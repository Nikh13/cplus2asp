/* 
 * Copyright (c) 2010-2013 <Joseph Babb, Michael Cassollary, Joohyung Lee>
 *
 * For information on how to contact the authors, please visit
 *	http://reasoning.eas.asu.edu/cplus2asp
 *
 * This file is part of the cplus2asp system.
 *
 * cplus2asp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * cplus2asp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/** @file cplus2asp.cpp
 *  @brief Calls a tool chain of a translator, pre-processor, answer set solver, and post-processor on a CCalc program translated to ASP syntax.
 *  @author v3.0+ Joseph Babb (v2.3- Michael Casolary)
 *  @date 07/2011
 */

/* History:
 * v3.1 - Restructured the interactive interface for more user friendly interactions.
 * v3.0 - Restructured options parser. Added incremental translation functionality. Added automated detection and handling of additive/abnormal constants.
 * v2.3 - Implemented "-from[PROG]" and "-to[PROG]" options to give better control over running a partial tool chain.
 * v2.2.2 - Fixed bugs, "-notrans" wasn't shutting off the translator, "-gropt" and "-grsoopt" were mixed up. Set up system to track when tool chain programs have errors.
 * v2.2.1 - Fixed bug where program might get wrong values back from system calls (depending on OS).
 * v2.2 - cplus2asp now supports integrated grounder-solvers (like clingo), using the option -grso / --grounder-solver. Added automatic searching though queries with ranged maxsteps, with an option to switch to manual mode (-mm). Removed support for using piped tool chain commands. Added automated "non-interactive" mode option (-auto).
 * v2.1.2 - Tweaked status outputs to be compatible with benchmarking scripts, adjusted output messages to make more sense.
 * v2.1.1 - Renamed to cplus2asp, also renamed translator & standard file dependencies.
 * v2.1 - Skips translating any files with .f2lp or .lp extensions, not just if all files have those extensions.
 * v2.0.1 - Made file name output more friendly, ensured all steps of the tool chain work together properly.
 * v2.0 - Added ccalc2asp.bin (translator) to tool chain, including options to control its usage, and an ability to interactively guess critical constant values based on hints given in comments in the input files.
 * v1.3.5 - Fixed bug with post-processor not receiving options correctly.
 * v1.3.4 - Now passes input file to solver via standard in redirection.
 * v1.3.3 - Added option to use pipes instead of intermediate files to send data between tool chain programs (i.e., pre-v1.3 behavior).
 * v1.3.2 - Sends input files to the first tool in the tool chain that isn't disabled.
 * v1.3.1 - Fixed bug with spaces in path causing odd behavior and errors from tool chain.
 * v1.3 - Changed default post-processor to as2transition, changed default standard files to ccalc2asp_std.f2lp & ccalc2asp_additive.f2lp, changed argument handler to allow generic "const=value" arguments without needing "-c" before them, added intermediate file usage and auto-deletion, added options to pass command-line options directly to any of the tool chain programs.
 * v1.2 - Added option to un-include the standard translation files from the call to the pre-processor.
 * v1.1 - Added options to turn off programs in the tool chain.
 * v1.0 - First working version.
 */

#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <list>
#include <climits> // for PATH_MAX, INT_MIN
#include <cstring>
#include <sys/types.h>
#include <unistd.h> // for realpath()
#include <errno.h>
#include <string.h>
#include <sys/wait.h>
#include <cstdlib>
#include <iomanip>

#include "Config.h"
#include "utils.h"
#include "Interpreter.h"

using namespace std;

#define VERSION_MAJOR 3
#define VERSION_MINOR 1
#define VERSION_REV 0

#ifndef PATH_MAX
  #define PATH_MAX 4096
#endif

/// An enum of the various command line options available.
enum Option {
	OPT_AUTO,
	OPT_BRIDGE,
	OPT_BRIDGE_OPTS,
	OPT_CONST,
	OPT_FRM_BRIDGE,
	OPT_FRM_GRD,
	OPT_FRM_PRE,
	OPT_FRM_POST,
	OPT_FROM_SO,
	OPT_FROM_TRAN,
	OPT_GRD,
	OPT_GRD_OPTS,
	OPT_JUST_GRD,
	OPT_JUST_PRE,
	OPT_JUST_POST,
	OPT_JUST_SO,
	OPT_JUST_TRANS,
	OPT_MAXSTEP,
	OPT_MINSTEP,
	OPT_MODE_SELECT,
	OPT_MODE_STATIC_AUTO,
	OPT_MODE_STATIC_MANUAL,
	OPT_MODE_INCREMENTAL,
	OPT_MODE_REACTIVE,
	OPT_NO_DEL,
	OPT_SHIFT,
	OPT_SHIFT_TRUE,
	OPT_SHIFT_FALSE,
	OPT_NO_STD,
	OPT_GRINGO_NONE_HACK,
	OPT_GRINGO_NONE_HACK_TRUE,
	OPT_GRINGO_NONE_HACK_FALSE,
	OPT_PORT_INTERNAL,
	OPT_PORT_EXTERNAL,
	OPT_POSTPROC,
	OPT_POSTPROC_OPTS,
	OPT_PREPROC,
	OPT_PREPROC_OPTS,
	OPT_SO,
	OPT_SO_OPTS,
	OPT_SO_WARN,
	OPT_TO_BRIDGE,
	OPT_TO_GRD,
	OPT_TO_PRE,
	OPT_TO_POST,
	OPT_TO_SO,
	OPT_TO_TRANS,
	OPT_TRANS,
	OPT_TRANS_OPTS,
	OPT_VERSION,
	OPT_HELP,
	OPT_QUERY,
	OPT_UNSUPPORTED,
	OPT_UNSUPPORTED_ADDITIVE,
	OPT_UNSUPPORTED_GRSO,
	OPT_UNSUPPORTED_MANUAL_MAXSTEP,
	OPT_UNKNOWN
};

/// Return codes from known tool chain programs indicating their final status.
enum StatusFlags
{
	TC_STAT_OK = 0,												///< Universal OK.
	TC_STAT_BG = 130,											///< Exit code indicating that the task is running in the background.
	TC_STAT_TOOLSKIPPED = INT_MIN,								///< Psuedo return code indicating that the tool execution was skipped for some reason.
	TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK = 0x80,			///< Bitmask to determine if cplus2asp detected abnormalities.
	TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK = 0x40,				///< Bitmask to determine if cplus2asp detected additive fluents.
	TC_STAT_SO_CLINGO_FOUND_SOLUTIONS = 10,						///< return code indicating that clingo (or other similar programs) found solutions.
	TC_STAT_SO_CLINGO_NO_SOLUTIONS = 20,						///< return code indicating that clingo (or other similar programs) failed to find solutions.
	TC_STAT_POSTPROC_AS2TRANSITION_NO_SOLUTIONS = 100,			///< return code indicating that as2transition failed to find solutions.
	TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS = 101		///< return code indicating that as2transition found solutions.
};

/// Status flags that can be returned by the options parser.
enum OptionStatus
{
	OPT_STAT_OK,			///< Everything is ok, continue execution.
	OPT_STAT_BAD_ARG,		///< One or more bad arguments was found. Stop execution.
	OPT_STAT_HELP,			///< The user requested the help message be displayed.
	OPT_STAT_VERSION		///< The user requested the version message be displayed.
};

/// Mode selection constants (for argument parsing)
#define ARG_MODE_STATIC_MANUAL  "static-manual"
#define ARG_MODE_STATIC_AUTO 	"static-auto"
#define ARG_MODE_INCREMENTAL	"incremental"
#define ARG_MODE_REACTIVE		"reactive"

/// Flags used to efficiently indicate that we're missing a constant.
#define CONST_MAXSTEP_MASK 		0x80
#define CONST_QUERY_MASK 		0x40
#define CONST_MAXADDITIVE_MASK  0x20
#define CONST_MINSTEP_MASK		0x10
#define CONST_EXT_PORT_MASK		0x08

/// The command used to exit the program during interactive prompts.
#define EXIT_CMD				"exit"

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt);

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out);

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out);

/**
 * Parses the provided command line arguments and sets the configurations appropriately.
 * @param argc The number of command line arguments provided to the program.
 * @param argv The command line arguments provided to the program.
 * @param[out] outConf The configurations object to write to.
 * @return A status flag indicating the results of the parsing.
 */
OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf);

 /**
  * [interactive] Queries the user to select an appropriate query number (and optional solution count) among the defined queries.
  * @param config The program's configuration options.
  * @param runconfig The run's configurations that will be updated.
  * @param first Whether this is the first run or not.
  * @param[out] runconfig The run's configurations that will be updated.
  * @return True if the program should continue execution, false otherwise.
  */
bool queryUserForQuery(Config const& config, Config::RunConfig& runconfig, bool first = false);

/**
 * Displays the queries which have been found.
 * @param config The program's configuration.
 * @param[out] output The output stream to write to.
 */
void showQueries(Config const& config, std::ostream& output);

/**
 * Displays the current run-time configuration for the system.
 * @param config the master configuration.
 * @param runconfig The overridin run configuration.
 * @param output The stream to output to.
 */
void showConfig(Config const& config, Config::RunConfig const& runconfig, std::ostream& output);

/**
 * [interactive] Queries the user to select a value for the specified constant.
 * @param config The program's configuration options.
 * @param constant The constant's name to ask for.
 * @param defval The default value of the constant (Config::UNDEFINED for no default).
 * @return The selected value or Config::UNDEFINED to indicate the user wishes to exit the program.
 */
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defval = Config::UNDEFINED);

/**
 * Scans through all of the available input files in order to attempt to find the required constants.
 * @param config The configuration for the program. The list of queries in the configuration may be added to.
 * @param ranTranslator Whether the translator was ran.
 */
void scanFilesForConstants(Config& config, bool ranTranslator);

 /**
  * Scans through a provided input files in order to attempt to find the required constants.
  * @param config The configuration for the program. The list of queries in the configuration may be added to.
  * @param file The name of the file to scan.
  */
void scanForConstants(Config& config, std::string const& file);

/**
 * Runs the specified tool in the toolchain IF it is not disabled in the toolchain configuration.
 * @param config The configuration for the program.
 * @param tool The tool to run.
 * @param name The human readable name of the tool (for output purposes).
 * @param subconfig The sub configuration settings which will override the configuration settings.
 * @return The status code from running the program (TC_STAT_TOOLSKIPPED indicates that it did not run).
 */
int runTool(Config const& config, Config::Toolchain tool, std::string const& name, Config::RunConfig const* subconfig = NULL);

/**
 * Cleans up the intermediate files generated during program execution.
 * @param config The program's configuration.
 * @param ran An array of booleans of length Config::TC_LENGTH detailing which components have ran.
 */
void cleanup(Config const& config, bool const* ran);

/**
 * Attempts to echo the specified file to the specified output stream.
 * @param out The output stream to print to.
 * @param filename The file to open.
 * @return True if the file exists, false otherwise.
 */
bool echoFile(std::ostream& out, std::string const& filename);

int main(int argc, char** argv)
{

	string strEXEName = argv[0]; 						// Name of this executable.
	string tmpCmd;				 						// temporary command string.

	vector<string> vecConstants; 						// List of constants to pass to the grounder.
	int intSystemResult = 0; 							// Holds what comes back from system().
	

	Config config;										// The almighty system configuration.

	bool ran[Config::TC_LENGTH];						// Variable used to track which toolchain components we have ran so far.
	memset(ran, 0, Config::TC_LENGTH);


	bool blnFoundSolutions = false; 					// Set to true if the solver or post-processor indicates solutions were found.


	/***************************************************************************************************/
	/* Command Line Parsing */
	/***************************************************************************************************/
	
	// Process command-line arguments.
	debug("Parsing Options...", true);
	switch (parseCommandOptions(argc, argv, config)) {
	case OPT_STAT_OK:
		// We're good to go!
		break;
	case OPT_STAT_BAD_ARG:
		error("A problem occurred parsing program arguments. Exiting.", true, 0);
		showHelp(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_BAD_ARGS,NULL);
		break;
	case OPT_STAT_HELP:
		showHelp(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_GOOD,NULL);
		break;
	case OPT_STAT_VERSION:
		showVersion(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_GOOD,NULL);
		break;
	}
	
	/***************************************************************************************************/
	/* Command Sanity Checks */
	/***************************************************************************************************/

	// Sanity checks...
	// Make sure that we aren't in manual mode with suppressed user interaction...
	if (config.mode() == Config::MODE_STATIC_MANUAL && config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {
		warning("Unable to manually advance the time step in with the '--auto' flag asserted. Switching to '%s' mode.", true, ARG_MODE_STATIC_AUTO);
		config.mode(Config::MODE_STATIC_AUTO);
	}

	// Ensure we are doing _something_
	bool doingSomething = false;
	for (Config::Toolchain tool = Config::TC_BEGIN; tool < Config::TC_END && !doingSomething; tool = (Config::Toolchain)(((int) tool) + 1)) {
		if (config.run(tool) && config.command(tool) != "")
			doingSomething = true;
	}
	if (!doingSomething) {
		// Everything is disabled.
		pragma("The toolchain is empty. Exiting.", true, EXT_CODE_GOOD);
	}

	debug("The command line options are sane.", true);
	/***************************************************************************************************/
	/* Translator */
	/***************************************************************************************************/

	
	// Run the translator if it's called for.
	debug("Beginning translator subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_TRANSLATOR, "translator")) != TC_STAT_TOOLSKIPPED) {

		// It Ran!
		ran[Config::TC_TRANSLATOR] = true;

		// check the status and make sure all is well...
		if((intSystemResult & ~TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK & ~TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK) != TC_STAT_OK)
		{
			cleanup(config, ran);
			error("An error occurred while executing the translator.",true, EXT_CODE_TOOLCHAIN_TRANS_ERR);
		}

		// Check for abnormalities...
		if (intSystemResult & TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK) {
			// The abnormality mask is set, meaning that there is at least one abnormality...

			if (!config.customMode()) {
				// They haven't specified a mode. Default to REACTIVE.
				pragma("One or more abnormality constants have been detected. Defaulting to the '%s' mode.", true, ARG_MODE_REACTIVE);
				config.mode(Config::MODE_REACTIVE);
			} else if (config.mode() == Config::MODE_STATIC_AUTO || config.mode() == Config::MODE_STATIC_MANUAL) {
				warning("One or more abnormality constants have been detected while operating in a static mode. This isn't recommended as many answer-sets will be generated.",true);
			}
		}

		if ((intSystemResult & TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK)) {
			// The additive mask is set, meaning that there is at least one additive constant...
			if (config.boolConfigOpt(Config::OPT_INCL_STD)) {
				pragma("One or more additive constants have been detected. Including the additive standard file.",true);
				config.boolConfigOpt(Config::OPT_INCL_ADDITIVE, true);
			} else {
				warning("One or more additive constants have been detected but the standard file has been suppressed. The additive standard file will not be included.",true);
			}
		}
	}

	/**********************************************************************************************************************/
	/* Pre-processor */
	/**********************************************************************************************************************/
	debug("Entering pre-processor subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_PREPROC, "pre-processor")) != TC_STAT_TOOLSKIPPED)  {
		// It Ran!
		ran[Config::TC_PREPROC] = true;

		// check the status and make sure all is well...
		if(intSystemResult != TC_STAT_OK)
		{
			cleanup(config, ran);
			error("An error occurred while executing the pre-processor.",true, EXT_CODE_TOOLCHAIN_PREPROC_ERR);
		}

	}

	/**********************************************************************************************************************/
	/* Intermediate Processing & Final Configuration */
	/**********************************************************************************************************************/

	debug("Translation done. Performing intermediate processing and final configuration.", true);


	// If any of the "critical" constants aren't defined and one of the
	// "active" tool chain programs is going to need the constants, try
	// finding "hint" comments in the input that we can use to fill in details.

	if (config.run(Config::TC_GROUNDER) || config.run(Config::TC_SOLVER)) {

		// We should determine the maxAdditive and port information outside of the interactive loop.
		// The query, maxstep, and minstep information can be determined from within.

		// If any of the "critical" constants aren't defined and one of the
		// "active" tool chain programs is going to need the constants, try
		// finding "hint" comments in the input that we can use to fill in details.

		unsigned int tmpVal;

		// Scan the files for the required constants. Hopefully one of them has it!
		// We should also scan the files in the event a query hasn't been specified (we'll need it!)
		if ((config.boolConfigOpt(Config::OPT_INCL_ADDITIVE) && !config.customConfigOpt(Config::OPT_MAXADDITIVE))
				|| config.intConfigOpt(Config::OPT_QUERY) == Config::UNDEFINED
				|| config.intConfigOpt(Config::OPT_MAXSTEP) == Config::UNDEFINED
				|| config.intConfigOpt(Config::OPT_MINSTEP) == Config::UNDEFINED)
			scanFilesForConstants(config, ran[Config::TC_TRANSLATOR]);

		// If all else fails, ask the user (unless we're not allowed to).
		if (config.intConfigOpt(Config::OPT_MAXADDITIVE) == Config::UNDEFINED
				&& config.boolConfigOpt(Config::OPT_INCL_ADDITIVE)) {

			if (!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

				if ((tmpVal = queryUserForConstant(config, "maxAdditive")) != Config::UNDEFINED) {
					// They gave us a maxAdditive value.
					config.intConfigOpt(Config::OPT_MAXADDITIVE, tmpVal);
				} else {
					// They elected to exit instead of answer a simple question.
					// Life moves on but we do not.
					cleanup(config, ran);
					nice_exit(0, "Exiting.");
				}
			} else {
				// we can't ask the user
				error("The maxAdditive constant was never defined and is required for program's containing additive constants. Exiting.", true, 0);
				cleanup(config, ran);
				nice_exit(EXT_CODE_UNDEFINED_CONSTANTS, NULL);
			}
		}

		if (config.run(Config::TC_SOLVER)) {
			if (config.intConfigOpt(Config::OPT_EXT_PORT) == Config::UNDEFINED
					&& config.mode() == Config::MODE_REACTIVE) {

				if (!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

					if ((tmpVal = queryUserForConstant(config, "external port")) != Config::UNDEFINED) {
						// They gave us a maxAdditive value.
						config.intConfigOpt(Config::OPT_EXT_PORT, tmpVal);
					} else {
						// They elected to exit instead of answer a simple question.
						// Life moves on but we do not.
						cleanup(config, ran);
						nice_exit(0, "Exiting.");
					}
				} else {
					// We can't ask the user.
					 error("The port to listen on for client connections is undefined and is required for the given running mode. Exiting.", true, 0);
					 cleanup(config, ran);
					 nice_exit(EXT_CODE_UNDEFINED_CONSTANTS, NULL);
				}
			}
		}

	}


	/************************************************************************************************/
	/* Outer Interactive Loop */
	/************************************************************************************************/

	Config::RunConfig runConfig;
	runConfig.numSoln = config.intConfigOpt(Config::OPT_NUM_SOLN);
	bool first = true;	
	do {
		unsigned int maxmaxstep = config.intConfigOpt(Config::OPT_MAXSTEP);
		Config::Query const* activeQuery = NULL;

		runConfig.maxstep = config.intConfigOpt(Config::OPT_MAXSTEP);
		runConfig.minstep = config.intConfigOpt(Config::OPT_MINSTEP);

		runConfig.queryId = config.intConfigOpt(Config::OPT_QUERY);

		/********************************************************************************************/
		/*  Run configurations */
		/********************************************************************************************/

		// Query
		if ((config.run(Config::TC_GROUNDER) || config.run(Config::TC_SOLVER))
				&& (config.intConfigOpt(Config::OPT_QUERY) == Config::UNDEFINED
						|| config.intConfigOpt(Config::OPT_MINSTEP) == Config::UNDEFINED
						|| config.intConfigOpt(Config::OPT_MAXSTEP) == Config::UNDEFINED)){


			// Query...
			if (runConfig.queryId == Config::UNDEFINED && !config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

				// The query hasn't been specified, try prompting them for it
				if (!queryUserForQuery(config, runConfig, first)) {

					// They elected to exit instead of answer a simple question.
					// Life moves on but we do not.
					cleanup(config, ran);
					nice_exit(0, "Exiting.");
				}

			} else if (runConfig.queryId == Config::UNDEFINED) {
				// Not specified and we can't prompt the for it.
				error("The query to execute was never specified. Exiting.", true, 0);
				cleanup(config, ran);
				nice_exit(EXT_CODE_UNDEFINED_CONSTANTS, NULL);
			}

			if ((activeQuery = config.query(runConfig.queryId)) == NULL) {
				error("The specified query was not found.", true, 0);
				cleanup(config, ran);
				nice_exit(EXT_CODE_INVALID_QUERY, NULL);
			}

			// Maxstep...
			// This can be solved if we have a query and it has a maxstep...
			if (runConfig.maxstep != Config::UNDEFINED) {
				maxmaxstep = runConfig.maxstep;
			} else if (activeQuery && activeQuery->maxstep != Config::UNDEFINED) {
				maxmaxstep = activeQuery->maxstep;
			} 

			// Minstep...
			// This can be solved if we have a query and it has a minstep...
			if (runConfig.minstep == Config::UNDEFINED) {

				if ( activeQuery && activeQuery->minstep != Config::UNDEFINED)
					runConfig.minstep = activeQuery->minstep;
				else
					runConfig.minstep = 0; // default to 0.
			}

		} else {
			// Look for the active query anyways.
			// Chances are we didn't end up parsing the files so we probably haven't seen it.
			activeQuery = config.query(runConfig.queryId);
		}


		/**********************************************************************************************************************/
		/* Interactive Loop */
		/**********************************************************************************************************************/


		/*********************************************************************************************/
		/* Initial Maxstep */
		/*********************************************************************************************/

		runConfig.maxstep = (config.mode() == Config::MODE_STATIC_AUTO || config.mode() == Config::MODE_STATIC_MANUAL)
				? runConfig.minstep
				: maxmaxstep;


		// Final sanity check on the min and max steps...
		if (runConfig.maxstep != Config::UNDEFINED && runConfig.minstep > runConfig.maxstep) {
			error("The maxstep value must be at least that of the minstep.", true, 0);
			cleanup(config, ran);
			nice_exit(EXT_CODE_INVALID_STEP_VALUE, NULL);
		}

		// run the rest of the tool chain at least once, but we may have to run it multiple times in one of the STATIC modes...
		debug("Entering primary interactive loop.", true);
		do
		{

			/*********************************************************************************************/
			/* Grounder */
			/*********************************************************************************************/
			debug("Entering grounder subroutine.", true);
			if ((intSystemResult = runTool(config, Config::TC_GROUNDER, "grounder", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
				// It Ran!
				ran[Config::TC_GROUNDER] = true;

				// check the status and make sure all is well...
				if(intSystemResult != TC_STAT_OK)
				{
					cleanup(config, ran);
					error("An error occurred while executing the grounder.",true, EXT_CODE_TOOLCHAIN_GROUNDER_ERR);
				}

			}

			/*********************************************************************************************/
			/* Header Logic */
			/*********************************************************************************************/

			// Print the solution header!
			if (config.run(Config::TC_SOLVER))
			{
				if (activeQuery)pragma("Running Query '%s'.", true, activeQuery->name.c_str());
				else pragma("Running Query '%d'.", true, runConfig.queryId);

				switch (config.mode()) {
				case Config::MODE_STATIC_AUTO:
				case Config::MODE_STATIC_MANUAL:
					if (runConfig.maxstep != Config::UNDEFINED)
						pragma("Maximum Step = '%d'.", true, runConfig.maxstep);
					else
						pragma("No Maximum Step.", true);
					break;

				case Config::MODE_INCREMENTAL:
				case Config::MODE_REACTIVE:
					// We can guarantee that at this point the minimum step is defined.
					if (runConfig.maxstep != Config::UNDEFINED)
						pragma("Minimum Step = '%d', Maximum Step = '%d'.", true, runConfig.minstep, runConfig.maxstep);
					else
						pragma("Minimum Step = '%d', No Maximum Step.", true, runConfig.minstep);
					break;

				default:
					break;
				}

				if (runConfig.numSoln == 0)
					pragma("Searching for all solutions.", true);
				else
					pragma("Searching for %d solutions.", true, runConfig.numSoln );
			}

			/*********************************************************************************************/
			/* Solver */
			/*********************************************************************************************/
			debug("Entering solver subroutine.", true);
			if ((intSystemResult = runTool(config, Config::TC_SOLVER, "solver", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
				// It Ran!
				ran[Config::TC_SOLVER] = true;
				bool ok = true;

				// check the status and make sure all is well...
				if (intSystemResult == TC_STAT_SO_CLINGO_FOUND_SOLUTIONS) {
					// Looks like we have solutions... YAY!
					blnFoundSolutions = true;
				} else if (intSystemResult == TC_STAT_SO_CLINGO_NO_SOLUTIONS) {
					pragma("No solutions found.", true);
				} else if (intSystemResult == TC_STAT_BG) {
					// The solver was launched in the background.
				} else if(intSystemResult != TC_STAT_OK) {
					ok = false;
				}

				if (!ok || !config.boolConfigOpt(Config::OPT_SQUELCH_SOLVER)) {
					// echo the warnings, if any
					if (!echoFile(std::cerr, config.intSoErrFile())) {
						error("Cannot display solver errors. The error file does not exist.", true, 0);
					}
				}

				if (!ok) {
					// something went wrong
					cleanup(config, ran);
					error("An error occurred while executing the solver.",true, EXT_CODE_TOOLCHAIN_SOLVER_ERR);
				}

			}

			/*********************************************************************************************/
			/* Post-processor */
			/*********************************************************************************************/
			// The post-processor is only run outside of reactive mode
			debug("Entering post-processor subroutine.", true);
			if (config.mode() != Config::MODE_REACTIVE) {
				if ((intSystemResult = runTool(config, Config::TC_POSTPROC, "post-processor", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
					// It Ran!
					ran[Config::TC_POSTPROC] = true;

					// check the status and make sure all is well...
					if (intSystemResult == TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS) {
						// Looks like we have solutions... YAY!
						blnFoundSolutions = true;
					} else if (intSystemResult == TC_STAT_POSTPROC_AS2TRANSITION_NO_SOLUTIONS) {

					} else if(intSystemResult != TC_STAT_OK) {
						cleanup(config, ran);
						error("An error occurred while executing the post-processor.",true, EXT_CODE_TOOLCHAIN_POSTPROC_ERR);
					}
				}
			}

			/*********************************************************************************************/
			/* Reactive Bridge */
			/*********************************************************************************************/

			// The reactive bridge is run inside of reactive mode.
			// NOTE: If we really are in reactive mode then they solver is still running the background!
			debug("Entering reactive bridge subroutine.", true);

			// TODO: The reactive bridge is currently disabled as it is not yet implemented.
			if (config.mode() == Config::MODE_REACTIVE) { 
#ifdef NO_REACTIVE_BRIDGE
			warning("The reactive bridge has not yet been completed. Due to this, the system will run as if the reactive bridge has been disabled and you will need to connect to oClingo directly.", true);
			warning("Please connect your external agent to oClingo, which is listening on port '%d'.", true, config.intConfigOpt(Config::OPT_EXT_PORT));

#else
				if ((intSystemResult = runTool(config, Config::TC_REACTIVE_BRIDGE, "reactive bridge", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
					// It Ran!
					ran[Config::TC_REACTIVE_BRIDGE] = true;

					// check the status and make sure all is well...
					if (intSystemResult == TC_STAT_BG) {
						// The reactive bridge was launched in the background.
					} else if(intSystemResult != TC_STAT_OK) {
						cleanup(config, ran);
						error("An error occurred while executing the reactive bridge.",true, EXT_CODE_TOOLCHAIN_REACTIVE_BRIDGE_ERR);
					}
				}
#endif 
			}

			/*********************************************************************************************/
			/* Maxstep Increment */
			/*********************************************************************************************/

			if (config.mode() == Config::MODE_STATIC_MANUAL) {
				runConfig.maxstep = queryUserForConstant(config, "maximum step", runConfig.maxstep+1);
			} else if (config.mode() == Config::MODE_STATIC_AUTO) {
				runConfig.maxstep++;
			}

		} while(
				// The loop should continue as long as we are:
				// * Running in static-manual mode and the user hasn't told us to stop, or
				// * Running in static-auto mode, we haven't reached the maximum step , and we haven't found solutions.
				(config.mode() == Config::MODE_STATIC_MANUAL && runConfig.maxstep != Config::UNDEFINED)
				|| (config.mode() == Config::MODE_STATIC_AUTO
						&& runConfig.maxstep != Config::UNDEFINED
						&& (maxmaxstep == Config::UNDEFINED || runConfig.maxstep <= maxmaxstep)
						&& !blnFoundSolutions)
				);


		first = false;

	} while
			// The outer loop should run as long as:
			// * We're not suppressing user interaction,
			// * We are running what looks like a grounder/solver,
			// * The user has not selected a query on the command line, and
			// * The user has not selected to exit the outer loop.
			(!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)
			&& (config.run(Config::TC_GROUNDER) || config.run(Config::TC_SOLVER))
			&& config.intConfigOpt(Config::OPT_QUERY) == Config::UNDEFINED);

	debug("Exiting interactive loop.", true);
	/**********************************************************************************************************************/
	/* Final Cleanup */
	/**********************************************************************************************************************/

	cleanup(config, ran);

	return 0;
}

OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf) {
	// Process command-line arguments.

	char const* tmpptr;
	size_t tmpoffset;
	char tmpPath[PATH_MAX];
	std::list<char const*> rawInputList;
	std::pair<unsigned int, unsigned int> steps;
	unsigned int tmpInt;
	Config::Mode mode;




	for(int i = 1; i < argc; i++)
	{
		debug("Parsing option '%s'.", true, argv[i]);
		switch (parseOption(argv[i])) {

		case OPT_AUTO:
			// This is supposed to be an automated run, don't ask the user for anything.
			if (outConf.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION, true)) {
				warning("Detected redefinition of option '%s'. Continuing with value '%s'",true,argv[i],"true");
			}
			break;

		case OPT_BRIDGE:
			// They are specifying a specific command for the bridge.

			if (++i < argc) {
				if (outConf.command(Config::TC_REACTIVE_BRIDGE, argv[i])) {
					warning("Detected redefinition of bridge command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_BRIDGE_OPTS:

			if (++i < argc) {
				if (outConf.opts(Config::TC_REACTIVE_BRIDGE, argv[i])) {
					warning("Detected redefinition of bridge command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;
		case OPT_CONST:
			// Constant Declaration...
			if(++i < argc && (tmpptr = strchr(argv[i],'=')) != NULL)
			{
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}

			} else {   // Set up for a constant without actually giving one, bad command line.
				error("Expected a constant definition of the form 'constant=value' after option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_FRM_BRIDGE:
			pragma("Running the toolchain from the reactive bridge is discouraged.",true);
			if (outConf.setRunFrom(Config::TC_REACTIVE_BRIDGE)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_GRD:
			// Don't run anything before the grounder.
			if (outConf.setRunFrom(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_PRE:
			// Don't run anything before the pre-processor.
			if (outConf.setRunFrom(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_POST:
			// Don't call anything before the post-processor (equivalent to "-justpost")
			if (outConf.setRunFrom(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_SO:
			// Don't run anything before the solver.
			if (outConf.setRunFrom(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_TRAN:
			// Don't call anything before the translator (basically a no-op option).
			if (outConf.setRunFrom(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_GRD:
			// They're giving us a specific executable to use as the grounder instead of the default.
			// Make sure a second argument follows, and save the new grounder.
			if (++i < argc) {
				if (outConf.command(Config::TC_GROUNDER, argv[i])) {
					warning("Detected redefinition of grounder command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_GRD_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_GROUNDER, argv[i])) {
					warning("Detected redefinition of grounder command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_GRINGO_NONE_HACK:
			// Specifying a none_hack value.
			if (++i < argc) {

				bool val;
				if (!strcmp(argv[i], "true")) {
					val = true;
				} else if (!strcmp(argv[i], "false")) {
					val = false;
				} else {
					error("Expected a boolean value 'true' or 'false' following the '%s' flag. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

				if (outConf.boolConfigOpt(Config::OPT_NONE_HACK, val)) {
					warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
				}

			} else {
				// setup for a command but they didn't deliver.
				error("Expected a boolean value 'true' or 'false following the '%s' flag. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_GRINGO_NONE_HACK_TRUE:
			// They want us to treat none as an integral type to circumvent a
			// bug in gringo that prevents grounding of certain domains otherwise.
			if (outConf.boolConfigOpt(Config::OPT_NONE_HACK, true)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;
			
		case OPT_GRINGO_NONE_HACK_FALSE:
			// They want us NOT to treat none as an integral type to circumvent a
			// bug in gringo that prevents grounding of certain domains otherwise.
			if (outConf.boolConfigOpt(Config::OPT_NONE_HACK, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;


		case OPT_JUST_GRD:
			// Just call the grounder program, no others.
			if (outConf.setOnlyRun(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_PRE:
			// Just call the preprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_POST:
			// Just call the postprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_SO:
			// Just call the solver program, no others.
			if (outConf.setOnlyRun(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_TRANS:
			// Just call the translator program, no others.
			if (outConf.setOnlyRun(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_MAXSTEP:

			if (++i >= argc) {
				error("Expected a maximum step following option '%s'. Exiting.",true,0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			} else if ((steps = Config::parseMaxstep(argv[i])).second == Config::UNDEFINED) {
				error("'%s' is not a valid step value. Exiting.",true,0, argv[i]);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_MAXSTEP, steps.second)
					|| (steps.first != Config::UNDEFINED && outConf.intConfigOpt(Config::OPT_MINSTEP, steps.first)))
			{
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
			}
			break;

		case OPT_MINSTEP:

			if (++i >= argc) {
				error("Expected a minimum step following option '%s'. Exiting.",true,0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			} else if (!from_string(tmpInt, argv[i])) {
				error("'%s' is not a valid step value. Exiting.",true,0, argv[i]);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_MINSTEP, tmpInt)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
			}

			break;

		case OPT_MODE_SELECT:

			if (++i < argc) {

				if (!strcmp(argv[i],ARG_MODE_STATIC_MANUAL)) {
					mode = Config::MODE_STATIC_MANUAL;
				} else if (!strcmp(argv[i],ARG_MODE_STATIC_AUTO)) {
					mode = Config::MODE_STATIC_AUTO;
				} else if (!strcmp(argv[i],ARG_MODE_INCREMENTAL)) {
					mode = Config::MODE_INCREMENTAL;
				} else if (!strcmp(argv[i],ARG_MODE_REACTIVE)) {
					mode = Config::MODE_INCREMENTAL;
				} else {
					error("Expected a mode option (one of '%s', '%s', '%s', or '%s') following option '%s'. Exiting.",true,0,
							ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, OPT_MODE_REACTIVE, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

				if (outConf.mode(mode)) {
					warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, argv[i]);
				}

			} else {
				error("Expected a mode option (one of '%s', '%s', '%s', or '%s') following option '%s'. Exiting.",true,0,
						ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, ARG_MODE_REACTIVE, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}

			break;

		case OPT_MODE_STATIC_AUTO:
			if (outConf.mode(Config::MODE_STATIC_AUTO)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_STATIC_AUTO);
			}
			break;

		case OPT_MODE_STATIC_MANUAL:
			if (outConf.mode(Config::MODE_STATIC_MANUAL)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_STATIC_MANUAL);
			}
			break;
		case OPT_MODE_INCREMENTAL:
			if (outConf.mode(Config::MODE_INCREMENTAL)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_INCREMENTAL);
			}
			break;

		case OPT_MODE_REACTIVE:
			if (outConf.mode(Config::MODE_REACTIVE)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_REACTIVE);
			}
			break;

		case OPT_NO_DEL:
			// Shut off deleting intermediate files.
			if (outConf.boolConfigOpt(Config::OPT_DISCARD_INTERMEDIATE, false)
					|/*non-short-circuiting*/ outConf.boolConfigOpt(Config::OPT_DISCARD_F2LP, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;


		case OPT_SHIFT:

			// Specifying a shift value.
			if (++i < argc) {

				bool val;
				if (!strcmp(argv[i], "true")) {
					val = true;
				} else if (!strcmp(argv[i], "false")) {
					val = false;
				} else {
					error("Expected a boolean value 'true' or 'false' following the '%s' flag. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

				if (outConf.boolConfigOpt(Config::OPT_SHIFT, val)) {
					warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
				}

			} else {
				// setup for a command but they didn't deliver.
				error("Expected a boolean value 'true' or 'false following the '%s' flag. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_SHIFT_FALSE:
			// Allow the solver to shift disjunction into the body.
			if (outConf.boolConfigOpt(Config::OPT_SHIFT, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_SHIFT_TRUE:
			// Do not allow the solve to shift disjunction into the body.
			if (outConf.boolConfigOpt(Config::OPT_SHIFT, true)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_NO_STD:
			// Don't include standard files in the final product.
			if (outConf.boolConfigOpt(Config::OPT_INCL_STD, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_PORT_EXTERNAL:
			// Set the external port to use in reactive mode
			int tmp;

			if (++i >= argc) {
				error("Expected a port number following option '%s'. Exiting.",true,0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			} else if (!from_string(tmp, argv[i]) || tmp < 1) {
				error("'%s' is not a valid port. Exiting.",true,0, argv[i]);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.boolConfigOpt(Config::OPT_EXT_PORT, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
			}

			break;

		case OPT_PORT_INTERNAL:
			// Set the internal port to use in reactive mode
			if (++i >= argc) {
				error("Expected a port number following option '%s'. Exiting.",true,0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			} else if (!from_string(tmp, argv[i]) || tmp < 1) {
				error("'%s' is not a valid port. Exiting.",true,0, argv[i]);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.boolConfigOpt(Config::OPT_EXT_PORT, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
			}

			break;

		case OPT_POSTPROC:
			// They're giving us a specific executable to use as the post-processor instead of the default.
			// Make sure a second argument follows, and save the new post-processor.
			if (++i < argc) {
				if (outConf.command(Config::TC_POSTPROC, argv[i])) {
					warning("Detected redefinition of post-processor command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_POSTPROC_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_POSTPROC, argv[i])) {
					warning("Detected redefinition of post-processor command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_PREPROC:
			// They're giving us a specific executable to use as the pre-processor instead of the default.
			// Make sure a second argument follows, and save the new pre-processor.
			if (++i < argc) {
				if (outConf.command(Config::TC_PREPROC, argv[i])) {
					warning("Detected redefinition of pre-processor command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_PREPROC_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_PREPROC, argv[i])) {
					warning("Detected redefinition of pre-processor command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;


		case OPT_SO:
			// They're giving us a specific executable to use as the solver instead of the default.
			// Make sure a second argument follows, and save the new solver.
			if (++i < argc) {
				if (outConf.command(Config::TC_SOLVER, argv[i])) {
					warning("Detected redefinition of solver command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_SO_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_SOLVER, argv[i])) {
					warning("Detected redefinition of solver command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_SO_WARN:
			// They want to see the warnings issued by the solver.
			if (outConf.boolConfigOpt(Config::OPT_SQUELCH_SOLVER, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_BRIDGE:
			if (outConf.setRunTo(Config::TC_REACTIVE_BRIDGE)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_GRD:
			// Shut off deleting intermediate files.
			if (outConf.setRunTo(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_PRE:
			// Run everything up to the pre-processor.
			if (outConf.setRunTo(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_POST:
			// Run everything up to the post-processor...
			if (outConf.setRunTo(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_SO:
			// Run everything up to the solver...
			if (outConf.setRunTo(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_TRANS:
			// Run everything up to the translator...
			if (outConf.setRunTo(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TRANS:
			// They're giving us a specific executable to use as the translator instead of the default.
			// Make sure a second argument follows, and save the new grounder.
			if (++i < argc) {
				if (outConf.command(Config::TC_TRANSLATOR, argv[i])) {
					warning("Detected redefinition of translator command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_TRANS_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_TRANSLATOR, argv[i])) {
					warning("Detected redefinition of translator command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_VERSION:
			return OPT_STAT_VERSION;

		case OPT_HELP:
			return OPT_STAT_HELP;

		case OPT_QUERY:
			if (++i >= argc) {
				error("Expected a query identifier following option '%s'. Exiting.",true,0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			} else if (!strcmp(argv[i], CONST_QUERY_NONE)) {
				if (outConf.intConfigOpt(Config::OPT_QUERY, Config::NO_QUERY)) {
					warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
				}
			} else if (!strcmp(argv[i], CONST_QUERY_STATES)) {
				if (outConf.intConfigOpt(Config::OPT_QUERY, Config::STATES_QUERY)) {
					warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
				}
			} else if (!strcmp(argv[i], CONST_QUERY_TRANSITIONS)) {
				if (outConf.intConfigOpt(Config::OPT_QUERY, Config::TRANSITIONS_QUERY)) {
					warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
				}
			} else if (!from_string(tmpInt, argv[i])) {
				error("'%s' is not a valid query identifier. Exiting.",true,0, argv[i]);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_QUERY, tmpInt)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i-1]);
			}
			break;

		case OPT_UNSUPPORTED:
			// Whatever this is, it's unsupported.
			warning("The '%s' option is no longer supported. It will be ignored.",true);
			break;

		case OPT_UNSUPPORTED_ADDITIVE:
			// They want us to include the additive standard file...
			// This option is deprecated and shouldn't be used.
			warning("The '%s' option is no longer supported. The additive file will be included automatically if additive constants are detected.",true,argv[i]);
			break;

		case OPT_UNSUPPORTED_GRSO:
			// They did something involving the explicit grounder/solver
			// We no longer support the explicit grounder/solver calls
			error("The '%s' option is no longer supported. We no longer use a dedicated grounder/solver in the toolchain. Please make use of the solver component instead.",true,0,argv[i]);

			// We probably aren't going to do what they want, go ahead and signal that something went wrong
			return OPT_STAT_BAD_ARG;

		case OPT_UNSUPPORTED_MANUAL_MAXSTEP:
			// Manually advance the maximum step of the program query
			error("The '%s' option is no longer supported. Please use that '--mode=static-manual' option instead.",true,0,argv[i]);
			break;

		case OPT_UNKNOWN:
			debug("The option isn't a recognized flag. Checking other possibilities.", true);
			if (argv[i][0] == '-')
			{
				// It appears to be a bad argument...
				error("Found an unrecognized argument '%s'. Exiting.",true,0,argv[i]);
				return OPT_STAT_BAD_ARG;
			}

			// If there's no "header" on the argument, it's either a constant declaration, an input file, or the number of solutions.
			else if(isInteger(argv[i]))
			{	// It looks like a number, atoi it and save that as the desired number of solutions.
				int numSolutions = atoi(argv[i]);
				if(numSolutions < 0) {
					warning("The number of solutions cannot be negative. Ignoring the argument.",true);
				} else {
					if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, (unsigned int)numSolutions)) {
						warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,argv[i]);
					}
				}
			}
			else if((tmpptr = strchr(argv[i],'=')) != NULL)
			{   // Found an equals sign in the argument, it's probably a "const=value" declaration.
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}
			}
			else
			{	// If it's not a number, it's probably an input file. Make sure it exists, and then save it to the list.

				if(realpath(argv[i], tmpPath) == NULL)
				{
					// Couldn't find the input file...
					error("Unable to locate input file '%s'. Exiting.",true,0,argv[i]);
					return OPT_STAT_BAD_ARG;
				}
				else
				{
					// Save all of the input files until we are done and can handle them...
					rawInputList.push_back(argv[i]);
				}
			}
			break;
		}
	}

	// We've finished parsing all of the arguments... Let's handle those pesky input files.
	debug("Handling input files...", true);
	if (!rawInputList.size()) {
		//uh-oh. They didn't specify any input files. This simply won't do.
		error("One or more input files must be specified.",true,0);
		return OPT_STAT_BAD_ARG;
	}

	// They've insisted on sticking with a given mode. Make sure they're aware if they're using an incompatible
	for (std::list<char const*>::iterator it = rawInputList.begin(); it != rawInputList.end(); it++) {
		Config::FileType type = outConf.addInput(*it);
		if (outConf.customMode() && type.known && !(type.runningMode & outConf.mode())) {
			warning("The file '%s' doesn't appear to be compatible with the current running mode.",true,*it);
		}
	}

	return OPT_STAT_OK;
}

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt) {
	char const* marker;

	/*!re2c
			re2c:define:YYCTYPE = "char";
			re2c:define:YYCURSOR = opt;
			re2c:yyfill:enable = 0;
			re2c:define:YYMARKER = marker;
			re2c:indent:top = 1;

			"-auto"|"--automated"					{ return OPT_AUTO; }
			"-c"|"--const"							{ return OPT_CONST; }
			"-br"|"--bridge"						{ return OPT_BRIDGE; }
			"-bropt"|"--bridge--opts"				{ return OPT_BRIDGE_OPTS; }
			"-frombr"|"--from-bridge"				{ return OPT_FRM_BRIDGE; }
			"-fromgr"|"--from-grounder"				{ return OPT_FRM_GRD; }
			"-frompre"|"--from-pre-processor"		{ return OPT_FRM_PRE; }
			"-frompost"|"--from-post-processor"		{ return OPT_FRM_POST; }
			"-fromso"|"--from-solver"				{ return OPT_FROM_SO; }
			"-fromtrans"|"--from-translator"		{ return OPT_FROM_TRAN; }
			"-gr"|"--grounder"						{ return OPT_GRD; }
			"-gropt"|"--grounder-opts"				{ return OPT_GRD_OPTS; }
			"-nh"									{ return OPT_GRINGO_NONE_HACK_TRUE; }
			"--none-hack"							{ return OPT_GRINGO_NONE_HACK_TRUE; }
			"--none-hack=true"						{ return OPT_GRINGO_NONE_HACK_TRUE; }
			"--none-hack=false"						{ return OPT_GRINGO_NONE_HACK_FALSE; }
			"-i"|"--internal-port"					{ return OPT_PORT_INTERNAL; }
			"-justgr"|"--just-grounder"				{ return OPT_JUST_GRD; }
			"-justpre"|"--just-pre-processor"		{ return OPT_JUST_PRE; }
			"-justpost"|"--just-post-processor"		{ return OPT_JUST_POST; }
			"-justso"|"--just-solver"				{ return OPT_JUST_SO; }
			"-justtrans"|"--just-translator"		{ return OPT_JUST_TRANS; }
			"-m"									{ return OPT_MODE_SELECT; }
			"--mode=static-auto"					{ return OPT_MODE_STATIC_AUTO; }
			"--mode=static-manual"					{ return OPT_MODE_STATIC_MANUAL; }
			"--mode=incremental"					{ return OPT_MODE_INCREMENTAL; }
			"--mode=reactive"						{ return OPT_MODE_REACTIVE; }
			"-max"|"--maxstep"						{ return OPT_MAXSTEP; }
			"-min"|"--minstep"						{ return OPT_MINSTEP; }
			"-nodel"|"--no-delete"					{ return OPT_NO_DEL; }
			"-nostd"|"--no-standard"				{ return OPT_NO_STD; }
			"-s"									{ return OPT_SHIFT_TRUE; }
			"--shift"								{ return OPT_SHIFT_TRUE; }
			"--shift=true"							{ return OPT_SHIFT_TRUE; }
			"--shift=false"							{ return OPT_SHIFT_FALSE; }
			"-p"|"--port"							{ return OPT_PORT_EXTERNAL; }
			"-post"|"--post-processor"				{ return OPT_POSTPROC; }
			"-postopt"|"--post-processor-opts"		{ return OPT_POSTPROC_OPTS; }
			"-pre"|"--pre-processor"				{ return OPT_PREPROC; }
			"-preopt"|"--pre-processor-opts"		{ return OPT_PREPROC_OPTS; }
			"-so"|"--solver"						{ return OPT_SO; }
			"-soopt"|"--solver-opts"				{ return OPT_SO_OPTS; }
			"-sw"|"--solver-warnings"				{ return OPT_SO_WARN; }
			"-togr"|"--to-grounder"					{ return OPT_TO_GRD; }
			"-topre"|"--to-pre-processor"			{ return OPT_TO_PRE; }
			"-topost"|"--to-post-processor"			{ return OPT_TO_POST; }
			"-toso"|"--to-solver"					{ return OPT_TO_SO; }
			"-totrans"|"--to-translator"			{ return OPT_TO_TRANS; }
			"-tobr"|"--to-bridge"					{ return OPT_TO_BRIDGE;	}
			"-trans"|"--translator"					{ return OPT_TRANS; }
			"-transopt"|"--translator-opts"			{ return OPT_TRANS_OPTS; }
			"-v"|"--version"						{ return OPT_VERSION; }
			"-q"|"--query"							{ return OPT_QUERY; }
			"-?"|"--help"							{ return OPT_HELP; }


			"-add"|"--additive"						{ return OPT_UNSUPPORTED_ADDITIVE; }
			"-fromgrso"|"--from-grounder-solver"	{ return OPT_UNSUPPORTED_GRSO; }
			"-grso"|"--grounder-solver"				{ return OPT_UNSUPPORTED_GRSO; }
			"-grsoopt"|"--grounder-solver-opts"		{ return OPT_UNSUPPORTED_GRSO; }
			"-justgrso"|"--just-grounder-solver"	{ return OPT_UNSUPPORTED_GRSO; }
			"-mm"|"--manual-maxstep"				{ return OPT_UNSUPPORTED_MANUAL_MAXSTEP; }
			"-nogr"|"--no-grounder"					{ return OPT_UNSUPPORTED; }
			"-nogrso"|"--no-grounder-solver"		{ return OPT_UNSUPPORTED; }
			"-nopre"|"--no-pre-processor"			{ return OPT_UNSUPPORTED; }
			"-nopost"|"--no-post-processor"			{ return OPT_UNSUPPORTED; }
			"-noso"|"--no-solver"					{ return OPT_UNSUPPORTED; }
			"-notrans"|"--no-translator"			{ return OPT_UNSUPPORTED; }
			"-pipe"|"--use-pipes"					{ return OPT_UNSUPPORTED; }
			"-togrso"|"--to-grounder-solver"		{ return OPT_UNSUPPORTED; }
			.										{ return OPT_UNKNOWN; }
		*/
}

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out) {
	out   << "Usage: " << execName << " INPUT_FILES [OPTIONS] [CONSTANTS] [NUM_SOLUTIONS]" << endl
		  << endl
		  << "Calls cplus2asp.bin (translator), f2lp (pre-processor), gringo (grounder)," << endl
		  << "clasp (solver), and as2transition (post-processor) on the input files" << endl
		  << "(CCalc-style files that have been translated to ASP/f2lp syntax), adding " << endl
		  << "\"standard\" CCalc to ASP translation support files and outputting the results " << endl
		  << "from as2transition." << endl
		  << endl
		  << "  INPUT_FILES ----------- A series of files in CCalc, ASP, or f2lp syntax." << endl
		  << "                          At least one input file is required." << endl
		  << "                          Any input files that have extensions \".f2lp\" or \".lp\"" << endl
		  << "                          will automatically not be passed to the translator." << endl
		  << endl
		  << "  OPTIONS --------------- Optional arguments that change the program's behavior." << endl
		  << endl
		  << "  CONSTANTS ------------- Constant definitions that are passed to the grounder." << endl
		  << "                          There are three special constants that are often seen in" << endl
		  << "                          CCalc programs, and so can be useful to manually set." << endl
		  << "                          These are not required to be defined if special \"hint\"" << endl
		  << "                          comments are placed in the output from the translator." << endl
		  << "                          * maxAdditive - The maximum additive integer (only needed if" << endl
		  << "                                          using additive fluents/actions)." << endl
		  << "                          * maxstep ----- The maximum time step to consider." << endl
		  << "                          * minstep ----- The minimum time step to consider." << endl
		  << "                          * query   ----- The query number (i.e., label) to select." << endl
		  << endl
		  << "  NUM_SOLUTIONS --------- The desired number of solutions for the solver to find." << endl
		  << "                          This should be a non-negative integer (0 or greater)." << endl
		  << "                          If not specified, defaults to 1." << endl
		  << endl
		  << "Normal Program Options:" << endl
		  << "  -auto" << endl
		  << "  --automated ----------- Makes the program run in automated mode, so it won't prompt" << endl
		  << "                          or ask for any information from the user." << endl
		  << endl
		  << "  CONST=VALUE" << endl
		  << "  -c CONST=VALUE" << endl
		  << "  --const CONST=VALUE --- Declares a constant & value pair to pass to gringo." << endl
		  << "                          You will probably need to at least declare values for" << endl
		  << "                          the constants maxstep, query, and possibly maxAdditive." << endl
		  << endl
		  << "  --help ---------------- Shows this usage message." << endl
		  << "  -v" << endl
		  << "  --version ------------- Outputs version information." << endl
		  << endl
		  << "  -m [MODE]" << endl
		  << "  --mode=[MODE] --------- Sets the program to run in the specified running mode." << endl
		  << "                          [MODE] can be one of the following: " << endl
		  << "                          * static-auto --- uses a static translation and automatically " << endl
		  << "                                            advances the queries maximum time step." << endl
		  << "                          * static-manual - uses a static translation and queries the " << endl
		  << "                                            user each time a solution isn't found for a " << endl
		  << "                                            new time step." << endl
		  << "                          * incremental --- [default] uses an incremental translation " << endl
		  << "                                            and solver for better efficiency while " << endl
		  << "                                            ranging over maxsteps in a query." << endl
		  << "                          * reactive ------ uses a incremental translation and reactive " << endl
		  << "                                            solver in order to dynamically adding abnormality " << endl
		  << "                                            constants during execution."  << endl
		  << endl
		  << " -q [QUERY]" << endl
		  << " --query [QUERY] -------- Sets the query to use from those available in the C+ domain. " << endl
		  << "                          [QUERY] should be a positive integer and should be defined in " << endl
		  << "                          the domain file." << endl
		  << endl
		  << " -max [STEP]" << endl
		  << " --maxstep [STEP] ------- Sets the maximum step to solve for to [STEP]. [STEP] must be a " << endl
		  << "                          positive integer or a finite positive range (i.e. '1..5')." << endl
		  << "                          A range is seen as shorthand for a combined minimum and maximum " << endl
		  << "                          step definition." << endl
		  << endl
		  << " -min [STEP]" << endl
		  << " --minstep [STEP] ------- Sets the minimum step to solve for to [STEP]. [STEP] must be a " << endl
		  << "                          positive integer." << endl
		  << endl
		  << " -p [PORT]" << endl
		  << " --port [PORT] ---------- Sets the port used to connect with external client programs. " << endl
		  << "                          This option is only valid in reactive mode." << endl
		  << " -i [PORT]" << endl
		  << " --internal-port [PORT] - Sets the port used for internal communication between the " << endl
		  << "                          reactive solver and bridge. This option is only valid in " << endl
		  << "                          reactive mode." << endl
		  << endl
		  << " -nh" << endl
		  << " --none-hack={true,false} Indicates that we should simulate the 'none' value as a integral " << endl
		  << "                          type. This is helpful for circumventing a bug in Gringo 3.0.4 that " << endl
		  << "                          sometimes prevents domains from properly grounding due to " << endl
		  << "                          unification issues." << endl
		  << endl
		  << " -s" << endl
		  << " --shift={true,false} --- Allows the sovler to shift disjunction in the head of a rule generated by the" << endl
		  << "                          pre-processor into the body. This is useful when the preprocessor generates" << endl
		  << "                          disjunctive rules and a disjunctive solver isn't available. May not be" << endl
		  << "                          guaranteed to preserve stable models." << endl
		  << endl
		  << "Extra Program Options:" << endl
		  << "  Options with [PROG] or [PROGRAM] in their name affect individual" << endl
		  << "  programs in the tool chain, depending on [PROG] or [PROGRAM]'s value." << endl
		  << "  Any option with [PROG] in its name should have [PROG] replaced with one of:" << endl
		  << "    gr (grounder), pre (pre-processor), post (post-processor), so (solver)," << endl
		  << "    trans (translator), or br (reactive bridge)." << endl
		  << "  Replace [PROGRAM] in the applicable options with one of the following:" << endl
		  << "    grounder, pre-processor, post-processor, solver, translator, or bridge." << endl
		  << endl
		  << "  -[PROG] PATH" << endl
		  << "  --[PROGRAM] PATH -------- Gives a new path to the desired tool chain program." << endl
		  << endl
		  << "  -[PROG]opt \"OPTS\"" << endl
		  << "  --[PROGRAM]-opts \"OPTS\" - Passes OPTS to the given tool chain program." << endl
		  << endl
		  << "  -from[PROG]" << endl
		  << "  --from-[PROGRAM] -------- Starts running the tool chain from the given program." << endl
		  << endl
		  << "  -just[PROG]" << endl
		  << "  --just-[PROGRAM] -------- Removes all but the given program from the tool chain." << endl
		  << endl
		  << "  -nodel" << endl
		  << "  --no-delete ------------- Stops the program from deleting intermediate files created" << endl
		  << "                            during processing, grounding, and solving." << endl
		  << endl
		  << "  -nostd" << endl
		  << "  --no-standard ----------- Removes the standard translation files from the call to the" << endl
		  << "                            pre-processor. Useful if supplying different \"standard\"" << endl
		  << "                            files, or for debugging of input file errors." << endl
		  << endl
		  << "  -to[PROG]" << endl
		  << "  --to-[PROGRAM] ---------- Stops running the tool chain after the given program." << endl
		  << endl
		  << "  -sw" << endl
		  << "  --solver-warnings ------- Displays all warnings originating from the solver." << endl
		  << "                            These are disabled by default as a number of warnings" << endl
		  << "                            regarding undefined atoms are normal due to the standard" << endl
		  << "                            files." << endl
		  << endl
		  << "  Example: " << execName << " myProgram.cp" << endl
		  << "           would translate and process the file \"myProgram.cp\"," << endl
		  << "           interactively asking which query from the file to run, returning" << endl
		  << "           the first solution found (if any)." << endl
		  << "  Example: " << execName << " myProgram.cp query=1 2" << endl
		  << "           does the same as above, except it automatically runs Query 1" << endl
		  << "           (assuming it can find or derive maxstep), and tries to find two" << endl
		  << "           solutions to the query." << endl
		  << "  Example: " << execName << " myProgram.cp query=1 maxstep=3 -so cmodels 2" << endl
		  << "           would do the same as above, but it changes the solver to cmodels" << endl
		  << "           and forces maxstep to be 3." << endl
		  << "  Example: " << execName << " myProgram.f2lp --just-pre-processor" << endl
		  << "           skips running the translator because the input file has" << endl
		  << "           the .f2lp extension, just running f2lp (the pre-processor)" << endl
		  << "           on the contents of \"myProgram.f2lp\", outputting the results." << endl;
	return out;
}

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out) {
	// Show version information and quit.
	out << execName << " version " << VERSION_MAJOR;
	out << "." << VERSION_MINOR;
	if(VERSION_REV > 0) { cout << "." << VERSION_REV; }
	return out;
}


void scanFilesForConstants(Config& config, bool ranTranslator) {


	// Go through the input file(s) looking for special "hint" comments
	// that tell us the value of maxAdditive, maxstep, and/or query.
	// Loop through the file(s) looking for hints for any undefined constants.

	// Start with the output of the translator
	if(config.run(Config::TC_TRANSLATOR))
	{	// Start with the output from the translator.
		debug("Starting with the translator output file...",true);
		scanForConstants(config, config.intTransFile());
	}


	// Scan all other input files
	for (Config::Toolchain tool = Config::TC_BEGIN; tool < Config::TC_END; tool = (Config::Toolchain)(((int) tool) + 1)) {
		for (Config::InputList::const_iterator it = config.beginInput(tool); it != config.endInput(tool); it++) {
			scanForConstants(config, *it);
		}

	}
}





void scanForConstants(Config& config, std::string const& file) {
	std::string tempLine = "";
	std::string tempString;
	std::ifstream fin;

	std::string findText = "";
	size_t tempPos, tempPos2;
	size_t currentLine = 0;

	bool foundQuery = false;
	unsigned int tempInt;
	Config::Query tempQuery;					// Temporary place to store query information.
	std::stringstream nameBuilder;


	// Open the file
	fin.open(file.c_str());

	// If at any point we fail to open an input file, just skip over it...
	if(fin.fail()) {
		// Throw a warning!
		warning("Unable to open file '%s' for scanning. Skipping it.", true, file.c_str());
	}


	while(!fin.eof()) {
		// Go line by line looking for specially-formatted comments.
		getline(fin, tempLine);
		currentLine++;
		if (tempLine.empty()) continue;

		// Look for a maxadditive definition
		if ( config.intConfigOpt(Config::OPT_MAXADDITIVE) == Config::UNDEFINED) {
			// Look for a maxAdditive hint comment.
			// If one is found, set maxAdditive

			findText = "% [MaxAdditive:";
			tempPos = tempLine.find(findText);

			if(tempPos != string::npos)
			{
				debug("Found what appears to be a maxAdditive definition: '%s'", true, tempLine.c_str());
				tempPos += findText.length();
				tempPos2 = tempLine.find("]", tempPos);
				if(tempPos2 != string::npos && tempPos2 > tempPos)
				{
					tempString = tempLine.substr(tempPos, tempPos2 - tempPos);
					if(from_string(tempInt, tempString))
					{
						// Found maxAdditive, set it and flag that we need the additive standard file.
						pragma("Found a maxAdditive hint. Setting maxAdditive to '%d'.", true, tempInt);
						config.intConfigOpt(Config::OPT_MAXADDITIVE, tempInt);
					} else {
						// It looks like this hint is malformed. Be sure to warn them!
						warning("The maxAdditive hint '%s' is malformed. Ignoring it.", true, tempLine.c_str());
					}
				}
			}
		}

		// Look for a query hint comment.
		// Collect any that are found.
		findText = "% [Query: Label:";

		if((tempPos = tempLine.find(findText)) != std::string::npos
				&& (tempPos += findText.length())
				&& (tempPos2 = tempLine.find_first_of(",]", tempPos)) != std::string::npos
				&& tempPos2 > tempPos)
		{
			foundQuery = false;
			debug("Found what appears to be a query definition: '%s'", true, tempLine.c_str());
			tempString = tempLine.substr(tempPos, tempPos2 - tempPos);

			if(from_string(tempInt, tempString)) {
				// Found a query's label, keep it and look for the maxstep...
				tempQuery.id = tempInt;

				findText = "Maxstep:";
				if (tempLine.at(tempPos2) != ']' // Don't bother if we're at the end of the hint...
						&& (tempPos = tempLine.find(findText, tempPos2)) != std::string::npos
						&& (tempPos += findText.length())
						&& (tempPos2 = tempLine.find("]", tempPos)) != std::string::npos
						&& tempPos2 > tempPos) {

					// This would be a maximum step definition
					// This could be an integer M
					// Or this could be a range M::N or M..N
					tempString = tempLine.substr(tempPos, tempPos2 - tempPos);

					size_t sepBegin, sepEnd;

					if (((sepBegin = tempString.find("::")) != std::string::npos
							|| (sepBegin = tempString.find("..")) != std::string::npos)
						&& (sepEnd = sepBegin + 2)
						&& from_string(tempQuery.minstep, tempString.substr(0, sepBegin))
						&& from_string(tempQuery.maxstep, tempString.substr(sepEnd, std::string::npos))){
						// The query is good and contains a minstep and maxstep.
						foundQuery = true;
					} else if (from_string(tempQuery.maxstep, tempString)) {
						// The query is good and contains only a maxstep.
						// The minstep is undefined.
						tempQuery.minstep = tempQuery.maxstep;
						foundQuery = true;
					} else {
						// The step information is malformed.
						// Warn them...
						warning("[%s:%d]: The query hint '%s' has a malformed step maxstep parameter. Ignoring the maximum step information...", true, file.c_str(), currentLine, tempLine.c_str());
						tempQuery.minstep = Config::UNDEFINED;
						tempQuery.maxstep = Config::UNDEFINED;
						foundQuery = true;
					}
				} else {
					// No maxstep information to be found. This is ok.
					tempQuery.maxstep = Config::UNDEFINED;
					tempQuery.maxstep = Config::UNDEFINED;
					foundQuery = true;
				}
			} else {
				// The query ID is malformed... Warn them and move on.
				warning("[%s:%d]: The query hint '%s' has a malformed query ID. Ignoring it.", true, file.c_str(), currentLine, tempLine.c_str());
			}

			if (foundQuery) {
				// The query was good. We can go ahead and register it.
				// Generate a name...
				nameBuilder.str("");
				nameBuilder << "Query " << tempQuery.id;

				//if (tempQuery.minstep != Config::UNDEFINED && tempQuery.maxstep != Config::UNDEFINED)
				//	nameBuilder << " (" << tempQuery.minstep << ".." << tempQuery.maxstep <<")";
				//else if (tempQuery.maxstep != Config::UNDEFINED)
				//	nameBuilder << " (" << tempQuery.maxstep <<")";

				tempQuery.name = nameBuilder.str();

				// Build the command
				nameBuilder.str("");
				nameBuilder << tempQuery.id;
				tempQuery.cmd = nameBuilder.str();

				// Attempt to register it.
				debug("Registering query '%s'...", true, tempQuery.name.c_str());
				if (!config.addQuery(tempQuery)) {
					warning("[%s:%d]: Detected duplicate queries with ID '%d'. Ignoring the most recent one found.", file.c_str(), currentLine, tempQuery.id);
				}
			}
		}
	}

	// Clean up and move on...
	fin.close();
}


// [interactive] Queries the user to select an appropriate query number (and optional solution count) among the defined queries.
bool queryUserForQuery(Config const& config, Config::RunConfig& runconfig, bool first)
{
	std::string line, value;
	Config::Query const* query;
	Interpreter::Action action;
	bool goodInput = false;
	std::pair<unsigned int, unsigned int> steps;


	if (first) {
		showQueries(config, std::cout);
		std::cout << std::endl;
		Interpreter::showHelp(std::cout);
	}

	while (!goodInput) {

		// Get user input
		goodInput = true;
		query = NULL;

		do {
			std::cout << "$- ";
			std::getline(std::cin,line);

			if (std::cin.eof()) {
				// gracefully handle ctrl-d
				return false;
			}


			// Interpret the command.
			action = Interpreter::interpret(line, value);
			switch (action) {
			case Interpreter::SHOW_QUERIES:
				showQueries(config, std::cout);
				break;
			case Interpreter::SHOW_CONFIG:
				showConfig(config, runconfig, std::cout);
				break;
			case Interpreter::SET_QUERY:

				// Scan through the queries and try to find the one they (hopefully) selected.
				for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries() && !query; it++) {
					if (it->second.cmd == value) {
						query = &(it->second);
					}
				}

				// make sure we got a query...
				if (!query) {
					goodInput = false;
					std::cout << "Invalid query selection.";
				}

				break;

			case Interpreter::SET_NUMSOLN:
				if (value == CONST_DEFAULT) runconfig.numSoln = Config::UNDEFINED;
				else goodInput = from_string(runconfig.numSoln, value);
				break;

			case Interpreter::SET_MAXSTEP:
				if (value == CONST_DEFAULT) runconfig.maxstep = Config::UNDEFINED;
				else {
					steps = Config::parseMaxstep(value);
					if (steps.second == Config::UNDEFINED) goodInput = false;
					else {
						if (steps.first != Config::UNDEFINED) runconfig.minstep = steps.first;
						runconfig.maxstep = steps.second;
	
						if (runconfig.minstep == Config::UNDEFINED) {
							std::cout << "Autosetting minstep to 0." << std::endl;
							runconfig.minstep = 0;
						}
					}
				}

				break;

			case Interpreter::SET_MINSTEP:
				if (value == CONST_DEFAULT) runconfig.minstep = Config::UNDEFINED;
				else goodInput = from_string(runconfig.minstep, value);
				break;
		
	
			case Interpreter::SHOW_HELP:
				Interpreter::showHelp(std::cout);
				break;

			case Interpreter::EXIT:
				// signal the exit.
				return false;
			default:
				// bad input
				goodInput = false;
				break;
			}

		} while ( goodInput && !query );

		if (!goodInput) {
			std::cout << "Error: Invalid choice.\n";
			std::cout << "Type 'help' to list the available commands.\n";
		}
	} while (!goodInput && !query);

	runconfig.queryId = query->id;
	return true;
}

// Displays the queries which have been found.
void showQueries(Config const& config, std::ostream& output) {

	output << "The following queries are available to run:" << std::endl << std::endl;


	for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries(); it++) {
		output << '\t' << std::setw(15) << std::right << it->second.cmd << ": " << std::setw(20) << std::left << it->second.name;

		if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED)
				|| (!config.customConfigOpt(Config::OPT_MAXSTEP) && it->second.maxstep != Config::UNDEFINED) ) {
			output << " [ ";
	
			if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED)) {
				output << it->second.minstep;
			} else {
				output << "0";
			}


			if (it->second.maxstep == Config::UNDEFINED)
				output << "...";
			else if ((it->second.minstep == Config::UNDEFINED && it->second.maxstep != 0)
					|| it->second.minstep != it->second.maxstep)
				output << ".." << it->second.maxstep;

			output << " ]";
		}
		output << std::endl;
	}

}

// Displays the current run-time configuration for the system.
void showConfig(Config const& config, Config::RunConfig const& runconfig, std::ostream& output) {
	unsigned int tmp, tmp2;

	// TODO: This REALLY needs to be cleaned up.

	output << "Current configuration:\n\n";

	// translation mode
	output << "\t\t" << std::setw(30) << std::left << "Translation Mode:";

	output << std::setw(20) << std::left;
	switch (config.mode()) {
	case Config::MODE_INCREMENTAL:
		output << "Incremental";
		break;

	case Config::MODE_REACTIVE:
		output << "Reactive";
		break;

	case Config::MODE_STATIC_AUTO:
		output << "Static (auto)";
		break;

	case Config::MODE_STATIC_MANUAL:
		output << "Static (manual)";
		break;
	}
 	output << std::endl;

	// number of solutions
	tmp2 = (config.intConfigOpt(Config::OPT_NUM_SOLN) != Config::UNDEFINED) ? config.intConfigOpt(Config::OPT_NUM_SOLN) : 1;
	tmp = (runconfig.numSoln != Config::UNDEFINED) ? runconfig.numSoln : tmp2;

	output << "\t\t" << std::setw(30) << std::left << "Number of solutions:";

	output << std::setw(20) << std::left;
	if (tmp) output << tmp;
	else output << "all";

	output << "[default: ";
 	if (tmp2) output << tmp2;
	else output << "all";
	output << " ]\n";

	// maximum soln step
	tmp2 = config.intConfigOpt(Config::OPT_MAXSTEP);
	tmp = (runconfig.maxstep != Config::UNDEFINED) ? runconfig.maxstep : tmp2;

	output << "\t\t" << std::setw(30) << std::left << "Maximum solution step:";
	
	output << std::setw(20) << std::left;
	if (tmp == Config::INF) output << CONST_MAXSTEP_INFINITE;
	else if (tmp != Config::UNDEFINED) output << tmp;
	else output << "query selected";
	
	output << "[default: ";
	if (tmp2 == Config::INF) output << CONST_MAXSTEP_INFINITE;
	else if (tmp2 != Config::UNDEFINED) output << tmp2;
	else output << "query selected";
	output << " ]\n";


	// minimum soln step	
	tmp2 = config.intConfigOpt(Config::OPT_MINSTEP);
	tmp = (runconfig.minstep != Config::UNDEFINED) ? runconfig.minstep : tmp2;
	
	output << "\t\t" << std::setw(30) << std::left << "Minimum solution step:";
	
	output << std::setw(20) << std::left;
	if (tmp != Config::UNDEFINED) output << tmp;
	else output << "query selected";
	
	output << "[default: ";
	if (tmp2 != Config::UNDEFINED) output << tmp2;
	else output << "query selected";
	output << " ]\n";
	 
}

// Asks the user to select a max step.
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defVal) {
	unsigned int ret = Config::UNDEFINED;
	std::string line;
	bool goodInput = false;

	while (!goodInput) {

		// Prompt user input
		std::cout << "Please select a (non-negative) value for the " << constant << ". You may input 'exit' to exit the program." << std::endl;
		std::cout << "Selected value";
		if (defVal != Config::UNDEFINED) std::cout << " [" << defVal << "]";
		std::cout << ": ";



		std::getline(std::cin,line);
		line = trimWhitespace(line);

		// Make sure they don't want to exit.
		if (line == EXIT_CMD) {
			// crap, they do. returning UNDEFINED will indicate this.
			goodInput = true;
			ret = Config::UNDEFINED;
		}
		// Check if they want to go for a default value
		else if (defVal != Config::UNDEFINED && line == "") {
			ret = defVal;
			goodInput = true;
		}
		// Check if they have provided any other valid input...
		else if (from_string(ret, line)) {
			goodInput = true;
		}

		if (!goodInput) {
			std::cout << "Error: Invalid selection." << std::endl;
		}

	}

	return ret;
}

int runTool(Config const& config, Config::Toolchain tool, std::string const& name, Config::RunConfig const* subconfig) {
	std::string tmpCmd;
	int ret = TC_STAT_TOOLSKIPPED;

	if (!config.run(tool)) {
		debug("Skipping %s execution.", true, name.c_str());
	} else if (!config.cumulativeInputCount(tool)) {
		pragma("No input files for the %s have been specified. Skipping it.", true, name.c_str());
	} else {
		// Run the translator...
		tmpCmd = config.compileCommandLine(tool, subconfig);
		debug("Running the %s with command: %s",true,name.c_str(), tmpCmd.c_str());
		int stat = system(tmpCmd.c_str());
		ret = WEXITSTATUS(stat);
	}

	return ret;
}

void cleanup(Config const& config, bool const* ran) {
	std::ostringstream builder;
	std::string tmpCmd;
	bool filesToDelete = false;

	builder << "rm";

	if (config.boolConfigOpt(Config::OPT_DISCARD_F2LP)) {
		// Discard F2LP intermediates...
		if (ran[Config::TC_PREPROC]) {
			builder << " " << F2LP_INPUT_FILE << " " << F2LP_OUTPUT_FILE;
			filesToDelete = true;
		}
	}

	if (config.boolConfigOpt(Config::OPT_DISCARD_INTERMEDIATE)) {
		if (ran[Config::TC_TRANSLATOR]) {
			builder << " " << config.intTransFile() << " " << config.intTransSymTabFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_PREPROC]) {
			builder << " " << config.intPreprocFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_GROUNDER]) {
			builder << " " << config.intGrdFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_SOLVER]) {
			builder << " " << config.intSoFile();
			builder << " " << config.intSoErrFile();
			filesToDelete = true;
		}
	}

	builder << " 2> /dev/null";

	if (filesToDelete) {
		tmpCmd = builder.str();
		debug("Deleting temporary files with command '%s'.", true, tmpCmd.c_str());
		system(tmpCmd.c_str());
	} else {
		debug("There are no files to delete.", true);
	}
}

/**
 * Attempts to echo the specified file to the specified output stream.
 * @param out The output stream to print to.
 * @param filename The file to open.
 * @return True if the file exists, false otherwise.
 */
bool echoFile(std::ostream& out, std::string const& filename) {
	std::ifstream file(filename.c_str());
	char buf[4096];

	if (file.fail()) {
		return false;
	}

	while (!file.eof()) {
		file.read(buf, 4096);
		out.write(buf, file.gcount());
	}

	return true;
}

