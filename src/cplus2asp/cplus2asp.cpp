/* Generated by re2c 0.16 on Wed May 11 18:56:24 2016 */
#line 1 "cplus2asp.r2c"
/* 
 * Copyright (c) 2010-2013 <Joseph Babb, Michael Cassollary, Joohyung Lee>
 *
 * For information on how to contact the authors, please visit
 *	http://reasoning.eas.asu.edu/cplus2asp
 *
 * This file is part of the cplus2asp system.
 *
 * cplus2asp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * cplus2asp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/** @file cplus2asp.cpp
 *  @brief Calls a tool chain of a translator, pre-processor, answer set solver, and post-processor on a CCalc program translated to ASP syntax.
 *  @author v2.0+ Joseph Babb (v1.0 Michael Casolary)
 *  @date 07/2011
 */

/* History:
 * v3.0 - Integration with the cplus2asp.bin v3.0 for enhanced language support.
 * v2.3 - Fixed several small issues. Added Syntactic checking for BC. Added experimental language BC+ as a proper extension of BC allowing arbitrary formulas in the body and choice rules in the head.
 * v2.2 - Major revision of command-line arguments. Revised command line calls to provide system portability.
 * v2.1 - Restructured the interactive interface for more user friendly interactions.
 * v2.0 - Restructured options parser. Added incremental translation functionality. Added automated detection and handling of additive/abnormal constants.
 * v1.7 - Implemented "-from[PROG]" and "-to[PROG]" options to give better control over running a partial tool chain.
 * v1.6.2 - Fixed bugs, "-notrans" wasn't shutting off the translator, "-gropt" and "-grsoopt" were mixed up. Set up system to track when tool chain programs have errors.
 * v1.6.1 - Fixed bug where program might get wrong values back from system calls (depending on OS).
 * v1.6 - cplus2asp now supports integrated grounder-solvers (like clingo), using the option -grso / --grounder-solver. Added automatic searching though queries with ranged maxsteps, with an option to switch to manual mode (-mm). Removed support for using piped tool chain commands. Added automated "non-interactive" mode option (-auto).
 * v1.5.2 - Tweaked status outputs to be compatible with benchmarking scripts, adjusted output messages to make more sense.
 * v1.5.1 - Renamed to cplus2asp, also renamed translator & standard file dependencies.
 * v1.5 - Skips translating any files with .f2lp or .lp extensions, not just if all files have those extensions.
 * v1.4.1 - Made file name output more friendly, ensured all steps of the tool chain work together properly.
 * v1.4 - Added ccalc2asp.bin (translator) to tool chain, including options to control its usage, and an ability to interactively guess critical constant values based on hints given in comments in the input files.
 * v1.3.5 - Fixed bug with post-processor not receiving options correctly.
 * v1.3.4 - Now passes input file to solver via standard in redirection.
 * v1.3.3 - Added option to use pipes instead of intermediate files to send data between tool chain programs (i.e., pre-v1.3 behavior).
 * v1.3.2 - Sends input files to the first tool in the tool chain that isn't disabled.
 * v1.3.1 - Fixed bug with spaces in path causing odd behavior and errors from tool chain.
 * v1.3 - Changed default post-processor to as2transition, changed default standard files to ccalc2asp_std.f2lp & ccalc2asp_additive.f2lp, changed argument handler to allow generic "const=value" arguments without needing "-c" before them, added intermediate file usage and auto-deletion, added options to pass command-line options directly to any of the tool chain programs.
 * v1.2 - Added option to un-include the standard translation files from the call to the pre-processor.
 * v1.1 - Added options to turn off programs in the tool chain.
 * v1.0 - First working version.
 */


#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <iterator>
#include <algorithm>
#include <utility>
#include <vector>
#include <list>
//#include <climits> // for PATH_MAX, INT_MIN
#include <cstring>
//#include <string.h>
//#include <cstdlib>
#include <iomanip>
#include <exception>

// Next 3 includes are for getting the home directory in linux
#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>

//Next 3 includes are for reading config files using Boost
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include <boost/algorithm/string.hpp>


#ifndef BOOST_FILESYSTEM_VERSION
#define BOOST_FILESYSTEM_VERSION 3
#endif
#define BOOST_NO_CXX11_SCOPED_ENUMS
#include <boost/filesystem.hpp>
#undef BOOST_NO_CXX11_SCOPED_ENUMS
#include <boost/iostreams/device/file_descriptor.hpp>
#include "boost/process.hpp"
#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>

#include "babb/utils/memory.h"
#include "bcplus/symbols/SymbolTable.h"
#include "bcplus/symbols/Symbol.h"
#include "bcplus/symbols/QuerySymbol.h"
#include "bcplus/symbols/ConstantSymbol.h"


#include "Config.h"
#include "utils.h"
#include "Interpreter.h"

namespace bp = boost::process;
namespace bfs = boost::filesystem;
namespace bio = boost::iostreams;

namespace u = babb::utils;
namespace bcp = bcplus;
namespace sy = bcplus::symbols;

#define VERSION_MAJOR 3
#define VERSION_MINOR 1
#define VERSION_REV 0

#ifndef PATH_MAX
  #define PATH_MAX 4096
#endif



/// An enum of the various command line options available.
enum Option {
	OPT_AUTO,
	OPT_BRIDGE,
	OPT_BRIDGE_OPTS,
	OPT_BRIDGE_OUT,
	OPT_CONST,
	OPT_FRM_BRIDGE,
	// OPT_FRM_GRD,
	OPT_FRM_PRE,
	OPT_FRM_POST,
	OPT_FROM_SO,
	OPT_FROM_TRAN,
	OPT_GRD,
	OPT_GRD_OPTS,
	OPT_GRD_OUT,
	OPT_GRINGO_NONE_HACK,
	OPT_JUST_GRD,
	OPT_JUST_PRE,
	OPT_JUST_POST,
	OPT_JUST_SO,
	OPT_JUST_TRANS,
	OPT_LANG,
	OPT_MAXSTEP,
	OPT_MINSTEP,
	OPT_MODE_SELECT,
	OPT_MODE_STATIC_AUTO,
	OPT_MODE_STATIC_MANUAL,
	OPT_MODE_INCREMENTAL,
	OPT_MODE_REACTIVE,
	OPT_NO_DEL,
	OPT_NO_DOMAIN_ENFORCE,
	OPT_NO_ADD_DOMAIN_ENFORCE,
	OPT_PORT_INTERNAL,
	OPT_PORT_EXTERNAL,
	OPT_POSTPROC,
	OPT_POSTPROC_OPTS,
	OPT_POSTPROC_OUT,
	OPT_PREPROC,
	OPT_PREPROC_OPTS,
	OPT_PREPROC_OUT,
	OPT_SHIFT,
	OPT_SO,
	OPT_SO_OPTS,
	OPT_SO_OUT,
	OPT_STATS,
	OPT_SYMTAB,
	OPT_TO_BRIDGE,
	OPT_TO_GRD,
	OPT_TO_PRE,
	OPT_TO_POST,
	OPT_TO_SO,
	OPT_TO_TRANS,
	OPT_TRANS,
	OPT_TRANS_OPTS,
	OPT_TRANS_OUT,
	OPT_VERSION,
	OPT_HELP,
	OPT_QUERY,
	OPT_UNSUPPORTED,
	OPT_UNSUPPORTED_NO_STD,
	OPT_UNSUPPORTED_ADDITIVE,
	OPT_UNSUPPORTED_GRSO,
	OPT_UNSUPPORTED_MANUAL_MAXSTEP,
	OPT_UNKNOWN
};

/// Return codes from known tool chain programs indicating their final status.
enum StatusFlags
{
	TC_STAT_OK = 0,												///< Universal OK.
	TC_STAT_BG = 130,											///< Exit code indicating that the task is running in the background.
	TC_STAT_IO_ERR = -8274,										///< Psuedo exit code indicating that we couldn't open the output file.
	TC_STAT_EXEC_ERR = -8273,									///, Psuedo exit code indicating that the tool failed to execute.
	TC_STAT_TOOLSKIPPED = INT_MIN,								///< Psuedo return code indicating that the tool execution was skipped for some reason.
	TC_STAT_SO_CLINGO_FOUND_SOLUTIONS = 10,						///< return code indicating that clingo (or other similar programs) found solutions.
	TC_STAT_SO_CLINGO_NO_SOLUTIONS = 20,						///< return code indicating that clingo (or other similar programs) failed to find solutions.
	TC_STAT_SO_CLINGO_SCRIPT_FOUND_SOLUTIONS = 30,						
	TC_STAT_POSTPROC_AS2TRANSITION_NO_SOLUTIONS = 100,			///< return code indicating that as2transition failed to find solutions.
	TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS = 101		///< return code indicating that as2transition found solutions.
};

/// Status flags that can be returned by the options parser.
enum OptionStatus
{
	OPT_STAT_OK,			///< Everything is ok, continue execution.
	OPT_STAT_BAD_ARG,		///< One or more bad arguments was found. Stop execution.
	OPT_STAT_HELP,			///< The user requested the help message be displayed.
	OPT_STAT_VERSION		///< The user requested the version message be displayed.
};

/// Mode selection constants (for argument parsing)
#define ARG_MODE_STATIC_MANUAL  "static-manual"
#define ARG_MODE_STATIC_AUTO 	"static-auto"
#define ARG_MODE_INCREMENTAL	"incremental"
#define ARG_MODE_REACTIVE		"reactive"

/// Flags used to efficiently indicate that we're missing a constant.
#define CONST_MAXSTEP_MASK 		0x80
#define CONST_QUERY_MASK 		0x40
#define CONST_MAXADDITIVE_MASK  0x20
#define CONST_MINSTEP_MASK		0x10
#define CONST_EXT_PORT_MASK		0x08

/// The command used to exit the program during interactive prompts.
#define EXIT_CMD				"exit"

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @param val A value for the option, where applicable (NULL otherwise).
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt, char const*& val);

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out);

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out);

/**
 * Parses the provided command line arguments and sets the configurations appropriately.
 * @param argc The number of command line arguments provided to the program.
 * @param argv The command line arguments provided to the program.
 * @param[out] outConf The configurations object to write to.
 * @return A status flag indicating the results of the parsing.
 */
OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf);

 /**
  * [interactive] Queries the user to select an appropriate query number (and optional solution count) among the defined queries.
  * @param config The program's configuration options.
  * @param runconfig The run's configurations that will be updated.
  * @param first Whether this is the first run or not.
  * @param[out] runconfig The run's configurations that will be updated.
  * @return True if the program should continue execution, false otherwise.
  */


bool queryUserForQuery(Config const& config, Config::RunConfig& runconfig, bool first = false);

OptionStatus parseConfigOptions(Config& outConf);

/**
 * Displays the queries which have been found.
 * @param config The program's configuration.
 * @param[out] output The output stream to write to.
 */
void showQueries(Config const& config, std::ostream& output);

/**
 * Displays the current run-time configuration for the system.
 * @param config the master configuration.
 * @param runconfig The overridin run configuration.
 * @param output The stream to output to.
 */
void showConfig(Config const& config, Config::RunConfig const& runconfig, std::ostream& output);

/**
 * [interactive] Queries the user to select a value for the specified constant.
 * @param config The program's configuration options.
 * @param constant The constant's name to ask for.
 * @param defval The default value of the constant (Config::UNDEFINED for no default).
 * @return The selected value or Config::UNDEFINED to indicate the user wishes to exit the program.
 */
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defval = Config::UNDEFINED);


/**
 * Runs the specified tool in the toolchain IF it is not disabled in the toolchain configuration.
 * @param config The configuration for the program.
 * @param tool The tool to run.
 * @param name The human readable name of the tool (for output purposes).
 * @param subconfig The sub configuration settings which will override the configuration settings.
 * @return The status code from running the program (TC_STAT_TOOLSKIPPED indicates that it did not run).
 */
int runTool(Config const& config, Config::Toolchain tool, std::string const& name, Config::RunConfig const* subconfig = NULL);


/**
 * @brief Processes the provided error file applying any error filters and printing the rest.
 * @param config The system configuration.
 * @param tool The tool that generated the error file.
 * @param file The error file.
 * @return True if the file exists and was successfully opened, false otherwise.
 */
bool processErrors(Config const& config, Config::Toolchain tool, std::string const& file);


/**
 * Cleans up the intermediate files generated during program execution.
 * @param config The program's configuration.
 * @param ran An array of booleans of length Config::_TC_LENGTH_ detailing which components have ran.
 */
#ifdef DEBUG
void cleanup(Config config, bool const* ran, bfs::path path);
#else
void cleanup(Config const& config, bool const* ran);
#endif


/**
 * Attempts to echo the specified file to the specified output stream.
 * @param out The output stream to print to.
 * @param filename The file to open.
 * @return True if the file exists, false otherwise.
 */
bool echoFile(std::ostream& out, std::string const& filename);

/**
 * Attempts to echo the solver stats from the specified file.
 * @param out The output stream to print to.
 * @param filename The file to read from.
 * @return True if the file exists and contains stats data that was printed, false otherwise.
 */
bool echoStats(std::ostream& out, std::string const& filename);

int main(int argc, char** argv)
{

	std::string strEXEName = argv[0]; 						// Name of this executable.
	std::string tmpCmd;				 						// temporary command string.

	std::vector<std::string> vecConstants; 						// List of constants to pass to the grounder.
	int intSystemResult = 0; 							// Holds what comes back from system().
	

	Config config(argv[0]);								// The almighty system configuration.

	bool ran[Config::_TC_LENGTH_];						// Variable used to track which toolchain components we have ran so far.
	memset(ran, 0, Config::_TC_LENGTH_);


	bool blnFoundSolutions = false; 					// Set to true if the solver or post-processor indicates solutions were found.


	#ifdef DEBUG
	bfs::path selfpath = argv[0];
	#endif
	/***************************************************************************************************/
	/* Command Line Parsing */
	/***************************************************************************************************/
	
	// Process command-line arguments.
	utils::debug("Parsing Options...", true);

	//Read config options from config file and give it lower precedence by executing it first
	OptionStatus optConf = parseConfigOptions(config);
	// Read config options from command line
	OptionStatus optCmd = parseCommandOptions(argc, argv, config);

	if(optCmd != OPT_STAT_OK || optConf != OPT_STAT_OK){

		//Switch on config options from command line because errors in config file would most likely be thrown in parseConfigOptions
		switch (optCmd) {
		case OPT_STAT_OK:
			// We're good to go!
			break;
		case OPT_STAT_BAD_ARG:
			utils::error("A problem occurred parsing program arguments. Exiting.", true, 0);
			showHelp(strEXEName, std::cout);
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::nice_exit(utils::EXT_CODE_BAD_ARGS,NULL);
			break;
		case OPT_STAT_HELP:
			showHelp(strEXEName, std::cout);
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::nice_exit(utils::EXT_CODE_GOOD,NULL);
			break;
		case OPT_STAT_VERSION:
			showVersion(strEXEName, std::cout);
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::nice_exit(utils::EXT_CODE_GOOD,NULL);
			break;
		default:
			break;
		}
	}
	
	/***************************************************************************************************/
	/* Command Sanity Checks */
	/***************************************************************************************************/

	// Sanity checks...
	// Make sure that we aren't in manual mode with suppressed user interaction...
	if (config.mode() == Config::MODE_STATIC_MANUAL && config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {
		utils::warning("Unable to manually advance the time step in with the '--auto' flag asserted. Switching to '%s' mode.", true, ARG_MODE_STATIC_AUTO);
		config.mode(Config::MODE_STATIC_AUTO);
	}

	// Ensure we are doing _something_
	bool doingSomething = false;
	for (Config::Toolchain tool = Config::_TC_BEGIN_; tool < Config::_TC_END_ && !doingSomething; tool = (Config::Toolchain)(((int) tool) + 1)) {
		if (config.run(tool) && config.command(tool) != "")
			doingSomething = true;
	}
	if (!doingSomething) {
		// Everything is disabled.
		utils::pragma("The toolchain is empty. Exiting.", true, utils::EXT_CODE_GOOD);
	}

	utils::debug("The command line options are sane.", true);
	/***************************************************************************************************/
	/* Translator */
	/***************************************************************************************************/

	
	// Run the translator if it's called for.
	utils::debug("Beginning translator subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_TRANSLATOR, "translator")) != TC_STAT_TOOLSKIPPED) {

		// It Ran!
		ran[Config::TC_TRANSLATOR] = true;

		if (!config.run(Config::TC_PREPROC)) {
			if (!echoFile(std::cout, config.output(Config::TC_TRANSLATOR))) {
				utils::error("Unable to read from the translator output file '%s'", true, -1, config.output(Config::TC_TRANSLATOR).c_str());
			}
		}


		// check the status and make sure all is well...

		if(intSystemResult != TC_STAT_OK)
		{
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::error("An error occurred while executing the translator.",true, utils::EXT_CODE_TOOLCHAIN_TRANS_ERR);
		}


	}

	/**********************************************************************************************************************/
	/* Pre-processor */
	/**********************************************************************************************************************/
	utils::debug("Entering pre-processor subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_PREPROC, "pre-processor")) != TC_STAT_TOOLSKIPPED)  {
		// It Ran!
		ran[Config::TC_PREPROC] = true;

		if (!config.run(Config::TC_SOLVER)) {
			if (!echoFile(std::cout, config.output(Config::TC_PREPROC))) {
				utils::error("Unable to read from the pre-processor output file '%s'", true, -1, config.output(Config::TC_PREPROC).c_str());
			}
		}
		
		// check the status and make sure all is well...
		if(intSystemResult != TC_STAT_OK)
		{
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::error("An error occurred while executing the pre-processor.",true, utils::EXT_CODE_TOOLCHAIN_PREPROC_ERR);
		}

	}

	utils::debug("Entering clingo3to4 translator subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_C4_PREPROC, "c4-pre-processor")) != TC_STAT_TOOLSKIPPED)  {
		// It Ran!
		ran[Config::TC_C4_PREPROC] = true;

		if (!config.run(Config::TC_SOLVER)) {
			if (!echoFile(std::cout, config.output(Config::TC_PREPROC))) {
				utils::error("Unable to read from the c4 pre-processor output file '%s'", true, -1, config.output(Config::TC_PREPROC).c_str());
			}
		}
		
		// check the status and make sure all is well...
		if(intSystemResult != TC_STAT_OK)
		{
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::error("An error occurred while executing the c4 pre-processor.",true, utils::EXT_CODE_TOOLCHAIN_PREPROC_ERR);
		}

	}

	/**********************************************************************************************************************/
	/* Intermediate Processing & Final Configuration */
	/**********************************************************************************************************************/

	utils::debug("Translation done. Performing intermediate processing and final configuration.", true);



	// Load the input symbol table
	u::ref_ptr<bcp::Configuration> bcpconf = new bcp::Configuration(NULL, NULL);
	bcpconf->symtabInput(new ReferencedPath(config.strOpt(Config::STR_SYMTAB_FILE)));
	u::ref_ptr<sy::SymbolTable> symtab = new sy::SymbolTable(bcpconf);

	// Load queries from the symbol table...
	for(sy::SymbolTable::const_iterator it = symtab->begin(sy::Symbol::Type::QUERY);it != symtab->end(sy::Symbol::Type::QUERY); it++) {
	
		sy::QuerySymbol const* q = (sy::QuerySymbol const*)(it->get());

		if (!config.addQuery(*q->base(), *q->base(), q->maxmax(), q->minmax())) {
			utils::error("Could not add query \"%s\" as it appears to be a duplicate.",true,0,q->base()->c_str());
		}

	}


	// Load constants from the symbol table...

	if (config.intConfigOpt(Config::OPT_MAXADDITIVE) == Config::UNDEFINED) {
		// check maxAdditive, then check maxAFValue
		u::ref_ptr<const ReferencedString> v = symtab->getData("maxAdditive");
		if (!v) v = symtab->getData("maxAFValue");
		if (v) {
			config.intConfigOpt(Config::OPT_MAXADDITIVE, boost::lexical_cast<unsigned int>(*v));
		}
	}
		

	// Check for abnormalities...
	if (symtab->cmask() & sy::ConstantSymbol::Type::M_EXTERNAL) {
		// The abnormality mask is set, meaning that there is at least one abnormality...

		if (!config.customMode()) {
			// They haven't specified a mode. Default to REACTIVE.
			utils::pragma("One or more external constants have been detected. Defaulting to the '%s' mode.", true, ARG_MODE_REACTIVE);
			config.mode(Config::MODE_REACTIVE);
		} else {
			utils::warning("One or more external constants have been detected while operating in a non-reactive mode.", true);
		}
	}


	// Ask the user about other constants...


	// If any of the "critical" constants aren't defined and one of the
	// "active" tool chain programs is going to need the constants, try
	// finding "hint" comments in the input that we can use to fill in details.
	if (config.run(Config::TC_SOLVER)) {

		// If all else fails, ask the user (unless we're not allowed to).
		unsigned int tmpVal = Config::UNDEFINED;
		if (config.intConfigOpt(Config::OPT_MAXADDITIVE) == Config::UNDEFINED
				&& (symtab->cmask() & sy::ConstantSymbol::Type::M_ADDITIVE)) {

			if (!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

				if ((tmpVal = queryUserForConstant(config, "maxAdditive")) != Config::UNDEFINED) {
					// They gave us a maxAdditive value.
					config.intConfigOpt(Config::OPT_MAXADDITIVE, tmpVal);
				} else {
					// They elected to exit instead of answer a simple question.
					// Life moves on but we do not.
					#ifdef DEBUG
					cleanup(config, ran, selfpath);
					#else
					cleanup(config, ran);
					#endif
					utils::nice_exit(0, "Exiting.");
				}
			} else {
				// we can't ask the user
				utils::error("The maxAdditive constant was never defined and is required for program's containing additive constants. Exiting.", true, 0);
				#ifdef DEBUG
				cleanup(config, ran, selfpath);
				#else
				cleanup(config, ran);
				#endif
				utils::nice_exit(utils::EXT_CODE_UNDEFINED_CONSTANTS, NULL);
			}
		}

		if (config.run(Config::TC_SOLVER)) {
/*
			if (config.intConfigOpt(Config::OPT_EXT_PORT) == Config::UNDEFINED
					&& config.mode() == Config::MODE_REACTIVE) {

				if (!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

					if ((tmpVal = queryUserForConstant(config, "external port")) != Config::UNDEFINED) {
						// They gave us a maxAdditive value.
						config.intConfigOpt(Config::OPT_EXT_PORT, tmpVal);
					} else {
						// They elected to exit instead of answer a simple question.
						// Life moves on but we do not.
						cleanup(config, ran);
						utils::nice_exit(0, "Exiting.");
					}
				} else {
					// We can't ask the user.
					 utils::error("The port to listen on for client connections is undefined and is required for the given running mode. Exiting.", true, 0);
					 cleanup(config, ran);
					 utils::nice_exit(utils::EXT_CODE_UNDEFINED_CONSTANTS, NULL);
				}
			}
*/
		}

	}


	/************************************************************************************************/
	/* Outer Interactive Loop */
	/************************************************************************************************/

	Config::RunConfig runConfig;
	runConfig.numSoln = config.intConfigOpt(Config::OPT_NUM_SOLN);
	bool first = true;	
	do {
		unsigned int maxmaxstep = config.intConfigOpt(Config::OPT_MAXSTEP);
		Config::Query const* activeQuery = NULL;

		runConfig.maxstep = config.intConfigOpt(Config::OPT_MAXSTEP);
		runConfig.minstep = config.intConfigOpt(Config::OPT_MINSTEP);

		runConfig.query = config.strOpt(Config::STR_QUERY);

		

		/********************************************************************************************/
		/*  Run configurations */
		/********************************************************************************************/

		// Query
		if (config.run(Config::TC_SOLVER)
				&& (config.strOpt(Config::STR_QUERY) == ""
						|| config.intConfigOpt(Config::OPT_MINSTEP) == Config::UNDEFINED
						|| config.intConfigOpt(Config::OPT_MAXSTEP) == Config::UNDEFINED)){


			// Query...
			if (runConfig.query == "" && !config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

				// The query hasn't been specified, try prompting them for it
				if (!queryUserForQuery(config, runConfig, first)) {

					// They elected to exit instead of answer a simple question.
					// Life moves on but we do not.
					#ifdef DEBUG
					cleanup(config, ran, selfpath);
					#else
					cleanup(config, ran);
					#endif
					utils::nice_exit(0, "Exiting.");
				}

			} else if (runConfig.query == "") {
				// Not specified and we can't prompt the for it.
				utils::error("The query to execute was never specified. Exiting.", true, 0);
				#ifdef DEBUG
				cleanup(config, ran, selfpath);
				#else
				cleanup(config, ran);
				#endif
				utils::nice_exit(utils::EXT_CODE_UNDEFINED_CONSTANTS, NULL);
			}

			if ((activeQuery = config.query(runConfig.query)) == NULL) {
				utils::error("The specified query was not found.", true, 0);
				#ifdef DEBUG
				cleanup(config, ran, selfpath);
				#else
				cleanup(config, ran);
				#endif
				utils::nice_exit(utils::EXT_CODE_INVALID_QUERY, NULL);
			}

			// Maxstep...
			// This can be solved if we have a query and it has a maxstep...
			if (runConfig.maxstep != Config::UNDEFINED) {
				maxmaxstep = runConfig.maxstep;
			} else if (activeQuery && activeQuery->maxstep != Config::UNDEFINED) {
				maxmaxstep = activeQuery->maxstep;
			} 

			// Minstep...
			// This can be solved if we have a query and it has a minstep...
			if (runConfig.minstep == Config::UNDEFINED) {

				if ( activeQuery && activeQuery->minstep != Config::UNDEFINED)
					runConfig.minstep = activeQuery->minstep;
				else
					runConfig.minstep = 0; // default to 0.
					// runConfig.minstep = 1; //default to 1. In clingo4 minstep=0 is UNKNOWN unlike in clingo3 
			}
			

		} else {
			// Look for the active query anyways.
			// Chances are we didn't end up parsing the files so we probably haven't seen it.
			activeQuery = config.query(runConfig.query);
		}

		/**********************************************************************************************************************/
		/* Interactive Loop */
		/**********************************************************************************************************************/


		/*********************************************************************************************/
		/* Initial Maxstep */
		/*********************************************************************************************/

		runConfig.maxstep = (config.mode() == Config::MODE_STATIC_AUTO || config.mode() == Config::MODE_STATIC_MANUAL)
				? runConfig.minstep
				: maxmaxstep;
		

		// Final sanity check on the min and max steps...
		if (runConfig.maxstep != Config::UNDEFINED && runConfig.minstep > runConfig.maxstep) {
			utils::error("The maxstep value must be at least that of the minstep.", true, 0);
			#ifdef DEBUG
			cleanup(config, ran, selfpath);
			#else
			cleanup(config, ran);
			#endif
			utils::nice_exit(utils::EXT_CODE_INVALID_STEP_VALUE, NULL);
		}

		// run the rest of the tool chain at least once, but we may have to run it multiple times in one of the STATIC modes...
		utils::debug("Entering primary interactive loop.", true);
		do
		{

			/*********************************************************************************************/
			/* Grounder */
			/*********************************************************************************************/
			// utils::debug("Entering grounder subroutine.", true);
			// if ((intSystemResult = runTool(config, Config::TC_GROUNDER, "grounder", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
			// 	// It Ran!
			// 	ran[Config::TC_GROUNDER] = true;
			// 	if (!config.run(Config::TC_SOLVER)) {
			// 		if (!echoFile(std::cout, config.output(Config::TC_GROUNDER))) {
			// 			utils::error("Unable to read from the grounder output file '%s'", true, -1, config.output(Config::TC_GROUNDER).c_str());
			// 		}
			// 	}

			// 	// check the status and make sure all is well...
			// 	if(intSystemResult != TC_STAT_OK)
			// 	{
			// 		cleanup(config, ran);
			// 		utils::error("An error occurred while executing the grounder.",true, utils::EXT_CODE_TOOLCHAIN_GROUNDER_ERR);
			// 	}

			// }

			/*********************************************************************************************/
			/* Header Logic */
			/*********************************************************************************************/

			// Print the solution header!
			if (config.run(Config::TC_SOLVER))
			{
				if (activeQuery)utils::pragma("Running Query '%s'.", true, activeQuery->name.c_str());
				else utils::pragma("Running Query '%s'.", true, runConfig.query.c_str());

				switch (config.mode()) {
				case Config::MODE_STATIC_AUTO:
				case Config::MODE_STATIC_MANUAL:
					if (runConfig.maxstep != Config::UNDEFINED)
						utils::pragma("Maximum Step = '%d'.", true, runConfig.maxstep);
					else
						utils::pragma("No Maximum Step.", true);
					break;

				case Config::MODE_INCREMENTAL:
				case Config::MODE_REACTIVE:
					// We can guarantee that at this point the minimum step is defined.
					if (runConfig.maxstep != Config::UNDEFINED)
						utils::pragma("Minimum Step = '%d', Maximum Step = '%d'.", true, runConfig.minstep, runConfig.maxstep);
					else
						utils::pragma("Minimum Step = '%d', No Maximum Step.", true, runConfig.minstep);
					break;

				default:
					break;
				}

				if (runConfig.numSoln == 0)
					utils::pragma("Searching for all solutions.", true);
				else
					utils::pragma("Searching for %d solutions.", true, runConfig.numSoln );
			}

			/*********************************************************************************************/
			/* Solver */
			/*********************************************************************************************/
			utils::debug("Entering solver subroutine.", true);
			if ((intSystemResult = runTool(config, Config::TC_SOLVER, "solver", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
				// It Ran!
				ran[Config::TC_SOLVER] = true;
				bool ok = true;

				if (!config.run(Config::TC_POSTPROC) && config.mode() != Config::MODE_REACTIVE) {
					if (!echoFile(std::cout, config.output(Config::TC_SOLVER))) {
						utils::error("Unable to read from the solver output file '%s'", true, -1, config.output(Config::TC_SOLVER).c_str());
					}
				}
				
				// check the status and make sure all is well...
				if (intSystemResult == TC_STAT_SO_CLINGO_FOUND_SOLUTIONS || intSystemResult == TC_STAT_SO_CLINGO_SCRIPT_FOUND_SOLUTIONS) {
					// Looks like we have solutions... YAY!
					blnFoundSolutions = true;
				} else if (intSystemResult == TC_STAT_SO_CLINGO_NO_SOLUTIONS) {
					utils::pragma("No solutions found.", true);
				} else if (intSystemResult == TC_STAT_BG) {
					// The solver was launched in the background.
				} else if(intSystemResult != TC_STAT_OK) {
					ok = false;
				}


				if (!ok) {
					// something went wrong
					#ifdef DEBUG
					cleanup(config, ran, selfpath);
					#else
					cleanup(config, ran);
					#endif
					utils::error("An error occurred while executing the solver.",true, utils::EXT_CODE_TOOLCHAIN_SOLVER_ERR);
				}

			}

			/*********************************************************************************************/
			/* Post-processor */
			/*********************************************************************************************/
			// The post-processor is only run outside of reactive mode
			utils::debug("Entering post-processor subroutine.", true);
			if (config.mode() != Config::MODE_REACTIVE) {
				if ((intSystemResult = runTool(config, Config::TC_POSTPROC, "post-processor", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
					if (!echoFile(std::cout, config.output(Config::TC_POSTPROC))) {
						utils::error("Unable to read from the post-processor output file '%s'", true, -1, config.output(Config::TC_POSTPROC).c_str());
					}
					// It Ran!
					ran[Config::TC_POSTPROC] = true;

					// check the status and make sure all is well...
					if (intSystemResult == TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS) {
						// Looks like we have solutions... YAY!
						blnFoundSolutions = true;
					} else if (intSystemResult == TC_STAT_POSTPROC_AS2TRANSITION_NO_SOLUTIONS) {

					} else if(intSystemResult != TC_STAT_OK) {
						#ifdef DEBUG
						cleanup(config, ran, selfpath);
						#else
						cleanup(config, ran);
						#endif
						utils::error("An error occurred while executing the post-processor.",true, utils::EXT_CODE_TOOLCHAIN_POSTPROC_ERR);
					}
				}
			}

			/*********************************************************************************************/
			/* Reactive Bridge */
			/*********************************************************************************************/

			// The reactive bridge is run inside of reactive mode.
			// NOTE: If we really are in reactive mode then they solver is still running the background!
			utils::debug("Entering reactive bridge subroutine.", true);

			if (config.mode() == Config::MODE_REACTIVE) { 
#ifdef NO_REACTIVE_BRIDGE
			utils::warning("The reactive bridge has not yet been completed. Due to this, the system will run as if the reactive bridge has been disabled and you will need to connect to oClingo directly.", true);
			utils::warning("Please connect your external agent to oClingo, which is listening on port '%d'.", true, config.intConfigOpt(Config::OPT_EXT_PORT));

#else
				if ((intSystemResult = runTool(config, Config::TC_REACTIVE_BRIDGE, "reactive bridge", &runConfig)) != TC_STAT_TOOLSKIPPED)  {
					// It Ran!
					ran[Config::TC_REACTIVE_BRIDGE] = true;

					// check the status and make sure all is well...
					if (intSystemResult == TC_STAT_BG) {
						// The reactive bridge was launched in the background.
					} else if(intSystemResult != TC_STAT_OK) {
						#ifdef DEBUG
						cleanup(config, ran, selfpath);
						#else
						cleanup(config, ran);
						#endif
						utils::error("An error occurred while executing the reactive bridge.",true, utils::EXT_CODE_TOOLCHAIN_REACTIVE_BRIDGE_ERR);
					}
				}
#endif 
			}

			/*********************************************************************************************/
			/* Maxstep Increment */
			/*********************************************************************************************/

			if (config.mode() == Config::MODE_STATIC_MANUAL) {
				runConfig.maxstep = queryUserForConstant(config, "maximum step", runConfig.maxstep+1);
			} else if (config.mode() == Config::MODE_STATIC_AUTO) {
				runConfig.maxstep++;
			}

		} while(
				// The loop should continue as long as we are:
				// * Running in static-manual mode and the user hasn't told us to stop, or
				// * Running in static-auto mode, we haven't reached the maximum step , and we haven't found solutions.
				// AND
				// * We have something to do
				((config.mode() == Config::MODE_STATIC_MANUAL && runConfig.maxstep != Config::UNDEFINED)
				|| (config.mode() == Config::MODE_STATIC_AUTO
						&& runConfig.maxstep != Config::UNDEFINED
						&& (maxmaxstep == Config::UNDEFINED || runConfig.maxstep <= maxmaxstep)
						&& !blnFoundSolutions))
				&& (
					// config.run(Config::TC_GROUNDER) ||
					config.run(Config::TC_SOLVER) 
					|| config.run(Config::TC_POSTPROC)
					|| (config.mode() == Config::MODE_REACTIVE && config.run(Config::TC_REACTIVE_BRIDGE))
				)
				);


		first = false;

	} while
			// The outer loop should run as long as:
			// * We're not suppressing user interaction,
			// * We are running what looks like a grounder/solver,
			// * The user has not selected a query on the command line, and
			// * The user has not selected to exit the outer loop.
			(!config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)
			&& config.run(Config::TC_SOLVER)
			&& config.strOpt(Config::STR_QUERY) =="");

	utils::debug("Exiting interactive loop.", true);
	/**********************************************************************************************************************/
	/* Final Cleanup */
	/**********************************************************************************************************************/
	#ifdef DEBUG
	cleanup(config, ran, argv[0]);
	#else
	cleanup(config, ran);
	#endif
	return 0;
}

OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf) {
	// Process command-line arguments.

	char const* tmpptr;
	size_t tmpoffset;
	char tmpPath[PATH_MAX];
	std::list<char const*> rawInputList;
	std::pair<unsigned int, unsigned int> steps;
	unsigned int tmpInt;
	Config::Mode mode;
	bool tmpBool;



	for(int i = 1; i < argc; i++)
	{
		utils::debug("Parsing option '%s'.", true, argv[i]);
		switch (parseOption(argv[i], tmpptr)) {

		case OPT_AUTO:
			// This is supposed to be an automated run, don't ask the user for anything.
			if (outConf.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION, true)) {
				utils::warning("Detected redefinition of option '%s'. Continuing with value '%s'",true,argv[i],"true");
			}
			break;

		case OPT_BRIDGE:
			// They are specifying a specific command for the bridge.

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.command(Config::TC_REACTIVE_BRIDGE, tmpptr)) {
				utils::warning("Detected redefinition of bridge command. Continuing with value '%s'",true,tmpptr);
			}

			break;

		case OPT_BRIDGE_OPTS:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected pass-through options following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.opts(Config::TC_REACTIVE_BRIDGE, tmpptr)) {
				utils::warning("Detected redefinition of bridge command options. Continuing with value '%s'",true,tmpptr);
			}
			break;
		case OPT_BRIDGE_OUT:

			utils::error("Redirecting the reactive bridge's output is currently unsupported.", true, 0);
			return OPT_STAT_BAD_ARG;

		case OPT_CONST:
			// Constant Declaration...
			if(++i < argc && (tmpptr = strchr(argv[i],'=')) != NULL)
			{
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				utils::debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					utils::warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}

			} else {   // Set up for a constant without actually giving one, bad command line.
				utils::error("Expected a constant definition of the form 'constant=value' after option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_FRM_BRIDGE:
			utils::pragma("Running the toolchain from the reactive bridge is discouraged.",true);
			if (outConf.setRunFrom(Config::TC_REACTIVE_BRIDGE)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		// case OPT_FRM_GRD:
		// 	// Don't run anything before the grounder.
		// 	if (outConf.setRunFrom(Config::TC_GROUNDER)) {
		// 		utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
		// 	}
		// 	break;

		case OPT_FRM_PRE:
			// Don't run anything before the pre-processor.
			if (outConf.setRunFrom(Config::TC_PREPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_POST:
			// Don't call anything before the post-processor (equivalent to "-justpost")
			if (outConf.setRunFrom(Config::TC_POSTPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_SO:
			// Don't run anything before the solver.
			if (outConf.setRunFrom(Config::TC_SOLVER)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_TRAN:
			// Don't call anything before the translator (basically a no-op option).
			if (outConf.setRunFrom(Config::TC_TRANSLATOR)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		// case OPT_GRD:
		// 	// They're giving us a specific executable to use as the grounder instead of the default.
		// 	// Make sure a second argument follows, and save the new grounder.
		// 	if (!tmpptr) {
		// 		if (++i < argc) {
		// 			tmpptr = argv[i];
		// 		} else {
		// 			// setup for a command but they didn't deliver.
		// 			utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
		// 			return OPT_STAT_BAD_ARG;
		// 		}
		// 	}

		// 	if (outConf.command(Config::TC_GROUNDER, tmpptr)) {
		// 		utils::warning("Detected redefinition of grounder command. Continuing with value '%s'",true,tmpptr);
		// 	}

		// 	break;

		// case OPT_GRD_OPTS:
		// 	if (!tmpptr) {
		// 		if (++i < argc) {
		// 			tmpptr = argv[i];
		// 		} else {
		// 			// setup for options but they didn't deliver
		// 			utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
		// 			return OPT_STAT_BAD_ARG;
		// 		}
		// 	}

		// 	if (outConf.opts(Config::TC_GROUNDER, tmpptr)) {
		// 		utils::warning("Detected redefinition of grounder command options. Continuing with value '%s'",true, tmpptr);
		// 	}

		// 	break;

		// case OPT_GRD_OUT:

		// 	if (!tmpptr) {
		// 		if (++i < argc) {
		// 			tmpptr = argv[i];
		// 		} else {
		// 			// setup for a command but they didn't deliver.
		// 			utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
		// 			return OPT_STAT_BAD_ARG;
		// 		}
		// 	}

		// 	if (outConf.output(Config::TC_GROUNDER, tmpptr)) {
		// 		utils::warning("Detected redefinition of the grounder output file. Continuing with value '%s'",true, tmpptr);
		// 	}
		// 	break;

		case OPT_GRINGO_NONE_HACK:
			// Specifying a none_hack value.

			if (!tmpptr) {
				utils::warning("Option '%s' has been deprecated in favor of specifying an explicit none alias value.",true,argv[i]);

				tmpptr = DEF_NONE_HACK_VAL;
			}


			if (outConf.strOpt(Config::STR_NONE_ALIAS, tmpptr)) {
				utils::warning("Detected redefinition of the none alias option. Continuing with value '%s'",true, tmpptr);
			}

			break;


		// case OPT_JUST_GRD:
		// 	// Just call the grounder program, no others.
		// 	if (outConf.setOnlyRun(Config::TC_GROUNDER)) {
		// 		utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
		// 	}
		// 	break;

		case OPT_JUST_PRE:
			// Just call the preprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_PREPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_POST:
			// Just call the postprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_POSTPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_SO:
			// Just call the solver program, no others.
			if (outConf.setOnlyRun(Config::TC_SOLVER)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_TRANS:
			// Just call the translator program, no others.
			if (outConf.setOnlyRun(Config::TC_TRANSLATOR)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;
		case OPT_LANG:
			Config::Language l;
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
						utils::error("Expected a language specification following option '%s'. Exiting.",true,0, argv[i-1]);
						return OPT_STAT_BAD_ARG;
				}
			}

			if (!outConf.parseLang(tmpptr, l)) {
				utils::error("'%s' is not a supported language specification.", 0, true, tmpptr);
				return OPT_STAT_BAD_ARG;
			}

			if (outConf.lang(l)) {
				utils::warning("Detected a redefition of the input language.",true,argv[i]);
			}
			break;

		case OPT_MAXSTEP:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
						utils::error("Expected a maximum step following option '%s'. Exiting.",true,0, argv[i-1]);
						return OPT_STAT_BAD_ARG;
				}
			}

			if ((steps = Config::parseMaxstep(tmpptr)).second == Config::UNDEFINED) {
				utils::error("'%s' is not a valid step value. Exiting.",true,0, tmpptr);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_MAXSTEP, steps.second)
					|| (steps.first != Config::UNDEFINED && outConf.intConfigOpt(Config::OPT_MINSTEP, steps.first)))
			{
				utils::warning("Detected a redefinition of the maximum step. Continuing with the value '%s'.",true,tmpptr);
			}
			break;

		case OPT_MINSTEP:

			if (!tmpptr) {

				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a minimum step following option '%s'. Exiting.",true,0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

			}

	
			if (!utils::from_string(tmpInt, tmpptr)) {
				utils::error("'%s' is not a valid step value. Exiting.",true,0, tmpptr);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_MINSTEP, tmpInt)) {
				utils::warning("Detected a redefinition of the minimum step. Continuing with value '%s'.",true,tmpptr);
			}

			break;

		case OPT_NO_DOMAIN_ENFORCE:
			outConf.boolConfigOpt(Config::OPT_NO_DOMAIN_ENFORCE, true);
			break;
		case OPT_NO_ADD_DOMAIN_ENFORCE:
			outConf.boolConfigOpt(Config::OPT_NO_ADD_DOMAIN_ENFORCE, true);
			break;

		case OPT_MODE_SELECT:
			tmpBool = false;
			if (!tmpptr) {
				tmpBool = true;
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a mode option (one of '%s', '%s', '%s', or '%s') following option '%s'. Exiting.",true,0,
							ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, ARG_MODE_REACTIVE, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (!strcmp(tmpptr,ARG_MODE_STATIC_MANUAL)) {
				mode = Config::MODE_STATIC_MANUAL;
			} else if (!strcmp(tmpptr,ARG_MODE_STATIC_AUTO)) {
				mode = Config::MODE_STATIC_AUTO;
			} else if (!strcmp(tmpptr,ARG_MODE_INCREMENTAL)) {
				mode = Config::MODE_INCREMENTAL;
			} else if (!strcmp(tmpptr,ARG_MODE_REACTIVE)) {
				mode = Config::MODE_INCREMENTAL;
			} else {
				utils::error("Unexpected value '%s'. Expected a mode option (one of '%s', '%s', '%s', or '%s'). Exiting.",true,0,
						tmpptr, ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, OPT_MODE_REACTIVE);
				return OPT_STAT_BAD_ARG;
			}

			if (outConf.mode(mode)) {
				utils::warning("Detected a redefinition of the program's running mode. Continuing with value '%s'.", true, tmpptr);
			}

			break;
		case OPT_MODE_STATIC_AUTO:
			if (outConf.mode(Config::MODE_STATIC_AUTO)) {
				utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'static-auto'.", true);
			}
			break;
		case OPT_MODE_STATIC_MANUAL:
			if (outConf.mode(Config::MODE_STATIC_MANUAL)) {
				utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'static-manual'.", true);
			}
			break;
		case OPT_MODE_INCREMENTAL:
			if (outConf.mode(Config::MODE_INCREMENTAL)) {
				utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'incremental'", true);
			}
			break;
		case OPT_MODE_REACTIVE:
			if (outConf.mode(Config::MODE_REACTIVE)) {
				utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'reactive'.", true);
			}
			break;

		case OPT_NO_DEL:
			tmpBool = false;
			utils::warning("The option '%s' has been deprecated in favor of the '--[PROG]-output=[OUTFILE] option.", true, argv[i]);

			tmpBool = outConf.output(Config::TC_TRANSLATOR, DEF_INT_TRANS_FILE) 
					|/* non-shortcutting bitwise or */ outConf.output(Config::TC_PREPROC, DEF_INT_PREPROC_FILE)

					| outConf.output(Config::TC_SOLVER, DEF_INT_SO_FILE);

			// Shut off deleting intermediate files.
			if (tmpBool) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_SHIFT:
			if (!tmpptr) {
				// default true
				tmpptr = "true";
			}
			
			bool val;
			if (!strcmp(tmpptr, "true")) {
				val = true;
			} else if (!strcmp(tmpptr, "false")) {
				val = false;
			} else {
				utils::error("Invalid shift value. Expected a Boolean value ('true' or 'false'). Exiting.", true, 0, argv[i]);
				return OPT_STAT_BAD_ARG;
			}

			if (outConf.boolConfigOpt(Config::OPT_SHIFT, val)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}

			break;

		case OPT_STATS:
			// Don't include standard files in the final product.
			if (outConf.boolConfigOpt(Config::OPT_STATS, true)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true, argv[i]);
			}

			break;

		case OPT_PORT_EXTERNAL:
			// Set the external port to use in reactive mode
			if (!tmpptr) {

				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a port number following option '%s'. Exiting.",true,0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (!utils::from_string(tmpInt, tmpptr) || tmpInt < 1) {
				utils::error("'%s' is not a valid port. Exiting.",true,0, tmpptr);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_EXT_PORT, tmpInt)) {
				utils::warning("Detected a redefinition of the external port. Continuing with value '%s'.",true,tmpptr);
			}

			break;

		case OPT_PORT_INTERNAL:
			// Set the internal port to use in reactive mode
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a port number following option '%s'. Exiting.",true,0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (!utils::from_string(tmpInt, tmpptr) || tmpInt < 1) {
				utils::error("'%s' is not a valid port. Exiting.",true,0, tmpptr);
				return OPT_STAT_BAD_ARG;
			} else if (outConf.intConfigOpt(Config::OPT_INT_PORT, tmpInt)) {
				utils::warning("Detected a redefinition of the internal port. Continuing with value '%s'.",true,tmpptr);
			}

			break;

		case OPT_POSTPROC:
			// They're giving us a specific executable to use as the post-processor instead of the default.
			// Make sure a second argument follows, and save the new post-processor.

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.command(Config::TC_POSTPROC, tmpptr)) {
				utils::warning("Detected redefinition of post-processor command. Continuing with value '%s'.",true,argv[i]);
			}
	
			break;

		case OPT_POSTPROC_OPTS:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for options but they didn't deliver
					utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (outConf.opts(Config::TC_POSTPROC, tmpptr)) {
				utils::warning("Detected redefinition of post-processor command options. Continuing with value '%s'",true,tmpptr);
			}

			break;

		case OPT_POSTPROC_OUT:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.output(Config::TC_POSTPROC, tmpptr)) {
				utils::warning("Detected redefinition of the post-processor output file. Continuing with value '%s'",true, tmpptr);
			}
			break;

		case OPT_PREPROC:
			// They're giving us a specific executable to use as the pre-processor instead of the default.
			// Make sure a second argument follows, and save the new pre-processor.
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.command(Config::TC_PREPROC, tmpptr)) {
				utils::warning("Detected redefinition of pre-processor command. Continuing with value '%s'",true,tmpptr);
			}
			break;

		case OPT_PREPROC_OPTS:
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for options but they didn't deliver
					utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

			}


			if (outConf.opts(Config::TC_PREPROC, tmpptr)) {
				utils::warning("Detected redefinition of pre-processor command options. Continuing with value '%s'",true,tmpptr);
			}

			break;

		case OPT_PREPROC_OUT:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.output(Config::TC_PREPROC, tmpptr)) {
				utils::warning("Detected redefinition of the pre-processor output file. Continuing with value '%s'",true, tmpptr);
			}
			break;

		case OPT_SO:
			// They're giving us a specific executable to use as the solver instead of the default.
			// Make sure a second argument follows, and save the new solver.
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.command(Config::TC_SOLVER, tmpptr)) {
				utils::warning("Detected redefinition of solver command. Continuing with value '%s'",true,tmpptr);
			}
			break;

		case OPT_SO_OPTS:
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for options but they didn't deliver
					utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (outConf.opts(Config::TC_SOLVER, tmpptr)) {
				utils::warning("Detected redefinition of solver command options. Continuing with value '%s'",true, tmpptr);
			}

			break;

		case OPT_SO_OUT:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.output(Config::TC_SOLVER, tmpptr)) {
				utils::warning("Detected redefinition of the solver output file. Continuing with value '%s'",true, tmpptr);
			}
			break;
		
		case OPT_SYMTAB:
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

			}

			if (outConf.strOpt(Config::STR_SYMTAB_FILE, tmpptr)) {
				utils::warning("Detected redefinition of the symbol table file. Continuing with value '%s'",true, tmpptr);
			}
			break;


		case OPT_TO_BRIDGE:
			if (outConf.setRunTo(Config::TC_REACTIVE_BRIDGE)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		// case OPT_TO_GRD:
		// 	// Shut off deleting intermediate files.
		// 	if (outConf.setRunTo(Config::TC_GROUNDER)) {
		// 		utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
		// 	}
		// 	break;

		case OPT_TO_PRE:
			// Run everything up to the pre-processor.
			if (outConf.setRunTo(Config::TC_PREPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_POST:
			// Run everything up to the post-processor...
			if (outConf.setRunTo(Config::TC_POSTPROC)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_SO:
			// Run everything up to the solver...
			if (outConf.setRunTo(Config::TC_SOLVER)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_TRANS:
			// Run everything up to the translator...
			if (outConf.setRunTo(Config::TC_TRANSLATOR)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TRANS:
			// They're giving us a specific executable to use as the translator instead of the default.
			// Make sure a second argument follows, and save the new grounder.
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (outConf.command(Config::TC_TRANSLATOR, tmpptr)) {
				utils::warning("Detected redefinition of translator command. Continuing with value '%s'.",true,tmpptr);
			}

			break;

		case OPT_TRANS_OPTS:
			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for options but they didn't deliver
					utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}


			if (outConf.opts(Config::TC_TRANSLATOR, tmpptr)) {
				utils::warning("Detected redefinition of translator command options. Continuing with value '%s'.",true,tmpptr);
			}

			break;

		case OPT_TRANS_OUT:

			if (!tmpptr) {
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					// setup for a command but they didn't deliver.
					utils::error("Expected a file name following option '%s'. Exiting.",true,0,argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}

			if (outConf.output(Config::TC_TRANSLATOR, tmpptr)) {
				utils::warning("Detected redefinition of the translator output file. Continuing with value '%s'",true, tmpptr);
			}
			break;

		case OPT_VERSION:
			return OPT_STAT_VERSION;

		case OPT_HELP:
			return OPT_STAT_HELP;

		case OPT_QUERY:
			tmpBool = false;
			if (!tmpptr) {
				tmpBool = true;
				if (++i < argc) {
					tmpptr = argv[i];
				} else {
					utils::error("Expected a query identifier following option '%s'. Exiting.",true,0, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}
			}
			if (outConf.strOpt(Config::STR_QUERY, tmpptr)) {
				utils::warning("The option '%s' has overridden one or more previous choices.",true,(tmpBool) ? argv[i-1] : argv[i]);
			}
			break;

		case OPT_UNSUPPORTED:
			// Whatever this is, it's unsupported.
			utils::warning("The '%s' option is no longer supported. It will be ignored.",true,argv[i]);
			break;
		case OPT_UNSUPPORTED_NO_STD:
			// they want us to not include the standard file...
			// we don't use a standard file anymore.
			utils::warning("The '%s' option is no longer supported as standard files are no longer used.", true, argv[i]);
			break;

		case OPT_UNSUPPORTED_ADDITIVE:
			// They want us to include the additive standard file...
			utils::warning("The '%s' option is no longer supported as standard files are no longer used.",true,argv[i]);
			break;

		case OPT_UNSUPPORTED_GRSO:
			// They did something involving the explicit grounder/solver
			// We no longer support the explicit grounder/solver calls
			utils::error("The '%s' option is no longer supported. We no longer use a dedicated grounder/solver in the toolchain. Please make use of the solver component instead.",true,0,argv[i]);

			// We probably aren't going to do what they want, go ahead and signal that something went wrong
			return OPT_STAT_BAD_ARG;

		case OPT_UNSUPPORTED_MANUAL_MAXSTEP:
			// Manually advance the maximum step of the program query
			utils::error("The '%s' option is no longer supported. Please use that '--mode=static-manual' option instead.",true,0,argv[i]);
			break;

		case OPT_UNKNOWN:
			utils::debug("The option isn't a recognized flag. Checking other possibilities.", true);
			if (argv[i][0] == '-')
			{
				// It appears to be a bad argument...
				utils::error("Found an unrecognized argument '%s'. Exiting.",true,0,argv[i]);
				return OPT_STAT_BAD_ARG;
			}

			// If there's no "header" on the argument, it's either a constant declaration, an input file, or the number of solutions.
			else if(!strcmp(argv[i], "all") || !strcmp(argv[i], "ALL")) {
				if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, 0)) {
					utils::warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,argv[i]);
				}
			}
			else if(utils::isInteger(argv[i]))
			{	// It looks like a number, atoi it and save that as the desired number of solutions.
				int numSolutions = atoi(argv[i]);
				if(numSolutions < 0) {
					utils::warning("The number of solutions cannot be negative. Ignoring the argument.",true);
				} else {
					if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, (unsigned int)numSolutions)) {
						utils::warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,argv[i]);
					}
				}
			}
			else if((tmpptr = strchr(argv[i],'=')) != NULL)
			{   // Found an equals sign in the argument, it's probably a "const=value" declaration.
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				utils::debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					utils::warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}
			}
			else
			{	// If it's not a number, it's probably an input file. Make sure it exists, and then save it to the list.

				if(realpath(argv[i], tmpPath) == NULL)
				{
					// Couldn't find the input file...
					utils::error("Unable to locate input file '%s'. Exiting.",true,0,argv[i]);
					return OPT_STAT_BAD_ARG;
				}
				else
				{
					// Save all of the input files until we are done and can handle them...
					rawInputList.push_back(argv[i]);
				}
			}
			break;
		}
	}

	// We've finished parsing all of the arguments... Let's handle those pesky input files.
	utils::debug("Handling input files...", true);
	if (!rawInputList.size()) {
		//uh-oh. They didn't specify any input files. This simply won't do.
		utils::error("One or more input files must be specified.",true,0);
		return OPT_STAT_BAD_ARG;
	}

	// They've insisted on sticking with a given mode. Make sure they're aware if they're using an incompatible
	for (std::list<char const*>::iterator it = rawInputList.begin(); it != rawInputList.end(); it++) {
		Config::FileType type = outConf.addInput(*it);
		if (outConf.customMode() && type.known && !(type.runningMode & outConf.mode())) {
			utils::warning("The file '%s' doesn't appear to be compatible with the current running mode.",true,*it);
		}
	}

	return OPT_STAT_OK;
}

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @param[out] val A string with the value for the option (where applicable) or NULL. 
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt, char const*& val) {
	char const* marker;

	val = NULL;

	
#line 1859 "<stdout>"
	{
		char yych;
		unsigned int yyaccept = 0;
		yych = *opt;
		switch (yych) {
		case '\n':	goto yy2;
		case '-':	goto yy5;
		case 'l':	goto yy6;
		case 'm':	goto yy7;
		default:	goto yy3;
		}
yy2:
		opt = marker;
		switch (yyaccept) {
		case 0: 	goto yy4;
		case 1: 	goto yy23;
		case 2: 	goto yy26;
		case 3: 	goto yy30;
		case 4: 	goto yy56;
		case 5: 	goto yy59;
		case 6: 	goto yy84;
		case 7: 	goto yy145;
		case 8: 	goto yy194;
		case 9: 	goto yy202;
		case 10: 	goto yy212;
		case 11: 	goto yy222;
		case 12: 	goto yy309;
		default:	goto yy366;
		}
yy3:
		++opt;
yy4:
#line 1960 "cplus2asp.r2c"
		{ return OPT_UNKNOWN; }
#line 1894 "<stdout>"
yy5:
		yyaccept = 0;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy8;
		case '?':	goto yy9;
		case 'a':	goto yy11;
		case 'b':	goto yy12;
		case 'c':	goto yy13;
		case 'f':	goto yy15;
		case 'g':	goto yy16;
		case 'i':	goto yy17;
		case 'j':	goto yy19;
		case 'l':	goto yy20;
		case 'm':	goto yy22;
		case 'n':	goto yy24;
		case 'p':	goto yy25;
		case 'q':	goto yy27;
		case 's':	goto yy29;
		case 't':	goto yy31;
		case 'v':	goto yy32;
		default:	goto yy4;
		}
yy6:
		yyaccept = 0;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'a':	goto yy34;
		default:	goto yy4;
		}
yy7:
		yyaccept = 0;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy35;
		default:	goto yy4;
		}
yy8:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy36;
		case 'b':	goto yy37;
		case 'c':	goto yy38;
		case 'f':	goto yy39;
		case 'g':	goto yy40;
		case 'h':	goto yy41;
		case 'i':	goto yy42;
		case 'j':	goto yy43;
		case 'l':	goto yy44;
		case 'm':	goto yy45;
		case 'n':	goto yy46;
		case 'p':	goto yy47;
		case 'q':	goto yy48;
		case 's':	goto yy49;
		case 't':	goto yy50;
		case 'u':	goto yy51;
		case 'v':	goto yy52;
		default:	goto yy2;
		}
yy9:
		++opt;
#line 1939 "cplus2asp.r2c"
		{ return OPT_HELP; }
#line 1958 "<stdout>"
yy11:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy53;
		case 'u':	goto yy54;
		default:	goto yy2;
		}
yy12:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy55;
		default:	goto yy2;
		}
yy13:
		++opt;
#line 1863 "cplus2asp.r2c"
		{ return OPT_CONST; }
#line 1976 "<stdout>"
yy15:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy57;
		default:	goto yy2;
		}
yy16:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy58;
		default:	goto yy2;
		}
yy17:
		++opt;
#line 1884 "cplus2asp.r2c"
		{ return OPT_PORT_INTERNAL; }
#line 1993 "<stdout>"
yy19:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy60;
		default:	goto yy2;
		}
yy20:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy61;
		default:	goto yy21;
		}
yy21:
#line 1890 "cplus2asp.r2c"
		{ return OPT_LANG; }
#line 2009 "<stdout>"
yy22:
		yyaccept = 1;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy63;
		case 'a':	goto yy65;
		case 'i':	goto yy66;
		case 'm':	goto yy67;
		default:	goto yy23;
		}
yy23:
#line 1893 "cplus2asp.r2c"
		{ return OPT_MODE_SELECT; }
#line 2023 "<stdout>"
yy24:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy69;
		case 'd':	goto yy71;
		case 'h':	goto yy73;
		case 'o':	goto yy75;
		default:	goto yy2;
		}
yy25:
		yyaccept = 2;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy76;
		case 'i':	goto yy78;
		case 'o':	goto yy79;
		case 'r':	goto yy80;
		default:	goto yy26;
		}
yy26:
#line 1903 "cplus2asp.r2c"
		{ return OPT_PORT_EXTERNAL; }
#line 2046 "<stdout>"
yy27:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy81;
		default:	goto yy28;
		}
yy28:
#line 1938 "cplus2asp.r2c"
		{ return OPT_QUERY; }
#line 2056 "<stdout>"
yy29:
		yyaccept = 3;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy83;
		case 'y':	goto yy85;
		default:	goto yy30;
		}
yy30:
#line 1900 "cplus2asp.r2c"
		{ return OPT_SHIFT; }
#line 2068 "<stdout>"
yy31:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy86;
		case 'r':	goto yy87;
		default:	goto yy2;
		}
yy32:
		++opt;
#line 1936 "cplus2asp.r2c"
		{ return OPT_VERSION; }
#line 2080 "<stdout>"
yy34:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy88;
		default:	goto yy2;
		}
yy35:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy89;
		default:	goto yy2;
		}
yy36:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy90;
		case 'u':	goto yy91;
		default:	goto yy2;
		}
yy37:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy92;
		default:	goto yy2;
		}
yy38:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy93;
		default:	goto yy2;
		}
yy39:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy94;
		default:	goto yy2;
		}
yy40:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy95;
		default:	goto yy2;
		}
yy41:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy96;
		default:	goto yy2;
		}
yy42:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy97;
		default:	goto yy2;
		}
yy43:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy98;
		default:	goto yy2;
		}
yy44:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy99;
		default:	goto yy2;
		}
yy45:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy100;
		case 'i':	goto yy101;
		case 'o':	goto yy102;
		default:	goto yy2;
		}
yy46:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy103;
		default:	goto yy2;
		}
yy47:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy104;
		case 'r':	goto yy105;
		default:	goto yy2;
		}
yy48:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy106;
		default:	goto yy2;
		}
yy49:
		yych = *++opt;
		switch (yych) {
		case 'h':	goto yy107;
		case 'o':	goto yy108;
		case 't':	goto yy109;
		case 'y':	goto yy110;
		default:	goto yy2;
		}
yy50:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy111;
		case 'r':	goto yy112;
		default:	goto yy2;
		}
yy51:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy113;
		default:	goto yy2;
		}
yy52:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy114;
		default:	goto yy2;
		}
yy53:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy115;
		default:	goto yy2;
		}
yy54:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy117;
		default:	goto yy2;
		}
yy55:
		yyaccept = 4;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy118;
		case 'o':	goto yy120;
		default:	goto yy56;
		}
yy56:
#line 1865 "cplus2asp.r2c"
		{ return OPT_BRIDGE; }
#line 2226 "<stdout>"
yy57:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy121;
		default:	goto yy2;
		}
yy58:
		yyaccept = 5;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy122;
		case 'o':	goto yy124;
		case 's':	goto yy125;
		default:	goto yy59;
		}
yy59:
#line 1877 "cplus2asp.r2c"
		{ return OPT_GRD; }
#line 2245 "<stdout>"
yy60:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy126;
		default:	goto yy2;
		}
yy61:
		++opt;
#line 1892 "cplus2asp.r2c"
		{ val = opt; return OPT_LANG; }
#line 2256 "<stdout>"
yy63:
		++opt;
#line 1891 "cplus2asp.r2c"
		{ val = opt; return OPT_MODE_SELECT; }
#line 2261 "<stdout>"
yy65:
		yych = *++opt;
		switch (yych) {
		case 'x':	goto yy127;
		default:	goto yy2;
		}
yy66:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy129;
		default:	goto yy2;
		}
yy67:
		++opt;
#line 1951 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_MANUAL_MAXSTEP; }
#line 2278 "<stdout>"
yy69:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy131;
		case 'd':	goto yy133;
		default:	goto yy70;
		}
yy70:
#line 1943 "cplus2asp.r2c"
		{ return OPT_GRINGO_NONE_HACK; }
#line 2289 "<stdout>"
yy71:
		++opt;
#line 1898 "cplus2asp.r2c"
		{ return OPT_NO_DOMAIN_ENFORCE; }
#line 2294 "<stdout>"
yy73:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy135;
		default:	goto yy74;
		}
yy74:
#line 1942 "cplus2asp.r2c"
		{ return OPT_GRINGO_NONE_HACK; }
#line 2304 "<stdout>"
yy75:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy137;
		case 'g':	goto yy138;
		case 'p':	goto yy139;
		case 's':	goto yy140;
		case 't':	goto yy141;
		default:	goto yy2;
		}
yy76:
		++opt;
#line 1902 "cplus2asp.r2c"
		{ val = opt; return OPT_PORT_EXTERNAL; }
#line 2319 "<stdout>"
yy78:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy142;
		default:	goto yy2;
		}
yy79:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy143;
		default:	goto yy2;
		}
yy80:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy144;
		default:	goto yy2;
		}
yy81:
		++opt;
#line 1937 "cplus2asp.r2c"
		{ val = opt; return OPT_QUERY; }
#line 2342 "<stdout>"
yy83:
		yyaccept = 6;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy146;
		case 'o':	goto yy148;
		default:	goto yy84;
		}
yy84:
#line 1917 "cplus2asp.r2c"
		{ return OPT_SO; }
#line 2354 "<stdout>"
yy85:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy149;
		default:	goto yy2;
		}
yy86:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy150;
		case 'g':	goto yy151;
		case 'p':	goto yy152;
		case 's':	goto yy153;
		case 't':	goto yy154;
		default:	goto yy2;
		}
yy87:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy155;
		default:	goto yy2;
		}
yy88:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy156;
		default:	goto yy2;
		}
yy89:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy157;
		default:	goto yy2;
		}
yy90:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy158;
		default:	goto yy2;
		}
yy91:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy159;
		default:	goto yy2;
		}
yy92:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy160;
		default:	goto yy2;
		}
yy93:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy161;
		default:	goto yy2;
		}
yy94:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy162;
		default:	goto yy2;
		}
yy95:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy163;
		default:	goto yy2;
		}
yy96:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy164;
		default:	goto yy2;
		}
yy97:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy165;
		default:	goto yy2;
		}
yy98:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy166;
		default:	goto yy2;
		}
yy99:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy167;
		default:	goto yy2;
		}
yy100:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy168;
		case 'x':	goto yy169;
		default:	goto yy2;
		}
yy101:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy170;
		default:	goto yy2;
		}
yy102:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy171;
		default:	goto yy2;
		}
yy103:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy172;
		case 'n':	goto yy173;
		default:	goto yy2;
		}
yy104:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy174;
		case 's':	goto yy175;
		default:	goto yy2;
		}
yy105:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy176;
		default:	goto yy2;
		}
yy106:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy177;
		default:	goto yy2;
		}
yy107:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy178;
		default:	goto yy2;
		}
yy108:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy179;
		default:	goto yy2;
		}
yy109:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy180;
		default:	goto yy2;
		}
yy110:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy181;
		default:	goto yy2;
		}
yy111:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy182;
		default:	goto yy2;
		}
yy112:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy183;
		default:	goto yy2;
		}
yy113:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy184;
		default:	goto yy2;
		}
yy114:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy185;
		default:	goto yy2;
		}
yy115:
		++opt;
#line 1946 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_ADDITIVE; }
#line 2546 "<stdout>"
yy117:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy186;
		default:	goto yy2;
		}
yy118:
		++opt;
#line 1864 "cplus2asp.r2c"
		{ val = opt; return OPT_BRIDGE; }
#line 2557 "<stdout>"
yy120:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy188;
		case 'u':	goto yy189;
		default:	goto yy2;
		}
yy121:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy190;
		default:	goto yy2;
		}
yy122:
		++opt;
#line 1876 "cplus2asp.r2c"
		{ val = opt; return OPT_GRD; }
#line 2575 "<stdout>"
yy124:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy191;
		case 'u':	goto yy192;
		default:	goto yy2;
		}
yy125:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy193;
		default:	goto yy2;
		}
yy126:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy195;
		default:	goto yy2;
		}
yy127:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy196;
		default:	goto yy128;
		}
yy128:
#line 1895 "cplus2asp.r2c"
		{ return OPT_MAXSTEP; }
#line 2604 "<stdout>"
yy129:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy198;
		default:	goto yy130;
		}
yy130:
#line 1897 "cplus2asp.r2c"
		{ return OPT_MINSTEP; }
#line 2614 "<stdout>"
yy131:
		++opt;
#line 1883 "cplus2asp.r2c"
		{ val = opt; return OPT_GRINGO_NONE_HACK; }
#line 2619 "<stdout>"
yy133:
		++opt;
#line 1899 "cplus2asp.r2c"
		{ return OPT_NO_ADD_DOMAIN_ENFORCE; }
#line 2624 "<stdout>"
yy135:
		++opt;
#line 1882 "cplus2asp.r2c"
		{ val = opt; return OPT_GRINGO_NONE_HACK; }
#line 2629 "<stdout>"
yy137:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy200;
		default:	goto yy2;
		}
yy138:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy201;
		default:	goto yy2;
		}
yy139:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy203;
		case 'r':	goto yy204;
		default:	goto yy2;
		}
yy140:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy205;
		case 't':	goto yy207;
		default:	goto yy2;
		}
yy141:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy208;
		default:	goto yy2;
		}
yy142:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy209;
		default:	goto yy2;
		}
yy143:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy211;
		default:	goto yy2;
		}
yy144:
		yyaccept = 7;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy213;
		case 'o':	goto yy215;
		default:	goto yy145;
		}
yy145:
#line 1911 "cplus2asp.r2c"
		{ return OPT_PREPROC; }
#line 2685 "<stdout>"
yy146:
		++opt;
#line 1916 "cplus2asp.r2c"
		{ val = opt; return OPT_SO; }
#line 2690 "<stdout>"
yy148:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy216;
		case 'u':	goto yy217;
		default:	goto yy2;
		}
yy149:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy218;
		default:	goto yy2;
		}
yy150:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy219;
		default:	goto yy2;
		}
yy151:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy221;
		default:	goto yy2;
		}
yy152:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy223;
		case 'r':	goto yy224;
		default:	goto yy2;
		}
yy153:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy225;
		default:	goto yy2;
		}
yy154:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy227;
		default:	goto yy2;
		}
yy155:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy228;
		default:	goto yy2;
		}
yy156:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy229;
		default:	goto yy2;
		}
yy157:
		yych = *++opt;
		goto yy23;
yy158:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy230;
		default:	goto yy2;
		}
yy159:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy231;
		default:	goto yy2;
		}
yy160:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy232;
		default:	goto yy2;
		}
yy161:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy233;
		default:	goto yy2;
		}
yy162:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy234;
		default:	goto yy2;
		}
yy163:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy235;
		default:	goto yy2;
		}
yy164:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy9;
		default:	goto yy2;
		}
yy165:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy236;
		default:	goto yy2;
		}
yy166:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy237;
		default:	goto yy2;
		}
yy167:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy238;
		default:	goto yy2;
		}
yy168:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy239;
		default:	goto yy2;
		}
yy169:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy240;
		default:	goto yy2;
		}
yy170:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy241;
		default:	goto yy2;
		}
yy171:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy242;
		default:	goto yy2;
		}
yy172:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy243;
		case 'd':	goto yy244;
		case 'g':	goto yy245;
		case 'p':	goto yy246;
		case 's':	goto yy247;
		case 't':	goto yy248;
		default:	goto yy2;
		}
yy173:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy249;
		default:	goto yy2;
		}
yy174:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy250;
		default:	goto yy2;
		}
yy175:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy251;
		default:	goto yy2;
		}
yy176:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy252;
		default:	goto yy2;
		}
yy177:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy253;
		default:	goto yy2;
		}
yy178:
		yych = *++opt;
		switch (yych) {
		case 'f':	goto yy254;
		default:	goto yy2;
		}
yy179:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy255;
		default:	goto yy2;
		}
yy180:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy256;
		default:	goto yy2;
		}
yy181:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy257;
		default:	goto yy2;
		}
yy182:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy258;
		case 'g':	goto yy259;
		case 'p':	goto yy260;
		case 's':	goto yy261;
		case 't':	goto yy262;
		default:	goto yy2;
		}
yy183:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy263;
		default:	goto yy2;
		}
yy184:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy264;
		default:	goto yy2;
		}
yy185:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy265;
		default:	goto yy2;
		}
yy186:
		++opt;
#line 1862 "cplus2asp.r2c"
		{ return OPT_AUTO; }
#line 2931 "<stdout>"
yy188:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy266;
		default:	goto yy2;
		}
yy189:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy268;
		default:	goto yy2;
		}
yy190:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy270;
		case 'g':	goto yy271;
		case 'p':	goto yy272;
		case 's':	goto yy273;
		case 't':	goto yy274;
		default:	goto yy2;
		}
yy191:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy275;
		default:	goto yy2;
		}
yy192:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy277;
		default:	goto yy2;
		}
yy193:
		yyaccept = 8;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy279;
		default:	goto yy194;
		}
yy194:
#line 1948 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 2976 "<stdout>"
yy195:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy280;
		case 'p':	goto yy281;
		case 's':	goto yy282;
		case 't':	goto yy283;
		default:	goto yy2;
		}
yy196:
		++opt;
#line 1894 "cplus2asp.r2c"
		{ val = opt;return OPT_MAXSTEP; }
#line 2990 "<stdout>"
yy198:
		++opt;
#line 1896 "cplus2asp.r2c"
		{ val = opt; return OPT_MINSTEP; }
#line 2995 "<stdout>"
yy200:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy284;
		default:	goto yy2;
		}
yy201:
		yyaccept = 9;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy286;
		default:	goto yy202;
		}
yy202:
#line 1952 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3012 "<stdout>"
yy203:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy287;
		default:	goto yy2;
		}
yy204:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy288;
		default:	goto yy2;
		}
yy205:
		++opt;
#line 1956 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3029 "<stdout>"
yy207:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy290;
		default:	goto yy2;
		}
yy208:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy292;
		default:	goto yy2;
		}
yy209:
		++opt;
#line 1958 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3046 "<stdout>"
yy211:
		yyaccept = 10;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy293;
		case 'o':	goto yy295;
		default:	goto yy212;
		}
yy212:
#line 1905 "cplus2asp.r2c"
		{ return OPT_POSTPROC; }
#line 3058 "<stdout>"
yy213:
		++opt;
#line 1910 "cplus2asp.r2c"
		{ val = opt; return OPT_PREPROC; }
#line 3063 "<stdout>"
yy215:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy296;
		case 'u':	goto yy297;
		default:	goto yy2;
		}
yy216:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy298;
		default:	goto yy2;
		}
yy217:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy300;
		default:	goto yy2;
		}
yy218:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy302;
		default:	goto yy2;
		}
yy219:
		++opt;
#line 1929 "cplus2asp.r2c"
		{ return OPT_TO_BRIDGE;	}
#line 3093 "<stdout>"
yy221:
		yyaccept = 11;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy303;
		default:	goto yy222;
		}
yy222:
#line 1924 "cplus2asp.r2c"
		{ return OPT_TO_GRD; }
#line 3104 "<stdout>"
yy223:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy304;
		default:	goto yy2;
		}
yy224:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy305;
		default:	goto yy2;
		}
yy225:
		++opt;
#line 1927 "cplus2asp.r2c"
		{ return OPT_TO_SO; }
#line 3121 "<stdout>"
yy227:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy307;
		default:	goto yy2;
		}
yy228:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy308;
		default:	goto yy2;
		}
yy229:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy310;
		default:	goto yy2;
		}
yy230:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy311;
		default:	goto yy2;
		}
yy231:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy312;
		default:	goto yy2;
		}
yy232:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy313;
		default:	goto yy2;
		}
yy233:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy13;
		default:	goto yy2;
		}
yy234:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy314;
		default:	goto yy2;
		}
yy235:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy315;
		default:	goto yy2;
		}
yy236:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy316;
		default:	goto yy2;
		}
yy237:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy317;
		default:	goto yy2;
		}
yy238:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy318;
		default:	goto yy2;
		}
yy239:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy319;
		default:	goto yy2;
		}
yy240:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy320;
		default:	goto yy2;
		}
yy241:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy321;
		default:	goto yy2;
		}
yy242:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy63;
		default:	goto yy23;
		}
yy243:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy322;
		default:	goto yy2;
		}
yy244:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy323;
		case 'o':	goto yy324;
		default:	goto yy2;
		}
yy245:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy325;
		default:	goto yy2;
		}
yy246:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy326;
		case 'r':	goto yy327;
		default:	goto yy2;
		}
yy247:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy328;
		case 't':	goto yy329;
		default:	goto yy2;
		}
yy248:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy330;
		default:	goto yy2;
		}
yy249:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy331;
		default:	goto yy2;
		}
yy250:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy76;
		default:	goto yy26;
		}
yy251:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy332;
		default:	goto yy2;
		}
yy252:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy333;
		default:	goto yy2;
		}
yy253:
		yych = *++opt;
		switch (yych) {
		case 'y':	goto yy27;
		default:	goto yy2;
		}
yy254:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy334;
		default:	goto yy2;
		}
yy255:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy335;
		default:	goto yy2;
		}
yy256:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy336;
		default:	goto yy2;
		}
yy257:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy338;
		default:	goto yy2;
		}
yy258:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy339;
		default:	goto yy2;
		}
yy259:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy340;
		default:	goto yy2;
		}
yy260:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy341;
		case 'r':	goto yy342;
		default:	goto yy2;
		}
yy261:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy343;
		default:	goto yy2;
		}
yy262:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy344;
		default:	goto yy2;
		}
yy263:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy345;
		default:	goto yy2;
		}
yy264:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy346;
		default:	goto yy2;
		}
yy265:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy347;
		default:	goto yy2;
		}
yy266:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy348;
		default:	goto yy267;
		}
yy267:
#line 1867 "cplus2asp.r2c"
		{ return OPT_BRIDGE_OPTS; }
#line 3369 "<stdout>"
yy268:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy350;
		default:	goto yy269;
		}
yy269:
#line 1869 "cplus2asp.r2c"
		{ return OPT_BRIDGE_OUT; }
#line 3379 "<stdout>"
yy270:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy352;
		default:	goto yy2;
		}
yy271:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy354;
		default:	goto yy2;
		}
yy272:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy355;
		case 'r':	goto yy356;
		default:	goto yy2;
		}
yy273:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy357;
		default:	goto yy2;
		}
yy274:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy359;
		default:	goto yy2;
		}
yy275:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy360;
		default:	goto yy276;
		}
yy276:
#line 1879 "cplus2asp.r2c"
		{ return OPT_GRD_OPTS; }
#line 3420 "<stdout>"
yy277:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy362;
		default:	goto yy278;
		}
yy278:
#line 1881 "cplus2asp.r2c"
		{ return OPT_GRD_OUT; }
#line 3430 "<stdout>"
yy279:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy364;
		default:	goto yy2;
		}
yy280:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy365;
		default:	goto yy2;
		}
yy281:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy367;
		case 'r':	goto yy368;
		default:	goto yy2;
		}
yy282:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy369;
		default:	goto yy2;
		}
yy283:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy371;
		default:	goto yy2;
		}
yy284:
		++opt;
#line 1941 "cplus2asp.r2c"
		{ return OPT_NO_DEL; }
#line 3466 "<stdout>"
yy286:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy372;
		default:	goto yy2;
		}
yy287:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy374;
		default:	goto yy2;
		}
yy288:
		++opt;
#line 1954 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3483 "<stdout>"
yy290:
		++opt;
#line 1945 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_NO_STD; }
#line 3488 "<stdout>"
yy292:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy376;
		default:	goto yy2;
		}
yy293:
		++opt;
#line 1904 "cplus2asp.r2c"
		{ val = opt; return OPT_POSTPROC; }
#line 3499 "<stdout>"
yy295:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy377;
		case 'u':	goto yy378;
		default:	goto yy2;
		}
yy296:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy379;
		default:	goto yy2;
		}
yy297:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy381;
		default:	goto yy2;
		}
yy298:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy383;
		default:	goto yy299;
		}
yy299:
#line 1919 "cplus2asp.r2c"
		{ return OPT_SO_OPTS; }
#line 3528 "<stdout>"
yy300:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy385;
		default:	goto yy301;
		}
yy301:
#line 1921 "cplus2asp.r2c"
		{ return OPT_SO_OUT; }
#line 3538 "<stdout>"
yy302:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy387;
		default:	goto yy2;
		}
yy303:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy389;
		default:	goto yy2;
		}
yy304:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy391;
		default:	goto yy2;
		}
yy305:
		++opt;
#line 1925 "cplus2asp.r2c"
		{ return OPT_TO_PRE; }
#line 3561 "<stdout>"
yy307:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy393;
		default:	goto yy2;
		}
yy308:
		yyaccept = 12;
		yych = *(marker = ++opt);
		switch (yych) {
		case '=':	goto yy394;
		case 'o':	goto yy396;
		default:	goto yy309;
		}
yy309:
#line 1931 "cplus2asp.r2c"
		{ return OPT_TRANS; }
#line 3579 "<stdout>"
yy310:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy397;
		default:	goto yy2;
		}
yy311:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy398;
		default:	goto yy2;
		}
yy312:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy399;
		default:	goto yy2;
		}
yy313:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy400;
		default:	goto yy2;
		}
yy314:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy401;
		case 'g':	goto yy402;
		case 'p':	goto yy403;
		case 's':	goto yy404;
		case 't':	goto yy405;
		default:	goto yy2;
		}
yy315:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy406;
		default:	goto yy2;
		}
yy316:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy407;
		default:	goto yy2;
		}
yy317:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy408;
		case 'p':	goto yy409;
		case 's':	goto yy410;
		case 't':	goto yy411;
		default:	goto yy2;
		}
yy318:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy412;
		default:	goto yy2;
		}
yy319:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy413;
		default:	goto yy2;
		}
yy320:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy414;
		default:	goto yy2;
		}
yy321:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy415;
		default:	goto yy2;
		}
yy322:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy416;
		default:	goto yy2;
		}
yy323:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy417;
		default:	goto yy2;
		}
yy324:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy418;
		default:	goto yy2;
		}
yy325:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy419;
		default:	goto yy2;
		}
yy326:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy420;
		default:	goto yy2;
		}
yy327:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy421;
		default:	goto yy2;
		}
yy328:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy422;
		default:	goto yy2;
		}
yy329:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy423;
		default:	goto yy2;
		}
yy330:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy424;
		default:	goto yy2;
		}
yy331:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy425;
		case 'h':	goto yy426;
		default:	goto yy2;
		}
yy332:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy427;
		default:	goto yy2;
		}
yy333:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy428;
		default:	goto yy2;
		}
yy334:
		yych = *++opt;
		goto yy30;
yy335:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy429;
		default:	goto yy2;
		}
yy336:
		++opt;
#line 1901 "cplus2asp.r2c"
		{ return OPT_STATS; }
#line 3745 "<stdout>"
yy338:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy430;
		default:	goto yy2;
		}
yy339:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy431;
		default:	goto yy2;
		}
yy340:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy432;
		default:	goto yy2;
		}
yy341:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy433;
		default:	goto yy2;
		}
yy342:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy434;
		default:	goto yy2;
		}
yy343:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy435;
		default:	goto yy2;
		}
yy344:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy436;
		default:	goto yy2;
		}
yy345:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy437;
		default:	goto yy2;
		}
yy346:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy438;
		default:	goto yy2;
		}
yy347:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy439;
		default:	goto yy2;
		}
yy348:
		++opt;
#line 1866 "cplus2asp.r2c"
		{ val = opt; return OPT_BRIDGE_OPTS; }
#line 3810 "<stdout>"
yy350:
		++opt;
#line 1868 "cplus2asp.r2c"
		{ val = opt; return OPT_BRIDGE_OUT; }
#line 3815 "<stdout>"
yy352:
		++opt;
#line 1870 "cplus2asp.r2c"
		{ return OPT_FRM_BRIDGE; }
#line 3820 "<stdout>"
yy354:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy440;
		default:	goto yy2;
		}
yy355:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy441;
		default:	goto yy2;
		}
yy356:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy442;
		default:	goto yy2;
		}
yy357:
		++opt;
#line 1874 "cplus2asp.r2c"
		{ return OPT_FROM_SO; }
#line 3843 "<stdout>"
yy359:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy444;
		default:	goto yy2;
		}
yy360:
		++opt;
#line 1878 "cplus2asp.r2c"
		{ val = opt; return OPT_GRD_OPTS; }
#line 3854 "<stdout>"
yy362:
		++opt;
#line 1880 "cplus2asp.r2c"
		{ val = opt; return OPT_GRD_OUT; }
#line 3859 "<stdout>"
yy364:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy445;
		default:	goto yy2;
		}
yy365:
		yyaccept = 13;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy447;
		default:	goto yy366;
		}
yy366:
#line 1885 "cplus2asp.r2c"
		{ return OPT_JUST_GRD; }
#line 3876 "<stdout>"
yy367:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy448;
		default:	goto yy2;
		}
yy368:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy449;
		default:	goto yy2;
		}
yy369:
		++opt;
#line 1888 "cplus2asp.r2c"
		{ return OPT_JUST_SO; }
#line 3893 "<stdout>"
yy371:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy451;
		default:	goto yy2;
		}
yy372:
		++opt;
#line 1953 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3904 "<stdout>"
yy374:
		++opt;
#line 1955 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3909 "<stdout>"
yy376:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy452;
		default:	goto yy2;
		}
yy377:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy454;
		default:	goto yy2;
		}
yy378:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy456;
		default:	goto yy2;
		}
yy379:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy458;
		default:	goto yy380;
		}
yy380:
#line 1913 "cplus2asp.r2c"
		{ return OPT_PREPROC_OPTS; }
#line 3937 "<stdout>"
yy381:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy460;
		default:	goto yy382;
		}
yy382:
#line 1915 "cplus2asp.r2c"
		{ return OPT_PREPROC_OUT; }
#line 3947 "<stdout>"
yy383:
		++opt;
#line 1918 "cplus2asp.r2c"
		{ val = opt; return OPT_SO_OPTS; }
#line 3952 "<stdout>"
yy385:
		++opt;
#line 1920 "cplus2asp.r2c"
		{ val = opt; return OPT_SO_OUT; }
#line 3957 "<stdout>"
yy387:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy462;
		default:	goto yy388;
		}
yy388:
#line 1922 "cplus2asp.r2c"
		{ return OPT_SYMTAB; }
#line 3967 "<stdout>"
yy389:
		++opt;
#line 1959 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 3972 "<stdout>"
yy391:
		++opt;
#line 1926 "cplus2asp.r2c"
		{ return OPT_TO_POST; }
#line 3977 "<stdout>"
yy393:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy464;
		default:	goto yy2;
		}
yy394:
		++opt;
#line 1930 "cplus2asp.r2c"
		{ val = opt; return OPT_TRANS; }
#line 3988 "<stdout>"
yy396:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy466;
		case 'u':	goto yy467;
		default:	goto yy2;
		}
yy397:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy468;
		default:	goto yy2;
		}
yy398:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy469;
		default:	goto yy2;
		}
yy399:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy470;
		default:	goto yy2;
		}
yy400:
		yyaccept = 4;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy471;
		case '=':	goto yy118;
		default:	goto yy56;
		}
yy401:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy472;
		default:	goto yy2;
		}
yy402:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy473;
		default:	goto yy2;
		}
yy403:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy474;
		case 'r':	goto yy475;
		default:	goto yy2;
		}
yy404:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy476;
		default:	goto yy2;
		}
yy405:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy477;
		default:	goto yy2;
		}
yy406:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy478;
		default:	goto yy2;
		}
yy407:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy479;
		default:	goto yy2;
		}
yy408:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy480;
		default:	goto yy2;
		}
yy409:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy481;
		case 'r':	goto yy482;
		default:	goto yy2;
		}
yy410:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy483;
		default:	goto yy2;
		}
yy411:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy484;
		default:	goto yy2;
		}
yy412:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy485;
		default:	goto yy2;
		}
yy413:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy486;
		default:	goto yy2;
		}
yy414:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy127;
		default:	goto yy2;
		}
yy415:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy129;
		default:	goto yy2;
		}
yy416:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy487;
		default:	goto yy2;
		}
yy417:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy488;
		default:	goto yy2;
		}
yy418:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy489;
		default:	goto yy2;
		}
yy419:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy490;
		default:	goto yy2;
		}
yy420:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy491;
		default:	goto yy2;
		}
yy421:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy492;
		default:	goto yy2;
		}
yy422:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy493;
		default:	goto yy2;
		}
yy423:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy494;
		default:	goto yy2;
		}
yy424:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy495;
		default:	goto yy2;
		}
yy425:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy496;
		default:	goto yy2;
		}
yy426:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy497;
		default:	goto yy2;
		}
yy427:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy498;
		default:	goto yy2;
		}
yy428:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy499;
		default:	goto yy2;
		}
yy429:
		yyaccept = 6;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy500;
		case '=':	goto yy146;
		default:	goto yy84;
		}
yy430:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy501;
		default:	goto yy2;
		}
yy431:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy502;
		default:	goto yy2;
		}
yy432:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy503;
		default:	goto yy2;
		}
yy433:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy504;
		default:	goto yy2;
		}
yy434:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy505;
		default:	goto yy2;
		}
yy435:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy506;
		default:	goto yy2;
		}
yy436:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy507;
		default:	goto yy2;
		}
yy437:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy508;
		default:	goto yy2;
		}
yy438:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy509;
		default:	goto yy2;
		}
yy439:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy32;
		default:	goto yy2;
		}
yy440:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy510;
		default:	goto yy2;
		}
yy441:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy512;
		default:	goto yy2;
		}
yy442:
		++opt;
#line 1872 "cplus2asp.r2c"
		{ return OPT_FRM_PRE; }
#line 4276 "<stdout>"
yy444:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy514;
		default:	goto yy2;
		}
yy445:
		++opt;
#line 1949 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 4287 "<stdout>"
yy447:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy515;
		default:	goto yy2;
		}
yy448:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy517;
		default:	goto yy2;
		}
yy449:
		++opt;
#line 1886 "cplus2asp.r2c"
		{ return OPT_JUST_PRE; }
#line 4304 "<stdout>"
yy451:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy519;
		default:	goto yy2;
		}
yy452:
		++opt;
#line 1957 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED; }
#line 4315 "<stdout>"
yy454:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy520;
		default:	goto yy455;
		}
yy455:
#line 1907 "cplus2asp.r2c"
		{ return OPT_POSTPROC_OPTS; }
#line 4325 "<stdout>"
yy456:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy522;
		default:	goto yy457;
		}
yy457:
#line 1909 "cplus2asp.r2c"
		{ return OPT_POSTPROC_OUT; }
#line 4335 "<stdout>"
yy458:
		++opt;
#line 1912 "cplus2asp.r2c"
		{ val = opt; return OPT_PREPROC_OPTS; }
#line 4340 "<stdout>"
yy460:
		++opt;
#line 1914 "cplus2asp.r2c"
		{ val = opt; return OPT_PREPROC_OUT; }
#line 4345 "<stdout>"
yy462:
		++opt;
#line 1923 "cplus2asp.r2c"
		{ val = opt; return OPT_SYMTAB; }
#line 4350 "<stdout>"
yy464:
		++opt;
#line 1928 "cplus2asp.r2c"
		{ return OPT_TO_TRANS; }
#line 4355 "<stdout>"
yy466:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy524;
		default:	goto yy2;
		}
yy467:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy526;
		default:	goto yy2;
		}
yy468:
		yych = *++opt;
		goto yy21;
yy469:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy115;
		default:	goto yy2;
		}
yy470:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy528;
		default:	goto yy2;
		}
yy471:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy529;
		default:	goto yy2;
		}
yy472:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy530;
		default:	goto yy2;
		}
yy473:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy531;
		default:	goto yy2;
		}
yy474:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy532;
		default:	goto yy2;
		}
yy475:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy533;
		default:	goto yy2;
		}
yy476:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy534;
		default:	goto yy2;
		}
yy477:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy535;
		default:	goto yy2;
		}
yy478:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy536;
		default:	goto yy2;
		}
yy479:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy537;
		default:	goto yy2;
		}
yy480:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy538;
		default:	goto yy2;
		}
yy481:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy539;
		default:	goto yy2;
		}
yy482:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy540;
		default:	goto yy2;
		}
yy483:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy541;
		default:	goto yy2;
		}
yy484:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy542;
		default:	goto yy2;
		}
yy485:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy20;
		default:	goto yy2;
		}
yy486:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy543;
		default:	goto yy2;
		}
yy487:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy544;
		default:	goto yy2;
		}
yy488:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy545;
		default:	goto yy2;
		}
yy489:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy546;
		default:	goto yy2;
		}
yy490:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy547;
		default:	goto yy2;
		}
yy491:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy548;
		default:	goto yy2;
		}
yy492:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy549;
		default:	goto yy2;
		}
yy493:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy550;
		default:	goto yy2;
		}
yy494:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy551;
		default:	goto yy2;
		}
yy495:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy552;
		default:	goto yy2;
		}
yy496:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy553;
		default:	goto yy2;
		}
yy497:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy554;
		default:	goto yy2;
		}
yy498:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy555;
		default:	goto yy2;
		}
yy499:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy556;
		default:	goto yy2;
		}
yy500:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy557;
		default:	goto yy2;
		}
yy501:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy558;
		default:	goto yy2;
		}
yy502:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy559;
		default:	goto yy2;
		}
yy503:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy560;
		default:	goto yy2;
		}
yy504:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy561;
		default:	goto yy2;
		}
yy505:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy562;
		default:	goto yy2;
		}
yy506:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy563;
		default:	goto yy2;
		}
yy507:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy564;
		default:	goto yy2;
		}
yy508:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy565;
		default:	goto yy2;
		}
yy509:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy566;
		default:	goto yy2;
		}
yy510:
		++opt;
#line 1947 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 4621 "<stdout>"
yy512:
		++opt;
#line 1873 "cplus2asp.r2c"
		{ return OPT_FRM_POST; }
#line 4626 "<stdout>"
yy514:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy567;
		default:	goto yy2;
		}
yy515:
		++opt;
#line 1950 "cplus2asp.r2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 4637 "<stdout>"
yy517:
		++opt;
#line 1887 "cplus2asp.r2c"
		{ return OPT_JUST_POST; }
#line 4642 "<stdout>"
yy519:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy569;
		default:	goto yy2;
		}
yy520:
		++opt;
#line 1906 "cplus2asp.r2c"
		{ val = opt; return OPT_POSTPROC_OPTS; }
#line 4653 "<stdout>"
yy522:
		++opt;
#line 1908 "cplus2asp.r2c"
		{ val = opt; return OPT_POSTPROC_OUT; }
#line 4658 "<stdout>"
yy524:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy571;
		default:	goto yy525;
		}
yy525:
#line 1933 "cplus2asp.r2c"
		{ return OPT_TRANS_OPTS; }
#line 4668 "<stdout>"
yy526:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy573;
		default:	goto yy527;
		}
yy527:
#line 1935 "cplus2asp.r2c"
		{ return OPT_TRANS_OUT; }
#line 4678 "<stdout>"
yy528:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy186;
		default:	goto yy2;
		}
yy529:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy575;
		case 'u':	goto yy576;
		default:	goto yy2;
		}
yy530:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy577;
		default:	goto yy2;
		}
yy531:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy578;
		default:	goto yy2;
		}
yy532:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy579;
		default:	goto yy2;
		}
yy533:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy580;
		default:	goto yy2;
		}
yy534:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy581;
		default:	goto yy2;
		}
yy535:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy582;
		default:	goto yy2;
		}
yy536:
		yyaccept = 5;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy583;
		case '=':	goto yy122;
		default:	goto yy59;
		}
yy537:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy584;
		default:	goto yy2;
		}
yy538:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy585;
		default:	goto yy2;
		}
yy539:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy586;
		default:	goto yy2;
		}
yy540:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy587;
		default:	goto yy2;
		}
yy541:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy588;
		default:	goto yy2;
		}
yy542:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy589;
		default:	goto yy2;
		}
yy543:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy590;
		default:	goto yy2;
		}
yy544:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy591;
		default:	goto yy2;
		}
yy545:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy284;
		default:	goto yy2;
		}
yy546:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy71;
		default:	goto yy2;
		}
yy547:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy592;
		default:	goto yy2;
		}
yy548:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy593;
		default:	goto yy2;
		}
yy549:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy594;
		default:	goto yy2;
		}
yy550:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy205;
		default:	goto yy2;
		}
yy551:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy595;
		default:	goto yy2;
		}
yy552:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy596;
		default:	goto yy2;
		}
yy553:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy597;
		default:	goto yy2;
		}
yy554:
		yych = *++opt;
		switch (yych) {
		case 'k':	goto yy73;
		default:	goto yy2;
		}
yy555:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy598;
		default:	goto yy2;
		}
yy556:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy599;
		default:	goto yy2;
		}
yy557:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy600;
		case 'u':	goto yy601;
		default:	goto yy2;
		}
yy558:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy602;
		default:	goto yy2;
		}
yy559:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy219;
		default:	goto yy2;
		}
yy560:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy603;
		default:	goto yy2;
		}
yy561:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy604;
		default:	goto yy2;
		}
yy562:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy605;
		default:	goto yy2;
		}
yy563:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy225;
		default:	goto yy2;
		}
yy564:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy606;
		default:	goto yy2;
		}
yy565:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy607;
		default:	goto yy2;
		}
yy566:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy209;
		default:	goto yy2;
		}
yy567:
		++opt;
#line 1875 "cplus2asp.r2c"
		{ return OPT_FROM_TRAN; }
#line 4921 "<stdout>"
yy569:
		++opt;
#line 1889 "cplus2asp.r2c"
		{ return OPT_JUST_TRANS; }
#line 4926 "<stdout>"
yy571:
		++opt;
#line 1932 "cplus2asp.r2c"
		{ val = opt; return OPT_TRANS_OPTS; }
#line 4931 "<stdout>"
yy573:
		++opt;
#line 1934 "cplus2asp.r2c"
		{ val = opt; return OPT_TRANS_OUT; }
#line 4936 "<stdout>"
yy575:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy608;
		default:	goto yy2;
		}
yy576:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy609;
		default:	goto yy2;
		}
yy577:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy610;
		default:	goto yy2;
		}
yy578:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy611;
		default:	goto yy2;
		}
yy579:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy612;
		default:	goto yy2;
		}
yy580:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy613;
		default:	goto yy2;
		}
yy581:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy614;
		default:	goto yy2;
		}
yy582:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy615;
		default:	goto yy2;
		}
yy583:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy616;
		case 's':	goto yy617;
		default:	goto yy2;
		}
yy584:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy618;
		default:	goto yy2;
		}
yy585:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy619;
		default:	goto yy2;
		}
yy586:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy620;
		default:	goto yy2;
		}
yy587:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy621;
		default:	goto yy2;
		}
yy588:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy622;
		default:	goto yy2;
		}
yy589:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy623;
		default:	goto yy2;
		}
yy590:
		yych = *++opt;
		switch (yych) {
		case 'x':	goto yy624;
		default:	goto yy2;
		}
yy591:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy625;
		default:	goto yy2;
		}
yy592:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy626;
		default:	goto yy2;
		}
yy593:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy627;
		default:	goto yy2;
		}
yy594:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy628;
		default:	goto yy2;
		}
yy595:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy207;
		default:	goto yy2;
		}
yy596:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy629;
		default:	goto yy2;
		}
yy597:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy630;
		default:	goto yy2;
		}
yy598:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy631;
		default:	goto yy2;
		}
yy599:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy632;
		default:	goto yy2;
		}
yy600:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy633;
		default:	goto yy2;
		}
yy601:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy634;
		default:	goto yy2;
		}
yy602:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy635;
		default:	goto yy2;
		}
yy603:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy636;
		default:	goto yy2;
		}
yy604:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy637;
		default:	goto yy2;
		}
yy605:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy638;
		default:	goto yy2;
		}
yy606:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy639;
		default:	goto yy2;
		}
yy607:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy640;
		default:	goto yy2;
		}
yy608:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy266;
		default:	goto yy2;
		}
yy609:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy641;
		default:	goto yy2;
		}
yy610:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy352;
		default:	goto yy2;
		}
yy611:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy642;
		default:	goto yy2;
		}
yy612:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy643;
		default:	goto yy2;
		}
yy613:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy644;
		default:	goto yy2;
		}
yy614:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy357;
		default:	goto yy2;
		}
yy615:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy645;
		default:	goto yy2;
		}
yy616:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy646;
		case 'u':	goto yy647;
		default:	goto yy2;
		}
yy617:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy648;
		default:	goto yy2;
		}
yy618:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy649;
		default:	goto yy2;
		}
yy619:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy650;
		default:	goto yy2;
		}
yy620:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy651;
		default:	goto yy2;
		}
yy621:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy652;
		default:	goto yy2;
		}
yy622:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy369;
		default:	goto yy2;
		}
yy623:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy653;
		default:	goto yy2;
		}
yy624:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy654;
		default:	goto yy2;
		}
yy625:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy655;
		default:	goto yy2;
		}
yy626:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy656;
		default:	goto yy2;
		}
yy627:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy657;
		default:	goto yy2;
		}
yy628:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy658;
		default:	goto yy2;
		}
yy629:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy659;
		default:	goto yy2;
		}
yy630:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy131;
		default:	goto yy70;
		}
yy631:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy660;
		default:	goto yy2;
		}
yy632:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy661;
		default:	goto yy2;
		}
yy633:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy298;
		default:	goto yy2;
		}
yy634:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy662;
		default:	goto yy2;
		}
yy635:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy663;
		default:	goto yy2;
		}
yy636:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy664;
		default:	goto yy2;
		}
yy637:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy665;
		default:	goto yy2;
		}
yy638:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy666;
		default:	goto yy2;
		}
yy639:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy667;
		default:	goto yy2;
		}
yy640:
		yyaccept = 12;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy668;
		case '=':	goto yy394;
		default:	goto yy309;
		}
yy641:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy189;
		default:	goto yy2;
		}
yy642:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy669;
		default:	goto yy2;
		}
yy643:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy670;
		default:	goto yy2;
		}
yy644:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy671;
		default:	goto yy2;
		}
yy645:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy672;
		default:	goto yy2;
		}
yy646:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy673;
		default:	goto yy2;
		}
yy647:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy674;
		default:	goto yy2;
		}
yy648:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy675;
		default:	goto yy2;
		}
yy649:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy676;
		default:	goto yy2;
		}
yy650:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy677;
		default:	goto yy2;
		}
yy651:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy678;
		default:	goto yy2;
		}
yy652:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy679;
		default:	goto yy2;
		}
yy653:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy680;
		default:	goto yy2;
		}
yy654:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy681;
		default:	goto yy2;
		}
yy655:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy682;
		default:	goto yy2;
		}
yy656:
		yyaccept = 9;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy683;
		default:	goto yy202;
		}
yy657:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy684;
		default:	goto yy2;
		}
yy658:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy685;
		default:	goto yy2;
		}
yy659:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy686;
		default:	goto yy2;
		}
yy660:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy687;
		default:	goto yy2;
		}
yy661:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy688;
		default:	goto yy2;
		}
yy662:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy217;
		default:	goto yy2;
		}
yy663:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy387;
		default:	goto yy2;
		}
yy664:
		yyaccept = 11;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy689;
		default:	goto yy222;
		}
yy665:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy690;
		default:	goto yy2;
		}
yy666:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy691;
		default:	goto yy2;
		}
yy667:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy692;
		default:	goto yy2;
		}
yy668:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy693;
		default:	goto yy2;
		}
yy669:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy694;
		default:	goto yy2;
		}
yy670:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy695;
		default:	goto yy2;
		}
yy671:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy696;
		default:	goto yy2;
		}
yy672:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy697;
		default:	goto yy2;
		}
yy673:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy275;
		default:	goto yy2;
		}
yy674:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy698;
		default:	goto yy2;
		}
yy675:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy699;
		default:	goto yy2;
		}
yy676:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy17;
		default:	goto yy2;
		}
yy677:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy700;
		default:	goto yy2;
		}
yy678:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy701;
		default:	goto yy2;
		}
yy679:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy702;
		default:	goto yy2;
		}
yy680:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy703;
		default:	goto yy2;
		}
yy681:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy704;
		default:	goto yy2;
		}
yy682:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy705;
		default:	goto yy2;
		}
yy683:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy706;
		default:	goto yy2;
		}
yy684:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy707;
		default:	goto yy2;
		}
yy685:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy708;
		default:	goto yy2;
		}
yy686:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy452;
		default:	goto yy2;
		}
yy687:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy709;
		default:	goto yy2;
		}
yy688:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy710;
		default:	goto yy2;
		}
yy689:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy711;
		default:	goto yy2;
		}
yy690:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy712;
		default:	goto yy2;
		}
yy691:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy713;
		default:	goto yy2;
		}
yy692:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy464;
		default:	goto yy2;
		}
yy693:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy714;
		case 'u':	goto yy715;
		default:	goto yy2;
		}
yy694:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy716;
		default:	goto yy2;
		}
yy695:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy717;
		default:	goto yy2;
		}
yy696:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy718;
		default:	goto yy2;
		}
yy697:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy719;
		default:	goto yy2;
		}
yy698:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy192;
		default:	goto yy2;
		}
yy699:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy720;
		default:	goto yy2;
		}
yy700:
		yyaccept = 13;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy721;
		default:	goto yy366;
		}
yy701:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy722;
		default:	goto yy2;
		}
yy702:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy723;
		default:	goto yy2;
		}
yy703:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy724;
		default:	goto yy2;
		}
yy704:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy67;
		default:	goto yy2;
		}
yy705:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy725;
		default:	goto yy2;
		}
yy706:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy726;
		default:	goto yy2;
		}
yy707:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy727;
		default:	goto yy2;
		}
yy708:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy728;
		default:	goto yy2;
		}
yy709:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy729;
		default:	goto yy2;
		}
yy710:
		yyaccept = 7;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy730;
		case '=':	goto yy213;
		default:	goto yy145;
		}
yy711:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy731;
		default:	goto yy2;
		}
yy712:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy732;
		default:	goto yy2;
		}
yy713:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy733;
		default:	goto yy2;
		}
yy714:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy734;
		default:	goto yy2;
		}
yy715:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy735;
		default:	goto yy2;
		}
yy716:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy736;
		default:	goto yy2;
		}
yy717:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy737;
		default:	goto yy2;
		}
yy718:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy738;
		default:	goto yy2;
		}
yy719:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy567;
		default:	goto yy2;
		}
yy720:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy739;
		default:	goto yy2;
		}
yy721:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy740;
		default:	goto yy2;
		}
yy722:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy741;
		default:	goto yy2;
		}
yy723:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy742;
		default:	goto yy2;
		}
yy724:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy569;
		default:	goto yy2;
		}
yy725:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy743;
		default:	goto yy2;
		}
yy726:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy744;
		default:	goto yy2;
		}
yy727:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy745;
		default:	goto yy2;
		}
yy728:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy746;
		default:	goto yy2;
		}
yy729:
		yyaccept = 10;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy747;
		case '=':	goto yy293;
		default:	goto yy212;
		}
yy730:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy748;
		default:	goto yy2;
		}
yy731:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy749;
		default:	goto yy2;
		}
yy732:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy750;
		default:	goto yy2;
		}
yy733:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy751;
		default:	goto yy2;
		}
yy734:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy524;
		default:	goto yy2;
		}
yy735:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy752;
		default:	goto yy2;
		}
yy736:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy753;
		default:	goto yy2;
		}
yy737:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy754;
		default:	goto yy2;
		}
yy738:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy755;
		default:	goto yy2;
		}
yy739:
		yyaccept = 8;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy756;
		default:	goto yy194;
		}
yy740:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy757;
		default:	goto yy2;
		}
yy741:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy758;
		default:	goto yy2;
		}
yy742:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy759;
		default:	goto yy2;
		}
yy743:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy760;
		default:	goto yy2;
		}
yy744:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy761;
		default:	goto yy2;
		}
yy745:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy762;
		default:	goto yy2;
		}
yy746:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy288;
		default:	goto yy2;
		}
yy747:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy763;
		default:	goto yy2;
		}
yy748:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy764;
		case 'u':	goto yy765;
		default:	goto yy2;
		}
yy749:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy766;
		default:	goto yy2;
		}
yy750:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy767;
		default:	goto yy2;
		}
yy751:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy305;
		default:	goto yy2;
		}
yy752:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy467;
		default:	goto yy2;
		}
yy753:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy768;
		default:	goto yy2;
		}
yy754:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy769;
		default:	goto yy2;
		}
yy755:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy770;
		default:	goto yy2;
		}
yy756:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy771;
		default:	goto yy2;
		}
yy757:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy772;
		default:	goto yy2;
		}
yy758:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy773;
		default:	goto yy2;
		}
yy759:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy774;
		default:	goto yy2;
		}
yy760:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy775;
		default:	goto yy2;
		}
yy761:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy776;
		default:	goto yy2;
		}
yy762:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy374;
		default:	goto yy2;
		}
yy763:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy777;
		case 'u':	goto yy778;
		default:	goto yy2;
		}
yy764:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy779;
		default:	goto yy2;
		}
yy765:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy780;
		default:	goto yy2;
		}
yy766:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy781;
		default:	goto yy2;
		}
yy767:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy391;
		default:	goto yy2;
		}
yy768:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy782;
		default:	goto yy2;
		}
yy769:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy783;
		default:	goto yy2;
		}
yy770:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy442;
		default:	goto yy2;
		}
yy771:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy784;
		default:	goto yy2;
		}
yy772:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy785;
		default:	goto yy2;
		}
yy773:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy786;
		default:	goto yy2;
		}
yy774:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy449;
		default:	goto yy2;
		}
yy775:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy133;
		default:	goto yy2;
		}
yy776:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy372;
		default:	goto yy2;
		}
yy777:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy787;
		default:	goto yy2;
		}
yy778:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy788;
		default:	goto yy2;
		}
yy779:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy379;
		default:	goto yy2;
		}
yy780:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy789;
		default:	goto yy2;
		}
yy781:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy389;
		default:	goto yy2;
		}
yy782:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy790;
		default:	goto yy2;
		}
yy783:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy512;
		default:	goto yy2;
		}
yy784:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy791;
		default:	goto yy2;
		}
yy785:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy792;
		default:	goto yy2;
		}
yy786:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy517;
		default:	goto yy2;
		}
yy787:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy454;
		default:	goto yy2;
		}
yy788:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy793;
		default:	goto yy2;
		}
yy789:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy297;
		default:	goto yy2;
		}
yy790:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy510;
		default:	goto yy2;
		}
yy791:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy445;
		default:	goto yy2;
		}
yy792:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy515;
		default:	goto yy2;
		}
yy793:
		++opt;
		switch ((yych = *opt)) {
		case 'u':	goto yy378;
		default:	goto yy2;
		}
	}
#line 1961 "cplus2asp.r2c"

}

OptionStatus parseConfigOptions(Config& outConf){


	namespace btree = boost::property_tree;

	try{
		const char *homedir;
		if ((homedir = getenv("HOME")) == NULL) {
		    homedir = getpwuid(getuid())->pw_dir;
		}

		std::string dir (homedir);
		btree::ptree pt;
		char const* tmpptr;
		size_t tmpoffset;
		char tmpPath[PATH_MAX];
		std::list<char const*> rawInputList;
		std::pair<unsigned int, unsigned int> steps;
		unsigned int tmpInt;
		Config::Mode mode;
		bool tmpBool;

		read_ini(dir.append("/.cplus2asp.config"),pt);	
		
		for (auto& section:pt){
			//Check for cplus2asp section
			if(boost::iequals(section.first, "cplus2asp")){
				for (auto& key : section.second){
					char const* tmpptr = key.second.get_value<std::string>().c_str();	

					switch(parseOption(key.first.c_str(), tmpptr)){
						case OPT_AUTO:
							// This is supposed to be an automated run, don't ask the user for anything.
							if (outConf.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION, true)) {
								utils::warning("Detected redefinition of option '%s'. Continuing with value '%s'",true,key.second.get_value<std::string>().c_str(),"true");
							}
							break;
						case OPT_BRIDGE:
							// They are specifying a specific command for the bridge.
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
								}
							

							if (outConf.command(Config::TC_REACTIVE_BRIDGE, tmpptr)) {
								utils::warning("Detected redefinition of bridge command. Continuing with value '%s'",true,tmpptr);
							}

							break;
						case OPT_BRIDGE_OPTS:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected pass-through options following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
								
							}

							if (outConf.opts(Config::TC_REACTIVE_BRIDGE, tmpptr)) {
								utils::warning("Detected redefinition of bridge command options. Continuing with value '%s'",true,tmpptr);
							}
							break;
						case OPT_BRIDGE_OUT:

							utils::error("Redirecting the reactive bridge's output is currently unsupported.", true, 0);
							return OPT_STAT_BAD_ARG;

						case OPT_CONST:
									tmpptr = key.second.get_value<std::string>().c_str();
									const char* temp;	
									// Constant Declaration...
									if((temp = strchr(tmpptr,'=')) != NULL)
									{
										tmpoffset = (size_t)(temp - tmpptr);

										// Get the constant name/value
										std::string name = std::string(key.second.get_value<std::string>().c_str(), tmpoffset);
										std::string value = std::string(&(key.second.get_value<std::string>().c_str()[tmpoffset+1]));

										utils::debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

										if (outConf.def(name,value)) {
											utils::warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
										}

									} else {   // Set up for a constant without actually giving one, bad command line.
										utils::error("Expected a constant definition of the form 'constant=value' after option '%s'. Exiting.",true,0,key.first.c_str());
										return OPT_STAT_BAD_ARG;
									}
									break;

						case OPT_FRM_BRIDGE:
							utils::pragma("Running the toolchain from the reactive bridge is discouraged.",true);
							if (outConf.setRunFrom(Config::TC_REACTIVE_BRIDGE)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						// case OPT_FRM_GRD:
						// 	// Don't run anything before the grounder.
						// 	if (outConf.setRunFrom(Config::TC_GROUNDER)) {
						// 		utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
						// 	}
						// 	break;					

						case OPT_FRM_PRE:
									// Don't run anything before the pre-processor.
									if (outConf.setRunFrom(Config::TC_PREPROC)) {
										utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
									}
									break;	

						case OPT_FRM_POST:
							// Don't call anything before the post-processor (equivalent to "-justpost")
							if (outConf.setRunFrom(Config::TC_POSTPROC)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_FROM_SO:
							// Don't run anything before the solver.
							if (outConf.setRunFrom(Config::TC_SOLVER)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_FROM_TRAN:
							// Don't call anything before the translator (basically a no-op option).
							if (outConf.setRunFrom(Config::TC_TRANSLATOR)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						// case OPT_GRD:
						// 	// They're giving us a specific executable to use as the grounder instead of the default.
						// 	// Make sure a second argument follows, and save the new grounder.
						// 	tmpptr = key.second.get_value<std::string>().c_str();
						// 	if (!tmpptr) {

						// 		// setup for a command but they didn't deliver.
						// 		utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
						// 		return OPT_STAT_BAD_ARG;
								
						// 	}

						// 	if (outConf.command(Config::TC_GROUNDER, tmpptr)) {
						// 		utils::warning("Detected redefinition of grounder command. Continuing with value '%s'",true,tmpptr);
						// 	}

						// 	break;

						// case OPT_GRD_OPTS:
						// 	tmpptr = key.second.get_value<std::string>().c_str();
						// 	if (!tmpptr) {
						// 		// setup for options but they didn't deliver
						// 		utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, key.first.c_str());
						// 		return OPT_STAT_BAD_ARG;
								
						// 	}

						// 	if (outConf.opts(Config::TC_GROUNDER, tmpptr)) {
						// 		utils::warning("Detected redefinition of grounder command options. Continuing with value '%s'",true, tmpptr);
						// 	}

						// 	break;

						// case OPT_GRD_OUT:
						// 	tmpptr = key.second.get_value<std::string>().c_str();
						// 	if (!tmpptr) {
								
						// 		// setup for a command but they didn't deliver.
						// 		utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
						// 		return OPT_STAT_BAD_ARG;
							
						// 	}

						// 	if (outConf.output(Config::TC_GROUNDER, tmpptr)) {
						// 		utils::warning("Detected redefinition of the grounder output file. Continuing with value '%s'",true, tmpptr);
						// 	}
						// 	break;

						case OPT_GRINGO_NONE_HACK:
							// Specifying a none_hack value.
							tmpptr = key.second.get_value<std::string>().c_str();
							if (!tmpptr) {
								utils::warning("Option '%s' has been deprecated in favor of specifying an explicit none alias value.",true,key.first.c_str());

								tmpptr = DEF_NONE_HACK_VAL;
							}


							if (outConf.strOpt(Config::STR_NONE_ALIAS, tmpptr)) {
								utils::warning("Detected redefinition of the none alias option. Continuing with value '%s'",true, tmpptr);
							}

							break;

						// case OPT_JUST_GRD:
						// 		// Just call the grounder program, no others.
						// 		if (outConf.setOnlyRun(Config::TC_GROUNDER)) {
						// 			utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
						// 		}
						// 		break;

						case OPT_JUST_PRE:
							// Just call the preprocessor program, no others.
							if (outConf.setOnlyRun(Config::TC_PREPROC)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_JUST_POST:
							// Just call the postprocessor program, no others.
							if (outConf.setOnlyRun(Config::TC_POSTPROC)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_JUST_SO:
							// Just call the solver program, no others.
							if (outConf.setOnlyRun(Config::TC_SOLVER)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_JUST_TRANS:
							// Just call the translator program, no others.
							if (outConf.setOnlyRun(Config::TC_TRANSLATOR)) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;


						case OPT_LANG:
							Config::Language l;
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (!outConf.parseLang(tmpptr, l)) {
								utils::error("'%s' is not a supported language specification.", 0, true, tmpptr);
								return OPT_STAT_BAD_ARG;
							}
							if (outConf.lang(l)) {
								utils::warning("Detected a redefition of the input language.",true,tmpptr);
							}
							break;

						case OPT_MAXSTEP:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (!tmpptr) {
							
									utils::error("Expected a maximum step following option '%s'. Exiting.",true,0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
							}
							

							if ((steps = Config::parseMaxstep(tmpptr)).second == Config::UNDEFINED) {
								utils::error("'%s' is not a valid step value. Exiting.",true,0, tmpptr);
								return OPT_STAT_BAD_ARG;
							} else if (outConf.intConfigOpt(Config::OPT_MAXSTEP, steps.second)
									|| (steps.first != Config::UNDEFINED && outConf.intConfigOpt(Config::OPT_MINSTEP, steps.first)))
							{
								utils::warning("Detected a redefinition of the maximum step. Continuing with the value '%s'.",true,tmpptr);
							}
							break;


						case OPT_MINSTEP:

							tmpptr = key.second.get_value<std::string>().c_str();
							if (!tmpptr) {

								utils::error("Expected a minimum step following option '%s'. Exiting.",true,0,key.first.c_str());
								return OPT_STAT_BAD_ARG;
							}

					
							if (!utils::from_string(tmpInt, tmpptr)) {
								utils::error("'%s' is not a valid step value. Exiting.",true,0, tmpptr);
								return OPT_STAT_BAD_ARG;
							} else if (outConf.intConfigOpt(Config::OPT_MINSTEP, tmpInt)) {
								utils::warning("Detected a redefinition of the minimum step. Continuing with value '%s'.",true,tmpptr);
							}

							break;
						case OPT_NO_DOMAIN_ENFORCE:
							outConf.boolConfigOpt(Config::OPT_NO_DOMAIN_ENFORCE, true);
							break;
						case OPT_NO_ADD_DOMAIN_ENFORCE:
							outConf.boolConfigOpt(Config::OPT_NO_ADD_DOMAIN_ENFORCE, true);
							break;

						case OPT_MODE_SELECT:
							tmpBool = false;

							tmpptr = key.second.get_value<std::string>().c_str();	
							if (!strcmp(tmpptr,ARG_MODE_STATIC_MANUAL)) {
								mode = Config::MODE_STATIC_MANUAL;
							} else if (!strcmp(tmpptr,ARG_MODE_STATIC_AUTO)) {
								mode = Config::MODE_STATIC_AUTO;
							} else if (!strcmp(tmpptr,ARG_MODE_INCREMENTAL)) {
								mode = Config::MODE_INCREMENTAL;
							} else if (!strcmp(tmpptr,ARG_MODE_REACTIVE)) {
								mode = Config::MODE_INCREMENTAL;
							} else {
								utils::error("Unexpected value '%s'. Expected a mode option (one of '%s', '%s', '%s', or '%s'). Exiting.",true,0,
										tmpptr, ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, OPT_MODE_REACTIVE);
								return OPT_STAT_BAD_ARG;
							}

							if (outConf.mode(mode)) {
								utils::warning("Detected a redefinition of the program's running mode. Continuing with value '%s'.", true, tmpptr);
							}

							break;
						
						case OPT_MODE_STATIC_AUTO:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (outConf.mode(Config::MODE_STATIC_AUTO)) {
								utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'static-auto'.", true);
							}
							break;
						
						case OPT_MODE_STATIC_MANUAL:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (outConf.mode(Config::MODE_STATIC_MANUAL)) {
								utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'static-manual'.", true);
							}
							break;
						
						case OPT_MODE_INCREMENTAL:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (outConf.mode(Config::MODE_INCREMENTAL)) {
								utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'incremental'", true);
							}
							break;
						
						case OPT_MODE_REACTIVE:
							tmpptr = key.second.get_value<std::string>().c_str();	
							if (outConf.mode(Config::MODE_REACTIVE)) {
								utils::warning("Detected a redefinition of the program's running mode. Continuing with value 'reactive'.", true);
							}
							break;

						case OPT_NO_DEL:
							tmpBool = false;
							utils::warning("The option '%s' has been deprecated in favor of the '--[PROG]-output=[OUTFILE] option.", true,key.second.get_value<std::string>().c_str());

							tmpBool = outConf.output(Config::TC_TRANSLATOR, DEF_INT_TRANS_FILE) 
									|/* non-shortcutting bitwise or */ outConf.output(Config::TC_PREPROC, DEF_INT_PREPROC_FILE)

									| outConf.output(Config::TC_SOLVER, DEF_INT_SO_FILE);

							// Shut off deleting intermediate files.
							if (tmpBool) {
								utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							}
							break;

						case OPT_SHIFT:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// default true
									tmpptr = "true";
								}
								
								bool val;
								if (!strcmp(tmpptr, "true")) {
									val = true;
								} else if (!strcmp(tmpptr, "false")) {
									val = false;
								} else {
									utils::error("Invalid shift value. Expected a Boolean value ('true' or 'false'). Exiting.", true, 0, key.second.get_value<std::string>().c_str());
									return OPT_STAT_BAD_ARG;
								}

								if (outConf.boolConfigOpt(Config::OPT_SHIFT, val)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}

								break;

							case OPT_STATS:
								// Don't include standard files in the final product.
								if (outConf.boolConfigOpt(Config::OPT_STATS, true)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}

								break;

							case OPT_PORT_EXTERNAL:
								// Set the external port to use in reactive mode
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									utils::error("Expected a port number following option '%s'. Exiting.",true,0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}


								if (!utils::from_string(tmpInt, tmpptr) || tmpInt < 1) {
									utils::error("'%s' is not a valid port. Exiting.",true,0, tmpptr);
									return OPT_STAT_BAD_ARG;
								} else if (outConf.intConfigOpt(Config::OPT_EXT_PORT, tmpInt)) {
									utils::warning("Detected a redefinition of the external port. Continuing with value '%s'.",true,tmpptr);
								}

								break;
							case OPT_PORT_INTERNAL:
								// Set the internal port to use in reactive mode
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
					
										utils::error("Expected a port number following option '%s'. Exiting.",true,0, key.first.c_str());
										return OPT_STAT_BAD_ARG;
									
								}

								if (!utils::from_string(tmpInt, tmpptr) || tmpInt < 1) {
									utils::error("'%s' is not a valid port. Exiting.",true,0, tmpptr);
									return OPT_STAT_BAD_ARG;
								} else if (outConf.intConfigOpt(Config::OPT_INT_PORT, tmpInt)) {
									utils::warning("Detected a redefinition of the internal port. Continuing with value '%s'.",true,tmpptr);
								}

								break;

							case OPT_POSTPROC:
								// They're giving us a specific executable to use as the post-processor instead of the default.
								// Make sure a second argument follows, and save the new post-processor.
								tmpptr = key.second.get_value<std::string>().c_str();

								if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}

								if (outConf.command(Config::TC_POSTPROC, tmpptr)) {
									utils::warning("Detected redefinition of post-processor command. Continuing with value '%s'.",true,tmpptr);
								}
						
								break;
							case OPT_POSTPROC_OPTS:

								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {

									// setup for options but they didn't deliver
									utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}


								if (outConf.opts(Config::TC_POSTPROC, tmpptr)) {
									utils::warning("Detected redefinition of post-processor command options. Continuing with value '%s'",true,tmpptr);
								}

								break;

							case OPT_POSTPROC_OUT:

								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									
									// setup for a command but they didn't deliver.
									utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}

								if (outConf.output(Config::TC_POSTPROC, tmpptr)) {
									utils::warning("Detected redefinition of the post-processor output file. Continuing with value '%s'",true, tmpptr);
								}
								break;

							case OPT_PREPROC:
								// They're giving us a specific executable to use as the pre-processor instead of the default.
								// Make sure a second argument follows, and save the new pre-processor.
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									
									// setup for a command but they didn't deliver.
									utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
								
								}

								if (outConf.command(Config::TC_PREPROC, tmpptr)) {
									utils::warning("Detected redefinition of pre-processor command. Continuing with value '%s'",true,tmpptr);
								}
								break;

							case OPT_PREPROC_OPTS:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									
									// setup for options but they didn't deliver
									utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0,key.first.c_str() );
									return OPT_STAT_BAD_ARG;
								}


								if (outConf.opts(Config::TC_PREPROC, tmpptr)) {
									utils::warning("Detected redefinition of pre-processor command options. Continuing with value '%s'",true,tmpptr);
								}

								break;
							case OPT_PREPROC_OUT:

								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}

								if (outConf.output(Config::TC_PREPROC, tmpptr)) {
									utils::warning("Detected redefinition of the pre-processor output file. Continuing with value '%s'",true, tmpptr);
								}
								break;

							case OPT_SO:
								tmpptr = key.second.get_value<std::string>().c_str();
								// They're giving us a specific executable to use as the solver instead of the default.
								// Make sure a second argument follows, and save the new solver.
								if (!tmpptr) {
										// setup for a command but they didn't deliver.
										utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
										return OPT_STAT_BAD_ARG;
								}

								if (outConf.command(Config::TC_SOLVER, tmpptr)) {
									utils::warning("Detected redefinition of solver command. Continuing with value '%s'",true,tmpptr);
								}
								break;

							case OPT_SO_OPTS:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// setup for options but they didn't deliver
									utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
								}


								if (outConf.opts(Config::TC_SOLVER, tmpptr)) {
									utils::warning("Detected redefinition of solver command options. Continuing with value '%s'",true, tmpptr);
								}

								break;

							case OPT_SO_OUT:
								tmpptr = key.second.get_value<std::string>().c_str();

								if (!tmpptr) {
									
									// setup for a command but they didn't deliver.
									utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}

								if (outConf.output(Config::TC_SOLVER, tmpptr)) {
									utils::warning("Detected redefinition of the solver output file. Continuing with value '%s'",true, tmpptr);
								}
								break;

							case OPT_SYMTAB:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									
									utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
								}

								if (outConf.strOpt(Config::STR_SYMTAB_FILE, tmpptr)) {
									utils::warning("Detected redefinition of the symbol table file. Continuing with value '%s'",true, tmpptr);
								}
								break;


							case OPT_TO_BRIDGE:
								if (outConf.setRunTo(Config::TC_REACTIVE_BRIDGE)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}
								break;

							// case OPT_TO_GRD:
							// 	// Shut off deleting intermediate files.
							// 	if (outConf.setRunTo(Config::TC_GROUNDER)) {
							// 		utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
							// 	}
							// 	break;

							case OPT_TO_PRE:
								// Run everything up to the pre-processor.
								if (outConf.setRunTo(Config::TC_PREPROC)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}
								break;

							case OPT_TO_POST:
								// Run everything up to the post-processor...
								if (outConf.setRunTo(Config::TC_POSTPROC)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}
								break;

							case OPT_TO_SO:
								// Run everything up to the solver...
								if (outConf.setRunTo(Config::TC_SOLVER)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}
								break;

							case OPT_TO_TRANS:
								// Run everything up to the translator...
								if (outConf.setRunTo(Config::TC_TRANSLATOR)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,key.second.get_value<std::string>().c_str());
								}
								break;
							case OPT_TRANS:
								// They're giving us a specific executable to use as the translator instead of the default.
								// Make sure a second argument follows, and save the new grounder.
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected a command following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}


								if (outConf.command(Config::TC_TRANSLATOR, tmpptr)) {
									utils::warning("Detected redefinition of translator command. Continuing with value '%s'.",true,tmpptr);
								}

								break;

							case OPT_TRANS_OPTS:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// setup for options but they didn't deliver
									utils::error("Expected pass-through options following the option '%s'. Exiting.", true, 0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}


								if (outConf.opts(Config::TC_TRANSLATOR, tmpptr)) {
									utils::warning("Detected redefinition of translator command options. Continuing with value '%s'.",true,tmpptr);
								}

								break;
							case OPT_TRANS_OUT:
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									// setup for a command but they didn't deliver.
									utils::error("Expected a file name following option '%s'. Exiting.",true,0,key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}

								if (outConf.output(Config::TC_TRANSLATOR, tmpptr)) {
									utils::warning("Detected redefinition of the translator output file. Continuing with value '%s'",true, tmpptr);
								}
								break;

							case OPT_VERSION:
								return OPT_STAT_VERSION;

							case OPT_HELP:
								return OPT_STAT_HELP;

							case OPT_QUERY:
								tmpBool = false;
								tmpptr = key.second.get_value<std::string>().c_str();
								if (!tmpptr) {
									tmpBool = true;
									utils::error("Expected a query identifier following option '%s'. Exiting.",true,0, key.first.c_str());
									return OPT_STAT_BAD_ARG;
									
								}
								if (outConf.strOpt(Config::STR_QUERY, tmpptr)) {
									utils::warning("The option '%s' has overridden one or more previous choices.",true,(tmpBool) ? key.first.c_str() : key.second.get_value<std::string>().c_str());
								}
								break;

							case OPT_UNSUPPORTED:
								// Whatever this is, it's unsupported.
								utils::warning("The '%s' option is no longer supported. It will be ignored.",true,key.second.get_value<std::string>().c_str());
								break;
							case OPT_UNSUPPORTED_NO_STD:
								// they want us to not include the standard file...
								// we don't use a standard file anymore.
								utils::warning("The '%s' option is no longer supported as standard files are no longer used.", true, key.second.get_value<std::string>().c_str());
								break;

							case OPT_UNSUPPORTED_ADDITIVE:
								// They want us to include the additive standard file...
								utils::warning("The '%s' option is no longer supported as standard files are no longer used.",true,key.second.get_value<std::string>().c_str());
								break;

							case OPT_UNSUPPORTED_GRSO:
								// They did something involving the explicit grounder/solver
								// We no longer support the explicit grounder/solver calls
								utils::error("The '%s' option is no longer supported. We no longer use a dedicated grounder/solver in the toolchain. Please make use of the solver component instead.",true,0,key.second.get_value<std::string>().c_str());

								// We probably aren't going to do what they want, go ahead and signal that something went wrong
								return OPT_STAT_BAD_ARG;

							case OPT_UNSUPPORTED_MANUAL_MAXSTEP:
								// Manually advance the maximum step of the program query
								utils::error("The '%s' option is no longer supported. Please use that '--mode=static-manual' option instead.",true,0,key.second.get_value<std::string>().c_str());
								break;

							case OPT_UNKNOWN:
								utils::debug("The option isn't a recognized flag. Checking other possibilities.", true);
								if (key.second.get_value<std::string>().c_str()[0] == '-')
								{
									// It appears to be a bad argument...
									utils::error("Found an unrecognized argument '%s'. Exiting.",true,0,key.second.get_value<std::string>().c_str());
									return OPT_STAT_BAD_ARG;
								}

								// If there's no "header" on the argument, it's either a constant declaration, an input file, or the number of solutions.
								else if(!strcmp(key.second.get_value<std::string>().c_str(), "all") || !strcmp(key.second.get_value<std::string>().c_str(), "ALL")) {
									if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, 0)) {
										utils::warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,key.second.get_value<std::string>().c_str());
									}
								}
								else if(utils::isInteger(key.second.get_value<std::string>().c_str()))
								{	// It looks like a number, atoi it and save that as the desired number of solutions.
									int numSolutions = atoi(key.second.get_value<std::string>().c_str());
									if(numSolutions < 0) {
										utils::warning("The number of solutions cannot be negative. Ignoring the argument.",true);
									} else {
										if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, (unsigned int)numSolutions)) {
											utils::warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,key.second.get_value<std::string>().c_str());
										}
									}
								}
								else if((tmpptr = strchr(key.second.get_value<std::string>().c_str(),'=')) != NULL)
								{   // Found an equals sign in the argument, it's probably a "const=value" declaration.
									tmpoffset = (size_t)(tmpptr - key.second.get_value<std::string>().c_str());

									// Get the constant name/value
									std::string name = std::string(key.second.get_value<std::string>().c_str(), tmpoffset);
									std::string value = std::string(&(key.second.get_value<std::string>().c_str()[tmpoffset+1]));

									utils::debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

									if (outConf.def(name,value)) {
										utils::warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
									}
								}
								else
								{	// If it's not a number, it's probably an input file. Make sure it exists, and then save it to the list.

									if(realpath(key.second.get_value<std::string>().c_str(), tmpPath) == NULL)
									{
										// Couldn't find the input file...
										utils::error("Unable to locate input file '%s'. Exiting.",true,0,key.second.get_value<std::string>().c_str());
										return OPT_STAT_BAD_ARG;
									}
									else
									{
										// Save all of the input files until we are done and can handle them...
										rawInputList.push_back(key.second.get_value<std::string>().c_str());
									}
								}
								break;



					}
				}
			}
		}


		utils::debug("Handling input files...", true);
		if (!rawInputList.size()) {
			//uh-oh. They didn't specify any input files. This simply won't do.
			utils::error("One or more input files must be specified.",true,0);
			return OPT_STAT_BAD_ARG;
		}

		// They've insisted on sticking with a given mode. Make sure they're aware if they're using an incompatible
		for (std::list<char const*>::iterator it = rawInputList.begin(); it != rawInputList.end(); it++) {
			Config::FileType type = outConf.addInput(*it);
			if (outConf.customMode() && type.known && !(type.runningMode & outConf.mode())) {
				utils::warning("The file '%s' doesn't appear to be compatible with the current running mode.",true,*it);
			}
		}
	}

	catch(const btree::ptree_error &e){
        utils::debug(e.what(),true);
        return OPT_STAT_BAD_ARG;
    }

    return OPT_STAT_OK;

    

}

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out) {
	out   << "Usage: " << execName << " <INPUT_FILES> [<OPTIONS>] [<CONSTANTS>] [<NUM_SOLUTIONS>]" << std::endl
		  << std::endl
		  << "Calls cplus2asp.bin (translator), f2lp (pre-processor), gringo (grounder)," << std::endl
		  << "clasp (solver), and as2transition (post-processor) on the input files" << std::endl
		  << "(CCalc-style files that have been translated to ASP/f2lp syntax), adding " << std::endl
		  << "\"standard\" CCalc to ASP translation support files and outputting the results " << std::endl
		  << "from as2transition." << std::endl
		  << std::endl
		  << "  <INPUT_FILES> --------- A series of files in CCalc, ASP, or f2lp syntax." << std::endl
		  << "                          At least one input file is required." << std::endl
		  << "                          Any input files that have extensions \".f2lp\" or \".lp\"" << std::endl
		  << "                          will automatically not be passed to the translator." << std::endl
		  << std::endl
		  << "  <OPTIONS> ------------- Optional arguments that change the program's behavior." << std::endl
		  << std::endl
		  << "  <CONSTANTS> ----------- Constant definitions that are passed to the grounder." << std::endl
		  << "                          There are three special constants that are often seen in" << std::endl
		  << "                          CCalc programs, and so can be useful to manually set." << std::endl
		  << "                          These are not required to be defined if special \"hint\"" << std::endl
		  << "                          comments are placed in the output from the translator." << std::endl
		  << "                          * maxAdditive - The maximum additive integer (only needed if" << std::endl
		  << "                                          using additive fluents/actions)." << std::endl
		  << "                          * maxstep ----- The maximum time step to consider." << std::endl
		  << "                          * minstep ----- The minimum time step to consider." << std::endl
		  << "                          * query   ----- The query number (i.e., label) to select." << std::endl
		  << std::endl
		  << "  <NUM_SOLUTIONS> ------- The desired number of solutions for the solver to find, or 'all'." << std::endl
		  << "                          This should be a non-negative integer (0 or greater)." << std::endl
		  << "                          If not specified, defaults to 1." << std::endl
		  << std::endl
		  << "Normal Program Options:" << std::endl
		  << "  -auto" << std::endl
		  << "  --automated ----------- Makes the program run in automated mode, so it won't prompt" << std::endl
		  << "                          or ask for any information from the user." << std::endl
		  << std::endl
		  << "  <CONST>=<VALUE>, -c <CONST>=<VALUE>" << std::endl
		  << "  --const <CONST>=<VALUE> Declares a constant & value pair to pass to gringo." << std::endl
		  << "                          You will probably need to at least declare values for" << std::endl
		  << "                          the constants maxstep, query, and possibly maxAdditive." << std::endl
		  << std::endl
		  << "  --help ---------------- Shows this usage message." << std::endl
		  << "  -v" << std::endl
		  << "  --version ------------- Outputs version information." << std::endl
		  << std::endl
		  << "  -m <MODE, -m=<MODE>, --mode <MODE>" << std::endl
		  << "  --mode=<MODE> --------- Sets the program to run in the specified running mode." << std::endl
		  << "                          <MODE> can be one of the following: " << std::endl
		  << "                          * static-auto --- uses a static translation and automatically " << std::endl
		  << "                                            advances the queries maximum time step." << std::endl
		  << "                          * static-manual - uses a static translation and queries the " << std::endl
		  << "                                            user each time a solution isn't found for a " << std::endl
		  << "                                            new time step." << std::endl
		  << "                          * incremental --- [default] uses an incremental translation " << std::endl
		  << "                                            and solver for better efficiency while " << std::endl
		  << "                                            ranging over maxsteps in a query." << std::endl
		  << "                          * reactive ------ uses a incremental translation and reactive " << std::endl
		  << "                                            solver in order to dynamically adding abnormality " << std::endl
		  << "                                            constants during execution."  << std::endl
		  << std::endl
		  << " -q <QUERY>, -q=<QUERY>, --query <QUERY>, query=<QUERY>"  << std::endl
		  << " --query=<QUERY> -------- Sets the query to use from those available in the C+ domain. " << std::endl
		  << "                          <QUERY> should be a positive integer and should be defined in " << std::endl
		  << "                          the domain file." << std::endl
		  << std::endl
		  << " -max <STEP>, -max=<STEP>, --maxstep <STEP>, maxstep=<STEP>" << std::endl
		  << " --maxstep=<STEP> ------- Sets the maximum step to solve for to <STEP>. <STEP> must be a " << std::endl
		  << "                          positive integer or a finite positive range (i.e. '1..5')." << std::endl
		  << "                          A range is seen as shorthand for a combined minimum and maximum " << std::endl
		  << "                          step definition." << std::endl
		  << std::endl
		  << " -min <STEP>, -min=<STEP>, --minstep <STEP>, minstep=<STEP>" << std::endl
		  << " --minstep=<STEP> ------- Sets the minimum step to solve for to <STEP>. <STEP> must be a " << std::endl
		  << "                          positive integer." << std::endl
		  << std::endl
		  << " -nd, --no-domain ------- Suppresses the generation of domain-enforcing rules for each " << std::endl
		  << "                          non-additive constant." << std::endl
		  << std::endl
		  << " -nad, " << std::endl
		  << " --no-additive-domain --- Suppresses the generation of domain-enforcing rules for each " << std::endl
		  << "                          additive constants." << std::endl
		  << std::endl

// TODO: Uncomment this when we have the reactive bridge complete w/ remote program support.
#ifndef NO_REACTIVE_BRIDGE
#if 0
		  << " -p <PORT]" << std::endl
		  << " --port [PORT] ---------- Sets the port used to connect with external client programs instead " << std::endl
		  << "                          of using the console to gather online input. This option is only " << std::endl
		  << "                          valid in reactive mode." << std::endl
#endif
		  << " -i <PORT>, -i=<PORT>, --internal-port <PORT>" << std::endl
		  << " --internal-port=<PORT> - Sets the port used for internal communication between the " << std::endl
		  << "                          reactive solver and bridge. This option is only valid in " << std::endl
		  << "                          reactive mode." << std::endl
#else
		  << " -p <PORT>, -p=<PORT>, --port <PORT>" << std::endl
		  << " --port=<PORT> ---------- Sets the port used to connect with external client programs." << std::endl
#endif
		  << std::endl
		  << " -na[=<VALUE>]" << std::endl
		  << " --none-alias[=<VALUE>]   Indicates that we should simulate 'none' with <VALUE> [default: '" << DEF_NONE_HACK_VAL << "']" << std::endl
		  << "                          This is helpful for circumventing a bug in Gringo 3.0.4 that " << std::endl
		  << "                          sometimes prevents domains from properly grounding due to " << std::endl
		  << "                          unification issues." << std::endl
		  << std::endl
		  << " -s[=<BOOLEAN>]" << std::endl
		  << " --shift[=<BOOLEAN>] ---- Sets whether to allow the solver to shift disjunction in the head of a rule " << std::endl
		  << "                          generated by the pre-processor into the body. This is useful when " << std::endl
		  << "                          the preprocessor generate disjunctive rules and a disjunctive " << std::endl
		  << "                          solver isn't available. May not be guaranteed to preserve stable " << std::endl
		  << "                          models." << std::endl
		  << std::endl
		  << " --stats ---------------- Indicates additional solving statistics should be requested from" << std::endl
		  << "                          the solver and displayed after each solver run." << std::endl
		  << std::endl
		  << " --language=<LANG> ------ Sets the input language that will be accepted for translation/running." << std::endl
		  << "                          <LANG> can be one of the following:" << std::endl
		  << "                          * c+, C+ ---------- [default] The action language C+." << std::endl
 		  << "                          * bc, BC ---------- The action language BC." << std::endl
		  << "                          * bc+, BC+ -------- An experimental extension to language BC." << std::endl
		  << "                          * mvpf, MVPF ------ Multi-valued propositional formulas." << std::endl
		  << std::endl
		  << "Extra Program Options:" << std::endl
		  << "  Options with <PROG> or <PROGRAM> in their name affect individual" << std::endl
		  << "  programs in the tool chain, depending on <PROG> or <PROGRAM>'s value." << std::endl
		  << "  Any option with <PROG> in its name should have <PROG> replaced with one of:" << std::endl
		  << "    gr (grounder), pre (pre-processor), post (post-processor), so (solver)," << std::endl
		  << "    trans (translator), or br (reactive bridge)." << std::endl
		  << "  Replace <PROGRAM> in the applicable options with one of the following:" << std::endl
		  << "    grounder, pre-processor, post-processor, solver, translator, or bridge." << std::endl
		  << std::endl
		  << "  -<PROG> <PATH>, -<PROG>=<PATH>, --<PROGRAM> <PATH> " << std::endl
		  << "  --<PROGRAM>=<PATH> ------ Gives a new path to the desired tool chain program." << std::endl
		  << std::endl
		  << "  -<PROG>opt <OPTS>, -<PROG>opt=<OPTS>, --<PROGRAM>-opts <OPTS>" << std::endl
		  << "  --<PROGRAM>-opts=<OPTS> -- Passes <OPTS> to the given tool chain program." << std::endl
		  << std::endl
		  << "  -<PROG>out <FILE>, -<PROG>out=<FILE>, --<PROGRAM>-output <FILE>" << std::endl
		  << "  --[PROGRAM]-output=<FILE> Write the output of the specified tool to <FILE>." << std::endl
		  << std::endl
		  << "  -from<PROG> " << std::endl
		  << "  --from-<PROGRAM> -------- Starts running the tool chain from the given program." << std::endl
		  << std::endl
		  << "  -just<PROG>" << std::endl
		  << "  --just-<PROGRAM> -------- Removes all but the given program from the tool chain." << std::endl
		  << std::endl
		  << "  -to<PROG>" << std::endl
		  << "  --to-<PROGRAM> ---------- Stops running the tool chain after the given program." << std::endl
		  << std::endl
		  << " -symtab <FILE>, -symtab=<FILE>, --symbol-table=<FILE> " << std::endl
		  << " --symbol-table=<FILE> -- Writes the program's symbol table to <FILE> for use in other programs." << std::endl
		  << std::endl
		  << "  Example: " << execName << " myProgram.cp" << std::endl
		  << "           would translate and process the file \"myProgram.cp\"," << std::endl
		  << "           interactively asking which query from the file to run, returning" << std::endl
		  << "           the first solution found (if any)." << std::endl
		  << "  Example: " << execName << " myProgram.cp query=1 2" << std::endl
		  << "           does the same as above, except it automatically runs Query 1" << std::endl
		  << "           (assuming it can find or derive maxstep), and tries to find two" << std::endl
		  << "           solutions to the query." << std::endl
		  << "  Example: " << execName << " myProgram.cp query=1 maxstep=3 -so cmodels 2" << std::endl
		  << "           would do the same as above, but it changes the solver to cmodels" << std::endl
		  << "           and forces maxstep to be 3." << std::endl
		  << "  Example: " << execName << " myProgram.f2lp --just-pre-processor" << std::endl
		  << "           skips running the translator because the input file has" << std::endl
		  << "           the .f2lp extension, just running f2lp (the pre-processor)" << std::endl
		  << "           on the contents of \"myProgram.f2lp\", outputting the results." << std::endl;
	return out;
}

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out) {
	// Show version information and quit.
	out << execName << " version " << VERSION_MAJOR;
	out << "." << VERSION_MINOR;
	if(VERSION_REV > 0) { out << "." << VERSION_REV; }
	out << std::endl;
	return out;
}




// [interactive] Queries the user to select an appropriate query number (and optional solution count) among the defined queries.
bool queryUserForQuery(Config const& config, Config::RunConfig& runconfig, bool first)
{
	std::string line, value;
	Config::Query const* query;
	Interpreter::Action action;
	bool goodInput = false;
	std::pair<unsigned int, unsigned int> steps;


	if (first) {
		showQueries(config, std::cout);
		std::cout << std::endl;
		Interpreter::showHelp(std::cout);
	}

	while (!goodInput) {

		// Get user input
		goodInput = true;
		query = NULL;

		do {
			std::cout << "$- ";
			std::getline(std::cin,line);

			if (std::cin.eof()) {
				// gracefully handle ctrl-d
				return false;
			}


			// Interpret the command.
			action = Interpreter::interpret(line, value);
			switch (action) {
			case Interpreter::SHOW_QUERIES:
				showQueries(config, std::cout);
				break;
			case Interpreter::SHOW_CONFIG:
				showConfig(config, runconfig, std::cout);
				break;
			case Interpreter::SET_QUERY:

				// Scan through the queries and try to find the one they (hopefully) selected.
				for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries() && !query; it++) {
					if (it->second.cmd == value) {
						query = &(it->second);
					}
				}

				// make sure we got a query...
				if (!query) {
					goodInput = false;
					std::cout << "Invalid query selection.";
				}

				break;

			case Interpreter::SET_NUMSOLN:
				if (value == CONST_DEFAULT) runconfig.numSoln = Config::UNDEFINED;
				else goodInput = utils::from_string(runconfig.numSoln, value);
				break;

			case Interpreter::SET_MAXSTEP:
				if (value == CONST_DEFAULT) runconfig.maxstep = Config::UNDEFINED;
				else {
					steps = Config::parseMaxstep(value);
					if (steps.second == Config::UNDEFINED) goodInput = false;
					else {
						if (steps.first != Config::UNDEFINED) runconfig.minstep = steps.first;
						runconfig.maxstep = steps.second;
	
						if (runconfig.minstep == Config::UNDEFINED) {
							std::cout << "Autosetting minstep to 0." << std::endl;
							runconfig.minstep = 0;
						}
					}
				}

				break;

			case Interpreter::SET_MINSTEP:
				if (value == CONST_DEFAULT) runconfig.minstep = Config::UNDEFINED;
				else goodInput = utils::from_string(runconfig.minstep, value);
				break;
		
	
			case Interpreter::SHOW_HELP:
				Interpreter::showHelp(std::cout);
				break;

			case Interpreter::EXIT:
				// signal the exit.
				return false;
			default:
				// bad input
				goodInput = false;
				break;
			}

		} while ( goodInput && !query );

		if (!goodInput) {
			std::cout << "Error: Invalid choice.\n";
			std::cout << "Type 'help' to list the available commands.\n";
		}
	} while (!goodInput && !query);

	runconfig.query = query->cmd;
	return true;
}

// Displays the queries which have been found.
void showQueries(Config const& config, std::ostream& output) {

	output << "The following queries are available to run:" << std::endl << std::endl;


	for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries(); it++) {
		output << '\t' << std::setw(15) << std::right << it->second.cmd << ": " << std::setw(20) << std::left << it->second.name;

		if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED)
				|| (!config.customConfigOpt(Config::OPT_MAXSTEP) && it->second.maxstep != Config::UNDEFINED) ) {
			output << " [ ";
	
			if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED)) {
				output << it->second.minstep;
			} else {
				output << "0";
			}


			if (it->second.maxstep == Config::UNDEFINED)
				output << "...";
			else if ((it->second.minstep == Config::UNDEFINED && it->second.maxstep != 0)
					|| it->second.minstep != it->second.maxstep)
				output << ".." << it->second.maxstep;

			output << " ]";
		}
		output << std::endl;
	}

}

// Displays the current run-time configuration for the system.
void showConfig(Config const& config, Config::RunConfig const& runconfig, std::ostream& output) {
	unsigned int tmp, tmp2;

	// TODO: This REALLY needs to be cleaned up.

	output << "Current configuration:\n\n";

	// translation mode
	output << "\t\t" << std::setw(30) << std::left << "Translation Mode:";

	output << std::setw(20) << std::left;
	switch (config.mode()) {
	case Config::MODE_INCREMENTAL:
		output << "Incremental";
		break;

	case Config::MODE_REACTIVE:
		output << "Reactive";
		break;

	case Config::MODE_STATIC_AUTO:
		output << "Static (auto)";
		break;

	case Config::MODE_STATIC_MANUAL:
		output << "Static (manual)";
		break;
	default:
		output << "Unknown";
		break;
	}
 	output << std::endl;

	// number of solutions
	tmp2 = (config.intConfigOpt(Config::OPT_NUM_SOLN) != Config::UNDEFINED) ? config.intConfigOpt(Config::OPT_NUM_SOLN) : 1;
	tmp = (runconfig.numSoln != Config::UNDEFINED) ? runconfig.numSoln : tmp2;

	output << "\t\t" << std::setw(30) << std::left << "Number of solutions:";

	output << std::setw(20) << std::left;
	if (tmp) output << tmp;
	else output << "all";

	output << "[default: ";
 	if (tmp2) output << tmp2;
	else output << "all";
	output << " ]\n";

	// maximum soln step
	tmp2 = config.intConfigOpt(Config::OPT_MAXSTEP);
	tmp = (runconfig.maxstep != Config::UNDEFINED) ? runconfig.maxstep : tmp2;

	output << "\t\t" << std::setw(30) << std::left << "Maximum solution step:";
	
	output << std::setw(20) << std::left;
	if (tmp == Config::INF) output << CONST_MAXSTEP_INFINITE;
	else if (tmp != Config::UNDEFINED) output << tmp;
	else output << "query selected";
	
	output << "[default: ";
	if (tmp2 == Config::INF) output << CONST_MAXSTEP_INFINITE;
	else if (tmp2 != Config::UNDEFINED) output << tmp2;
	else output << "query selected";
	output << " ]\n";


	// minimum soln step	
	tmp2 = config.intConfigOpt(Config::OPT_MINSTEP);
	tmp = (runconfig.minstep != Config::UNDEFINED) ? runconfig.minstep : tmp2;
	
	output << "\t\t" << std::setw(30) << std::left << "Minimum solution step:";
	
	output << std::setw(20) << std::left;
	if (tmp != Config::UNDEFINED) output << tmp;
	else output << "query selected";
	
	output << "[default: ";
	if (tmp2 != Config::UNDEFINED) output << tmp2;
	else output << "query selected";
	output << " ]\n";
	 
}

// Asks the user to select a max step.
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defVal) {
	unsigned int ret = Config::UNDEFINED;
	std::string line;
	bool goodInput = false;

	while (!goodInput) {

		// Prompt user input
		std::cout << "Please select a (non-negative) value for the " << constant << ". You may input 'exit' to exit the program." << std::endl;
		std::cout << "Selected value";
		if (defVal != Config::UNDEFINED) std::cout << " [" << defVal << "]";
		std::cout << ": ";



		std::getline(std::cin,line);
		line = utils::trimWhitespace(line);

		// Make sure they don't want to exit.
		if (line == EXIT_CMD) {
			// crap, they do. returning UNDEFINED will indicate this.
			goodInput = true;
			ret = Config::UNDEFINED;
		}
		// Check if they want to go for a default value
		else if (defVal != Config::UNDEFINED && line == "") {
			ret = defVal;
			goodInput = true;
		}
		// Check if they have provided any other valid input...
		else if (utils::from_string(ret, line)) {
			goodInput = true;
		}

		if (!goodInput) {
			std::cout << "Error: Invalid selection." << std::endl;
		}

	}

	return ret;
}

int runTool(Config const& config, Config::Toolchain tool, std::string const& name, Config::RunConfig const* subconfig) {
	
	int ret = TC_STAT_TOOLSKIPPED;
	
	if (!config.run(tool)) {
		utils::debug("Skipping %s execution.", true, name.c_str());
	} 
	else if (!config.cumulativeInputCount(tool) && tool != Config::TC_REACTIVE_BRIDGE) {
		utils::pragma("No input files for the %s have been specified. Skipping it.", true, name.c_str());
	} 
	else {
	// Run the translator...
	//		std::string tmpCmd = config.compileCommandLine(tool, subconfig);
		std::list<std::string> arglist;
		config.compileArgs(tool, arglist, subconfig);

		std::vector<std::string> tempVec (arglist.size());
		int i = 0;
		for (std::list<std::string>::iterator it=arglist.begin(); it != arglist.end(); ++it)
    		tempVec.at(i++) = *it;

		utils::debug("Running the '%s' (program: '%s') with command: '%s'",true,name.c_str(), config.command(tool).c_str(), config.compileCommandLine(tool, subconfig).c_str());


		bp::context ctx;
		ctx.environment = bp::self::get_environment();
		if (tool == Config::TC_REACTIVE_BRIDGE) {
			ctx.stdin_behavior  = bp::inherit_stream();
			ctx.stdout_behavior = bp::inherit_stream();
			ctx.stderr_behavior = bp::inherit_stream();
		} 
		else if (config.mode() != Config::MODE_REACTIVE || tool != Config::TC_SOLVER) {
			ctx.stdin_behavior  = bp::close_stream();
			ctx.stdout_behavior = bp::capture_stream();
			ctx.stderr_behavior = bp::capture_stream();
		}
		else {
			ctx.stdin_behavior  = bp::inherit_stream();
			ctx.stdout_behavior = bp::silence_stream();
			ctx.stderr_behavior = bp::inherit_stream();

		}
		
		
		bp::child c = bp::launch(bp::find_executable_in_path(config.command(tool)), arglist, ctx);

		if (tool == Config::TC_REACTIVE_BRIDGE) {
			bp::status s = c.wait();
			if (s.exited()) ret = s.exit_status();
			else ret = TC_STAT_EXEC_ERR;
		} 
		else if (config.mode() != Config::MODE_REACTIVE || tool != Config::TC_SOLVER) {
			
			std::ofstream outstream(config.output(tool));
			std::ofstream errstream(config.errFile());



			if (!outstream.good()) {
				if (config.customOut(tool))
					utils::error("Unable to open '%s' for writing.", true, 0, config.output(tool).c_str());
				else
					utils::error("Unable to open temporary file '%s' for writing.", true, 0, config.output(tool).c_str());
				return TC_STAT_IO_ERR;
			}


			if (!errstream.good()) {
				utils::error("Unable to open temporary file '%s' for writing.", true, 0, config.errFile().c_str());
				return TC_STAT_IO_ERR;
			}


			// write out data
			copy(std::istreambuf_iterator<char>(c.get_stdout()), std::istreambuf_iterator<char>(),
				std::ostreambuf_iterator<char>(outstream));
			copy(std::istreambuf_iterator<char>(c.get_stderr()), std::istreambuf_iterator<char>(),
				std::ostreambuf_iterator<char>(errstream));

			bp::status s = c.wait();
			if (s.exited()) ret = s.exit_status();
			else ret = TC_STAT_EXEC_ERR;


	/*					try {
					int tmp = bp::wait_for_exit(c);
					ret = BOOST_PROCESS_EXITSTATUS(tmp);
				} catch (boost::system::system_error& e) {
					utils::debug("Caught exception '%s'.", true, e.what());
					ret = TC_STAT_EXEC_ERR;
				} */

			outstream.close();
			errstream.close();


		} 
		else 
			ret = TC_STAT_BG;
}


// TODO: Do I need to close the sink?



utils::debug("Command exited with status '%d'.", true, ret);

if (!processErrors(config, tool, config.errFile())) {
	utils::warning("Could not read from the error stream file.", true);
}

//		int stat = system(tmpCmd.c_str());
//		ret = WEXITSTATUS(stat);

	return ret;
}

/**
 * @brief Processes the provided error file applying any error filters and printing the rest.
 * @param config The system configuration.
 * @param tool The tool that generated the error file.
 * @param file The error file.
 * @return True if the file exists and was successfully opened, false otherwise.
 */
bool processErrors(Config const& config, Config::Toolchain tool, std::string const& file) {
	std::ifstream in(file.c_str());
	std::string line;
	bool show, unificationError = false;

	if (in.fail()) {
		return false;
	}

	while (std::getline(in, line)) {
		show = true;

		switch (tool) {
		case Config::TC_TRANSLATOR:
			
			break;
		case Config::TC_PREPROC:

			break;
		// case Config::TC_GROUNDER:

		// 	break;
		case Config::TC_SOLVER:

			// Filter the usual warnings.
			if (line.find("never defined") != std::string::npos) {
				if (
					line.find("constant_sort/2") != std::string::npos
					|| line.find("rigid/1") != std::string::npos
					|| line.find("inertialFluent/1") != std::string::npos
					|| line.find("abFluent/1") != std::string::npos
					|| line.find("exogenousAction/1") != std::string::npos
					|| line.find("abAction/1") != std::string::npos
					|| line.find("attribute/1") != std::string::npos
					|| line.find("additiveAction/1") != std::string::npos
					|| line.find("staticAbnormality/1") != std::string::npos
					|| line.find("dynamicAbnormality/1") != std::string::npos
					|| line.find("action_attribute/2") != std::string::npos
					|| line.find("staticAbnormality/1") != std::string::npos
					|| line.find("noconcurrency/0") != std::string::npos
					|| line.find("strong_noconcurrency/0") != std::string::npos
					|| line.find("false/0") != std::string::npos
					|| line.find("computed/1") != std::string::npos
					)
					show = false;
			}
			else if (line.find("convert") != std::string::npos
					&& line.find("none") != std::string::npos) {
				unificationError = true;

			}

			break;
		case Config::TC_POSTPROC:

			break;
		case Config::TC_REACTIVE_BRIDGE:

			break;
		default:
			break;
		}

		if (show) std::cerr << line << std::endl;
	}

	if (unificationError) {
		utils::error("Detected an error that appears to be caused by a bug in Gringo 3.0.5 which prevents", true, 0);
		utils::error("  certain programs from being grounded properly. Adding '--none-alias[=VALUE]' to", true, 0);
		utils::error("  the command-line arguments may fix this problem.", true, 0); 
	}

	in.close();

	return true;
}


#ifdef DEBUG

void cleanup(Config config, bool const* ran, bfs::path selfpath){
	utils::debug("Deleting appropriate temporary files.", true);
	
	if (config.boolConfigOpt(Config::OPT_DISCARD_F2LP)) {
		// Discard F2LP intermediates...
		if (ran[Config::TC_PREPROC]) {
			bfs::copy_file(F2LP_INPUT_FILE,selfpath.remove_filename().string() + "F2LP_INPUT_FILE",bfs::copy_option::overwrite_if_exists);
			bfs::copy_file(F2LP_OUTPUT_FILE,selfpath.remove_filename().string() + "F2LP_OUTPUT_FILE",bfs::copy_option::overwrite_if_exists);
			bfs::remove(F2LP_INPUT_FILE);
			bfs::remove(F2LP_OUTPUT_FILE);
		}
	}

	bfs::remove(config.errFile());

	for (int i = 0; i < (int)Config::_TC_LENGTH_; i++) {
		if (!config.customOut((Config::Toolchain)i)) {
			utils::debug("Deleting '%s'.", true, config.output((Config::Toolchain)i).c_str());
			try{
				bfs::copy_file(config.output((Config::Toolchain)i),selfpath.remove_filename().string() + config.getTextForEnum(i) + std::to_string(i),bfs::copy_option::overwrite_if_exists);
			}
			catch(const bfs::filesystem_error& ex){
				std::cout<<ex.what()<<'\n';
			}
			bfs::remove(config.output((Config::Toolchain)i));	
		}
	}
}


#else

void cleanup(Config const& config, bool const* ran) {
	utils::debug("Deleting appropriate temporary files.", true);

	if (config.boolConfigOpt(Config::OPT_DISCARD_F2LP)) {
		// Discard F2LP intermediates...
		if (ran[Config::TC_PREPROC]) {
			bfs::remove(F2LP_INPUT_FILE);
			bfs::remove(F2LP_OUTPUT_FILE);
		}
	}

	bfs::remove(config.errFile());

	for (int i = 0; i < (int)Config::_TC_LENGTH_; i++) {
		if (!config.customOut((Config::Toolchain)i)) {
			utils::debug("Deleting '%s'.", true, config.output((Config::Toolchain)i).c_str());
			bfs::remove(config.output((Config::Toolchain)i));	
		}
	}
}

#endif



// Attempts to echo the specified file to the specified output stream.
bool echoFile(std::ostream& out, std::string const& filename) {
	std::ifstream file(filename.c_str());
	char buf[4096];

	if (file.fail()) {
		return false;
	}

	while (!file.eof()) {
		file.read(buf, 4096);
		out.write(buf, file.gcount());
	}

	return true;
}

// Attempts to echo the solver stats from the specified file.
bool echoStats(std::ostream& out, std::string const& filename) {
	std::string tmp;
	bool found = false;
	

	std::ifstream file(filename.c_str());

	if (file.fail()) {
		return false;
	}

	while (std::getline(file, tmp)) {
		if (!strncmp("Models", tmp.c_str(), strlen("Models"))) {
			found = true;
			break;
		}
	}

	if (!found) return false;
	do {
		out << tmp << std::endl;
	} while (std::getline(file, tmp));

	return true;
}

