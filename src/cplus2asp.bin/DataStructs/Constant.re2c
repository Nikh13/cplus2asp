/* 
 * Copyright (c) 2010-2013 <Joseph Babb, Michael Cassollary, Joohyung Lee>
 *
 * For information on how to contact the authors, please visit
 *	http://reasoning.eas.asu.edu/cplus2asp
 *
 * This file is part of the cplus2asp system.
 *
 * cplus2asp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * cplus2asp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/* Generated by re2c 0.13.5 on Fri Feb  1 20:07:26 2013 */
#line 1 "DataStructs/Constant.re2c"

#include "Attribute.h"
#include "Element.h"
#include "Variable.h"
#include "Sort.h"
#include "utilities.h"
#include "Translator.h"
#include "ElementCounter.h"
#include "Constant.h"
#include "Context.h"

// Full constructor.
Constant::Constant(std::string const& name, Sort const* domain, ConstantType type, ConstSortList const* params)
	: Element(name, Translator::sanitizeConstantName(name), Element::ELEM_CONST)
{
	mConstType = type;
	mDomain = domain;

	if (params) mParams = *params;

	mFullName = baseName();
	if(!mParams.empty())
	{
		mFullName += "(";
		mFullName += utils::elementVectorToFullNameString<Sort const*>(mParams);
		mFullName += ")";
	}

	mFullTransName = baseTransName();
	if(!mParams.empty())
	{
		mFullTransName += "(";
		mFullTransName += utils::elementVectorToFullTransNameString<Sort const*>(mParams);
		mFullTransName += ")";
	}
}

Constant::Constant(std::string const& name, ConstantType type, ConstSortList const* params)
	: Element(name, Translator::sanitizeConstantName(name), Element::ELEM_CONST)
{
	mConstType = type;
	mDomain = NULL;

	if (params) mParams = *params;

	mFullName = baseName();
	if(!mParams.empty())
	{
		mFullName += "(";
		mFullName += utils::elementVectorToFullNameString<Sort const*>(mParams);
		mFullName += ")";
	}

	mFullTransName = baseTransName();
	if(!mParams.empty())
	{
		mFullTransName += "(";
		mFullTransName += utils::elementVectorToFullTransNameString<Sort const*>(mParams);
		mFullTransName += ")";
	}
}

bool Constant::isNumeric() const {
	return domain() && domain()->isNumeric();
}

bool Constant::isBoolean() const {
	return domain() && domain()->isBoolean();
}

bool Constant::isStarred() const {
	return domain() && domain()->isStarred();
}

// Standard toString function.
std::string Constant::toString() const
{
	std::string tempStr;
	tempStr += "[Constant]";
	tempStr += "\n  params = (";
	if(!mParams.empty())
	{
		tempStr += utils::elementVectorToFullNameString<Sort const*>(mParams, ", ", true);
	}
	tempStr += ")";
	tempStr += "\n  domain = ";
	if(!mDomain)
	{
		tempStr += "NULL";
	}
	else
	{
		tempStr += "\"";
		tempStr += mDomain->fullName();
		tempStr += "\"";
	}
	tempStr += "\n  constType = ";

	// Print out the English version of the possible enum values of constType.
	tempStr += Constant::constTypeToString(mConstType);
	return tempStr;
}

// Generates a string representation of a Constant's type.
std::string Constant::constTypeToString(ConstantType _constType)
{
	// Print out the English version of the possible enum values of constType.
	switch (_constType)
	{
	case CONST_ACTION:
		return "action";
	case CONST_ABACTION:
		return "abAction";
	case CONST_ABFLUENT:
		return "abFluent";
	case CONST_ATTRIBUTE:
		return "attribute";
	case CONST_EXOGENOUSACTION:
		return "exogenousAction";
	case CONST_INERTIALFLUENT:
		return "inertialFluent";
	case CONST_RIGID:
		return "rigid";
	case CONST_SDFLUENT:
		return "sdFluent";
	case CONST_SIMPLEFLUENT:
		return "simpleFluent";
	case CONST_ADDITIVEACTION:
		return "additiveAction";
	case CONST_ADDITIVEFLUENT:
		return "additiveFluent";
	case CONST_STATICAB:
		return "staticAbnormality";
	case CONST_DYNAMICAB:
		return "dynamicAbnormality";
	default:
		// Unknown or unrecognized constant type.
		return "UNKNOWN";
	}
}

enum Constant::ConstantType Constant::stringToConstType(char const* _constType) {
	char const* marker;
	/*!re2c
		re2c:define:YYCTYPE = "char";
		re2c:define:YYCURSOR = _constType;
		re2c:yyfill:enable = 0;
		re2c:define:YYMARKER = marker;
		re2c:indent:top = 1;

		"action"				{ return CONST_ACTION; }
		"abAction"				{ return CONST_ABACTION; }
		"attribute"				{ return CONST_ATTRIBUTE; }
		"exogenousAction"		{ return CONST_EXOGENOUSACTION; }
		"inertialFluent"		{ return CONST_INERTIALFLUENT; }
		"rigid"					{ return CONST_RIGID; }
		"sdFluent"				{ return CONST_SDFLUENT; }
		"simpleFluent"			{ return CONST_SIMPLEFLUENT; }
		"additiveAction"		{ return CONST_ADDITIVEACTION; }
		"additiveFluent"		{ return CONST_ADDITIVEFLUENT; }
		"staticAbnormality"		{ return CONST_STATICAB; }
		"dynamicAbnormality"	{ return CONST_DYNAMICAB; }
		.						{ return CONST_UNKNOWN; }
	*/
}

// Checks if the type is an action constant.
bool Constant::isActionType(ConstantType _constType)
{
	switch (_constType)
	{
	case CONST_ACTION:
	case CONST_ABACTION:
	case CONST_ATTRIBUTE:
	case CONST_EXOGENOUSACTION:
	case CONST_ADDITIVEACTION:
		return true;
	default:
		return false;
	}
}

// Checks if the type is an abnormality constant.
bool Constant::isAbnormalityType(ConstantType _constType)
{
	switch (_constType)
	{
	case CONST_STATICAB:
	case CONST_DYNAMICAB:
		return true;
	default:
		return false;
	}
}
// Checks if the type is a fluent constant.
bool Constant::isFluentType(ConstantType _constType, bool includeRigid)
{
	switch (_constType)
	{
	case CONST_INERTIALFLUENT:
	case CONST_SDFLUENT:
	case CONST_SIMPLEFLUENT:
	case CONST_ADDITIVEFLUENT:
	case CONST_ABFLUENT:
		return true;
	case CONST_RIGID:
		return includeRigid;
	default:
		return false;
	}
}

// Checks if the type is a fluent constant.
bool Constant::isAdditiveType(ConstantType _constType)
{
	switch (_constType)
	{
	case CONST_ADDITIVEACTION:
	case CONST_ADDITIVEFLUENT:
		return true;
	default:
		return false;
	}
}

// Generates a prefix used to wrap the atom's name in.
std::string Constant::translatePrefix(ConstantType constType)
{
	switch (constType) {
	case CONST_ACTION:
	case CONST_ABACTION:
	case CONST_ATTRIBUTE:
	case CONST_EXOGENOUSACTION:
	case CONST_ADDITIVEACTION:
		return "occ(eql(";
	case CONST_STATICAB:
		return "ab_h(";
	case CONST_DYNAMICAB:
		return "ab_occ(";
	case CONST_INERTIALFLUENT:
	case CONST_RIGID:
	case CONST_SDFLUENT:
	case CONST_SIMPLEFLUENT:
	case CONST_ABFLUENT:
	case CONST_ADDITIVEFLUENT:
	default:
		return "h(eql(";
	}
}

// Generates a postfix used to wrap the atom's name in.
std::string Constant::translatePostfix(ConstantType constType, Context const& context) {
	std::stringstream out;
	if (Constant::isAbnormalityType(constType)) {
		return ", " + context.getTimestamp() + ")";
	} else {
		out << ", "
		// make sure we handle the case where the context is blind to this being an atom.
		// Default the value to "true".
			<< context.getValue()
			<< ")"
			<< ((constType == Constant::CONST_RIGID) ? "" : ", " + context.getTimestamp())
			<< ")";

		return out.str();
	}
}

bool Constant::translate(
		std::ostream& out,
		ClauseList& outClauses,
		ElementCounter* runningCount,
		std::vector<std::pair<Sort const*, std::string> >* matchMap,
		std::vector<std::pair<Sort const*, std::string> >* outMap) const {

	bool matchingMap = (bool)matchMap;							// Whether we are currently matching the mapped arguments.
	size_t count;												// The number of times this sort has appeared to date.
	std::string newVar;											// The name of the new variable to add.
	if (!runningCount) runningCount = new ElementCounter();

	// Translate the name...
	out << baseTransName();

	// Transform any parameters into sort variables.
	if(arity())
	{
		out << "(";

		// Use an occurrence counter to get guaranteed unique variable
		// names representing the sorts that comprise the parameters
		// of this constant.
		for(size_t i = 0; i < arity(); i++)
		{
			// check the argument against the known parameter list
			// Pragma: I'm fully aware that this does pointer-wise comparison.
			if (matchingMap && i < matchMap->size() && param(i) == matchMap->at(i).first) {
				// Everything (including this argument) has matched so far.
				// Keep using the mapped variables.
				if (i > 0) out << ", ";
				out << matchMap->at(i).second;
				if (outMap) outMap->push_back(std::pair<Sort const*, std::string>(param(i), matchMap->at(i).second));
			} else {
				// nope! Stop trying.
				matchingMap = false;

				newVar = param(i)->varTransName();
				// Generate our own variable to use.
				count = runningCount->add(param(i));
				if (count > 1) {
					newVar += "_" + utils::to_string(count);
				}

				// Add and register the new variable.
				if (i > 0) out << ", ";
				out << newVar;
				if (outMap) outMap->push_back(std::pair<Sort const*, std::string>(param(i), newVar));

				// Add the appropriate clause...
				if (count > 1) {
					outClauses.push_back(param(i)->fullTransName() + "(" + newVar + ")");
				}
			}
		}

		out << ")";
	}

	return !matchMap || matchingMap;
}

// Determines if the constant appears to be the contribution constant.
bool Constant::isContribConstant() const {
	return arity() == 2 && constType() == CONST_ACTION && baseName() == "contribution" && domain() && domain()->isNumeric();
}


// Gets the names associated with each parameter.
void Constant::getParamFullNames(NameList& out) const	{
	utils::elementVectorToFullNameVector<Sort const*>(mParams, out);
}

// Copies this constant as an attribute
Attribute* Constant::makeAttribute(Constant const* parent) const {
	return new Attribute(baseName(), domain(), parent, &mParams);

}
