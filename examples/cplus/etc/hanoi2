% File: 3-towers-of-hanoi

:- macros
  N -> 3.

:- sorts
  peg;
  disk;
  integer >> posInteger.

:- objects
  1..N            :: posInteger;
  0               :: integer;
  p(posInteger)   :: peg;
  d(posInteger)   :: disk.

:- variables
  P,P1            :: posInteger;
  Pi,Pj           :: peg;
  DS,DS1          :: disk*;
  D,D1            :: disk;
  S,S1            :: 0..N.

:- constants
  top(peg)        :: inertialFluent(disk*);
  loc(disk)       :: inertialFluent(disk*);
  size(disk*)     :: inertialFluent(0..N);
  move(peg,peg)   :: exogenousAction.


constraint loc(D)=DS ->> size(D)<size(DS).

nonexecutable move(p(P),p(P1)) if top(p(P))=none.


% effects

% top(Pi) := loc(top(Pi))    
move(Pi,Pj) causes top(Pi)=DS if top(Pi)=D & loc(D)=DS.

% loc(top(Pi)) := top(Pj)    
move(Pi,Pj) causes loc(D)=DS if top(Pi)=D & top(Pj)=DS.

% top(Pj) := top(Pi)         
move(Pi,Pj) causes top(Pj)=D if top(Pi)=D.

noconcurrency.

:- query
maxstep :: 7;
0: size(none)=3, size(d(1))=2, size(d(2))=1, size(d(3))=0,
   loc(d(1))=none,  loc(d(2))=d(1),  loc(d(3))=d(2),
   top(p(1))=d(3), top(p(2))=none, top(p(3))=none;
maxstep:
   loc(d(1))=none, loc(d(2))=d(1), loc(d(3))=d(2), top(p(3))=d(3).

:- query
maxstep :: 1;
label :: 1;
0: size(none)=3, size(d(1))=2, size(d(2))=1, size(d(3))=0,
   loc(d(1))=none,  loc(d(2))=d(1),  loc(d(3))=d(2),
   top(p(1))=d(3), top(p(2))=none, top(p(3))=none;
0: move(p(3),p(1)).


