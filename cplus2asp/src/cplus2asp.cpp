/* Generated by re2c 0.13.5 on Thu Jan 31 10:55:32 2013 */
#line 1 "cplus2asp.re2c"
/** @file cplus2asp.cpp
 *  @brief Calls a tool chain of a translator, pre-processor, answer set solver, and post-processor on a CCalc program translated to ASP syntax.
 *  @author v3.0+ Joseph Babb (v2.3- Michael Casolary)
 *  @date 07/2011
 */

/* History:
 * v3.0 - Restructured options parser. Added incremental translation functionality. Added automated detection and handling of additive/abnormal constants.
 * v2.3 - Implemented "-from[PROG]" and "-to[PROG]" options to give better control over running a partial tool chain.
 * v2.2.2 - Fixed bugs, "-notrans" wasn't shutting off the translator, "-gropt" and "-grsoopt" were mixed up. Set up system to track when tool chain programs have errors.
 * v2.2.1 - Fixed bug where program might get wrong values back from system calls (depending on OS).
 * v2.2 - cplus2asp now supports integrated grounder-solvers (like clingo), using the option -grso / --grounder-solver. Added automatic searching though queries with ranged maxsteps, with an option to switch to manual mode (-mm). Removed support for using piped tool chain commands. Added automated "non-interactive" mode option (-auto).
 * v2.1.2 - Tweaked status outputs to be compatible with benchmarking scripts, adjusted output messages to make more sense.
 * v2.1.1 - Renamed to cplus2asp, also renamed translator & standard file dependencies.
 * v2.1 - Skips translating any files with .f2lp or .lp extensions, not just if all files have those extensions.
 * v2.0.1 - Made file name output more friendly, ensured all steps of the tool chain work together properly.
 * v2.0 - Added ccalc2asp.bin (translator) to tool chain, including options to control its usage, and an ability to interactively guess critical constant values based on hints given in comments in the input files.
 * v1.3.5 - Fixed bug with post-processor not receiving options correctly.
 * v1.3.4 - Now passes input file to solver via standard in redirection.
 * v1.3.3 - Added option to use pipes instead of intermediate files to send data between tool chain programs (i.e., pre-v1.3 behavior).
 * v1.3.2 - Sends input files to the first tool in the tool chain that isn't disabled.
 * v1.3.1 - Fixed bug with spaces in path causing odd behavior and errors from tool chain.
 * v1.3 - Changed default post-processor to as2transition, changed default standard files to ccalc2asp_std.f2lp & ccalc2asp_additive.f2lp, changed argument handler to allow generic "const=value" arguments without needing "-c" before them, added intermediate file usage and auto-deletion, added options to pass command-line options directly to any of the tool chain programs.
 * v1.2 - Added option to un-include the standard translation files from the call to the pre-processor.
 * v1.1 - Added options to turn off programs in the tool chain.
 * v1.0 - First working version.
 */

#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <list>
#include <climits> // for PATH_MAX, INT_MIN
#include <cstring>
#include <sys/types.h>
#include <unistd.h> // for realpath()
#include <errno.h>
#include <string.h>
#include <sys/wait.h>
#include <cstdlib>

#include "Config.h"
#include "utils.h"

using namespace std;

#define VERSION_MAJOR 3
#define VERSION_MINOR 0
#define VERSION_REV 0

#ifndef PATH_MAX
  #define PATH_MAX 4096
#endif

/// An enum of the various command line options available.
enum Option {
	OPT_AUTO,
	OPT_BRIDGE,
	OPT_BRIDGE_OPTS,
	OPT_CONST,
	OPT_FRM_BRIDGE,
	OPT_FRM_GRD,
	OPT_FRM_PRE,
	OPT_FRM_POST,
	OPT_FROM_SO,
	OPT_FROM_TRAN,
	OPT_GRD,
	OPT_GRD_OPTS,
	OPT_JUST_GRD,
	OPT_JUST_PRE,
	OPT_JUST_POST,
	OPT_JUST_SO,
	OPT_JUST_TRANS,
	OPT_MODE_SELECT,
	OPT_MODE_STATIC_AUTO,
	OPT_MODE_STATIC_MANUAL,
	OPT_MODE_INCREMENTAL,
	OPT_MODE_REACTIVE,
	OPT_NO_DEL,
	OPT_NO_STD,
	OPT_POSTPROC,
	OPT_POSTPROC_OPTS,
	OPT_PREPROC,
	OPT_PREPROC_OPTS,
	OPT_SO,
	OPT_SO_OPTS,
	OPT_TO_BRIDGE,
	OPT_TO_GRD,
	OPT_TO_PRE,
	OPT_TO_POST,
	OPT_TO_SO,
	OPT_TO_TRANS,
	OPT_TRANS,
	OPT_TRANS_OPTS,
	OPT_VERSION,
	OPT_HELP,
	OPT_UNSUPPORTED,
	OPT_UNSUPPORTED_ADDITIVE,
	OPT_UNSUPPORTED_GRSO,
	OPT_UNSUPPORTED_MANUAL_MAXSTEP,
	OPT_UNKNOWN
};

/// Return codes from known tool chain programs indicating their final status.
enum StatusFlags
{
	TC_STAT_OK = 0,												///< Universal OK.
	TC_STAT_BG = 130,											///< Exit code indicating that the task is running in the background.
	TC_STAT_TOOLSKIPPED = INT_MIN,								///< Psuedo return code indicating that the tool execution was skipped for some reason.
	TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK = 0x80,			///< Bitmask to determine if cplus2asp detected abnormalities.
	TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK = 0x40,				///< Bitmask to determine if cplus2asp detected additive fluents.
	TC_STAT_SO_CLINGO_FOUND_SOLUTIONS = 10,						///< return code indicating that clingo (or other similar programs) found solutions.
	TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS = 101		///< return code indicating that as2transition found solutions.
};

/// Status flags that can be returned by the options parser.
enum OptionStatus
{
	OPT_STAT_OK,			///< Everything is ok, continue execution.
	OPT_STAT_BAD_ARG,		///< One or more bad arguments was found. Stop execution.
	OPT_STAT_HELP,			///< The user requested the help message be displayed.
	OPT_STAT_VERSION		///< The user requested the version message be displayed.
};

/// Mode selection constants (for argument parsing)
#define ARG_MODE_STATIC_MANUAL  "static-manual"
#define ARG_MODE_STATIC_AUTO 	"static-auto"
#define ARG_MODE_INCREMENTAL	"incremental"
#define ARG_MODE_REACTIVE		"reactive"

/// Flags used to efficiently indicate that we're missing a constant.
#define CONST_MAXSTEP_MASK 		0x80
#define CONST_QUERY_MASK 		0x40
#define CONST_MAXADDITIVE_MASK  0x20
#define CONST_MINSTEP_MASK		0x10
#define CONST_EXT_PORT_MASK		0x08

/// The command used to exit the program during interactive prompts.
#define EXIT_CMD				"exit"

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt);

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out);

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to write the dialog to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out);

/**
 * Parses the provided command line arguments and sets the configurations appropriately.
 * @param argc The number of command line arguments provided to the program.
 * @param argv The command line arguments provided to the program.
 * @param[out] outConf The configurations object to write to.
 * @return A status flag indicating the results of the parsing.
 */
OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf);

/**
 * [interactive] Queries the user to select an appropriate query number among the defined queries.
 * @param config The program's configuration options.
 * @return The selected query's ID or Config::UNDEFINED to indicate that the user wishes to exit the program.
 */
unsigned int queryUserForQuery(Config const& config);

/**
 * [interactive] Queries the user to select a value for the specified constant.
 * @param config The program's configuration options.
 * @param constant The constant's name to ask for.
 * @param defval The default value of the constant (Config::UNDEFINED for no default).
 * @return The selected value or Config::UNDEFINED to indicate the user wishes to exit the program.
 */
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defval = Config::UNDEFINED);

/**
 * Scans through all of the available input files in order to attempt to find the required constants.
 * @param config The configuration for the program. The list of queries in the configuration may be added to.
 * @param ranTranslator Whether the translator was ran.
 * @param neededConstants A set of flags indicating the constants that are required.
 * @return A new set of flags indicating the constants that are still required.
 */
 unsigned char scanFilesForConstants(Config& config, bool ranTranslator, unsigned char neededConstants);

 /**
  * Scans through a provided input files in order to attempt to find the required constants.
  * @param config The configuration for the program. The list of queries in the configuration may be added to.
  * @param file The name of the file to scan.
  * @param neededConstants A set of flags indicating the constants that are required.
  * @return A new set of flags indicating the constants that are still required.
  */
  unsigned char scanForConstants(Config& config, std::string const& file, unsigned char neededConstants);

/**
 * Runs the specified tool in the toolchain IF it is not disabled in the toolchain configuration.
 * @param config The configuration for the program.
 * @param tool The tool to run.
 * @param maxstep The maxstep to use during compilation
 * @param name The human readable name of the tool (for output purposes).
 * @return The status code from running the program (TC_STAT_TOOLSKIPPED indicates that it did not run).
 */
int runTool(Config const& config, Config::Toolchain tool, unsigned int maxstep, std::string const& name);

/**
 * Cleans up the intermediate files generated during program execution.
 * @param config The program's configuration.
 * @param ran An array of booleans of length Config::TC_LENGTH detailing which components have ran.
 */
void cleanup(Config const& config, bool const* ran);


int main(int argc, char** argv)
{

	string strEXEName = argv[0]; 						// Name of this executable.
	string tmpCmd;				 						// temporary command string.

	vector<string> vecConstants; 						// List of constants to pass to the grounder.
	int intSystemResult = 0; 							// Holds what comes back from system().
	
	unsigned int intCurMaxstep = Config::UNDEFINED; 	// Used when maxstep is a range.
	Config::Query const* activeQuery = NULL;			// The query which we are currently executing.
	

	Config config;										// The almighty system configuration.

	bool ran[Config::TC_LENGTH];						// Variable used to track which toolchain components we have ran so far.
	memset(ran, 0, Config::TC_LENGTH);


	bool blnFoundSolutions = false; 					// Set to true if the solver or post-processor indicates solutions were found.


	/***************************************************************************************************/
	/* Command Line Parsing */
	/***************************************************************************************************/
	
	// Process command-line arguments.
	debug("Parsing Options...", true);
	switch (parseCommandOptions(argc, argv, config)) {
	case OPT_STAT_OK:
		// We're good to go!
		break;
	case OPT_STAT_BAD_ARG:
		error("A problem occurred parsing program arguments. Exiting.", true, 0);
		showHelp(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_BAD_ARGS,NULL);
		break;
	case OPT_STAT_HELP:
		showHelp(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_GOOD,NULL);
		break;
	case OPT_STAT_VERSION:
		showVersion(strEXEName, std::cout);
		cleanup(config, ran);
		nice_exit(EXT_CODE_GOOD,NULL);
		break;
	}
	
	/***************************************************************************************************/
	/* Command Sanity Checks */
	/***************************************************************************************************/

	// Sanity checks...
	// Make sure that we aren't in manual mode with suppressed user interaction...
	if (config.mode() == Config::MODE_STATIC_MANUAL && config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {
		warning("Unable to manually advance the time step in with the '--auto' flag asserted. Switching to '%s' mode.", true, ARG_MODE_STATIC_AUTO);
		config.mode(Config::MODE_STATIC_AUTO);
	}

	// Ensure we are doing _something_
	bool doingSomething = false;
	for (Config::Toolchain tool = Config::TC_BEGIN; tool < Config::TC_END && !doingSomething; tool = (Config::Toolchain)(((int) tool) + 1)) {
		if (config.run(tool) && config.command(tool) != "")
			doingSomething = true;
	}
	if (!doingSomething) {
		// Everything is disabled.
		pragma("The toolchain is empty. Exiting.", true, EXT_CODE_GOOD);
	}

	debug("The command line options are sane.", true);
	/***************************************************************************************************/
	/* Translator */
	/***************************************************************************************************/

	
	// Run the translator if it's called for.
	debug("Beginning translator subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_TRANSLATOR, config.intConfigOpt(Config::OPT_MAXSTEP), "translator")) != TC_STAT_TOOLSKIPPED) {

		// It Ran!
		ran[Config::TC_TRANSLATOR] = true;

		// check the status and make sure all is well...
		if((intSystemResult & ~TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK & ~TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK) != TC_STAT_OK)
		{
			cleanup(config, ran);
			error("An error occurred while executing the translator.",true, EXT_CODE_TOOLCHAIN_TRANS_ERR);
		}

		// Check for abnormalities...
		if (intSystemResult & TC_STAT_TRANS_CPLUS2ASP_ABNORMALITY_MASK) {
			// The abnormality mask is set, meaning that there is at least one abnormality...

			if (!config.customMode()) {
				// They haven't specified a mode. Default to REACTIVE.
				pragma("One or more abnormality constants have been detected. Defaulting to the '%s' mode.", true, ARG_MODE_REACTIVE);
				config.mode(Config::MODE_REACTIVE);
			} else if (config.mode() == Config::MODE_STATIC_AUTO || config.mode() == Config::MODE_STATIC_MANUAL) {
				warning("One or more abnormality constants have been detected while operating in a static mode. This isn't recommended as many answer-sets will be generated.",true);
			}
		}

		if ((intSystemResult & TC_STAT_TRANS_CPLUS2ASP_ADDITIVE_MASK)) {
			// The additive mask is set, meaning that there is at least one additive constant...
			if (config.boolConfigOpt(Config::OPT_INCL_STD)) {
				pragma("One or more additive constants have been detected. Including the additive standard file.",true);
				config.boolConfigOpt(Config::OPT_INCL_ADDITIVE, true);
			} else {
				warning("One or more additive constants have been detected but the standard file has been suppressed. The additive standard file will not be included.",true);
			}
		}
	}

	/**********************************************************************************************************************/
	/* Intermediate Processing & Final Configuration */
	/**********************************************************************************************************************/

	debug("Translation done. Performing intermediate processing and final configuration.", true);

	// If any of the "critical" constants aren't defined and one of the
	// "active" tool chain programs is going to need the constants, try
	// finding "hint" comments in the input that we can use to fill in details.


	// If any of the "critical" constants aren't defined and one of the
	// "active" tool chain programs is going to need the constants, try
	// finding "hint" comments in the input that we can use to fill in details.
	unsigned char neededConstantFlgs = 0;

	if (!config.customConfigOpt(Config::OPT_MAXSTEP)
			&& (config.mode() == Config::MODE_STATIC_AUTO /* || config.mode() == Config::MODE_STATIC_MANUAL */)) {
		// This isn't needed in static-manual mode, we'll simply ask the user!
		neededConstantFlgs |= CONST_MAXSTEP_MASK;
		debug("The maxstep is unspecified. Registering the deficiency.", true);
	}

	if (!config.customConfigOpt(Config::OPT_QUERY)) {
		neededConstantFlgs |= CONST_QUERY_MASK;
		debug("The query is unspecified. Registering the deficiency.", true);
	}

	if (config.boolConfigOpt(Config::OPT_INCL_ADDITIVE) && !config.customConfigOpt(Config::OPT_MAXADDITIVE)) {
		neededConstantFlgs |= CONST_MAXADDITIVE_MASK;
		debug("The maxAdditive is unspecified. Registering the deficiency.", true);
	}

	/* Note: minstep is never really required, therefore we never register the deficiency */

	if (!config.customConfigOpt(Config::OPT_EXT_PORT) && config.mode() == Config::MODE_REACTIVE) {
		neededConstantFlgs |= CONST_EXT_PORT_MASK;
		debug("The external port is unspecified. Registering the deficiency.", true);
	}

	if (neededConstantFlgs && (config.run(Config::TC_GROUNDER) || config.run(Config::TC_SOLVER)))
	{
		debug("Going hunting for one or more critical constants...",true);

		// Scan the files for the required constants. Hopefully one of them has it!
		neededConstantFlgs = scanFilesForConstants(config, ran[Config::TC_TRANSLATOR], neededConstantFlgs);
	}


	// If at least one of maxstep and query still aren't defined and, we found query hints,
	// and we're allowed to be interactive, set up a prompt to have the user pick values to fill in.


	// Query deficiency:
	if (neededConstantFlgs & CONST_QUERY_MASK) {
		if (config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {
			// We aren't supposed to be asking the user anything...
			// We can still salvage this if there is only a single query...
			if (config.queryCount() == 1) {
				config.intConfigOpt(Config::OPT_QUERY,config.beginQueries()->first);
				pragma("The query hasn't been defined but there is only a single one. Defaulting to query '%s'.", true, config.activeQuery()->name.c_str());
				neededConstantFlgs &= ~CONST_QUERY_MASK;
			}
		} else {
			// Let's make this simple and just ask the user.
			unsigned int tmpVal;
			if ((tmpVal = queryUserForQuery(config)) != Config::UNDEFINED) {
				config.intConfigOpt(Config::OPT_QUERY, tmpVal);
				debug("Got user input. Using query '%s'.", true, config.activeQuery()->name.c_str());
				neededConstantFlgs &= ~CONST_QUERY_MASK;
			} else {
				// They elected to exit instead of answer a simple question.
				// Life moves on but we do not.
				cleanup(config, ran);
				nice_exit(0, "Exiting.");
			}
		}
	}

	// Get the currently active query.
	// Note: If there is query selected from the user this _could_ be null, so we need to be careful.
	activeQuery = config.activeQuery();

	// Maxstep Deficiency:
	// This can be solved if we have a query and it has a maxstep...
	// We actually want to double check this right now regardless of whether we 'need' it. That way the query/maxstep is kept in sync.
	if (config.intConfigOpt(Config::OPT_MAXSTEP) == Config::UNDEFINED
			&& activeQuery
			&& activeQuery->maxstep != Config::UNDEFINED) {

		// All is well, we have a maximum step to use...
		config.intConfigOpt(Config::OPT_MAXSTEP, activeQuery->maxstep);
		neededConstantFlgs &= ~CONST_MAXSTEP_MASK;
		debug("Selecting maxstep '%d' from the query '%s' for our maximum step.", true, activeQuery->maxstep, activeQuery->name.c_str());
	} else if ((neededConstantFlgs & CONST_MAXSTEP_MASK)
			&& !config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

		// Well, we don't have a  good maxstep value (and one is certainly needed).
		// Luckily we're allowed to ask the user.

		unsigned int tmpVal;

		if ((tmpVal = queryUserForConstant(config, "maximum step")) != Config::UNDEFINED) {
			config.intConfigOpt(Config::OPT_MAXSTEP, tmpVal);
			debug("Got maxstep value '%d' from user.", true, tmpVal);
			neededConstantFlgs &= ~CONST_MAXSTEP_MASK;
		} else {
			// The user wants to exit.
			cleanup(config, ran);
			nice_exit(0, "Exiting.");
		}
	}

	// Minstep
	// If a minstep isn't specified and we know a query, then we might be able to get it from the query...
	if (config.intConfigOpt(Config::OPT_MINSTEP) == Config::UNDEFINED
			&& activeQuery
			&& activeQuery->minstep != Config::UNDEFINED)
	{
		// The query has specified a minimum step for us to use.
		config.intConfigOpt(Config::OPT_MINSTEP, activeQuery->minstep);
		debug("Got minstep value '%d' from the query '%s'.", true, activeQuery->minstep, activeQuery->name.c_str());
		neededConstantFlgs &= ~CONST_MINSTEP_MASK;
	} else {
		// No such luck, default to 0.
		debug("No minimum step specified. Defaulting to 0.", true);
		config.intConfigOpt(Config::OPT_MINSTEP, 0);
		neededConstantFlgs &= ~CONST_MINSTEP_MASK;

	}

	// MaxAdditive Deficiency:
	// There is no way to resolve this short of asking the user...
	if ((neededConstantFlgs & CONST_MAXADDITIVE_MASK)
			&& ~config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

		// Well, it's certainly a good thing we can ask the user, now isn't it?
		unsigned int tmpVal;

		if ((tmpVal = queryUserForConstant(config, "maximum additive value")) != Config::UNDEFINED) {
			config.intConfigOpt(Config::OPT_MAXADDITIVE, tmpVal);
			debug("Got maxAdditive value '%d' from user.", true, tmpVal);
			neededConstantFlgs &= ~CONST_MAXADDITIVE_MASK;
		} else {
			// The user wants to exit.
			cleanup(config, ran);
			nice_exit(0, "Exiting.");
		}
	}


	// Listening port deficiency:
	// We have to ask the user about this.
	if ((neededConstantFlgs & CONST_EXT_PORT_MASK)
			&& ~config.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION)) {

		// Well, it's certainly a good thing we can ask the user, now isn't it?
		unsigned int tmpVal;

		if ((tmpVal = queryUserForConstant(config, "client port")) != Config::UNDEFINED) {
			config.intConfigOpt(Config::OPT_EXT_PORT, tmpVal);
			debug("Got client port value '%d' from user.", true, tmpVal);
			neededConstantFlgs &= ~CONST_EXT_PORT_MASK;
		} else {
			// The user wants to exit.
			cleanup(config, ran);
			nice_exit(0, "Exiting.");
		}
	}

	// Hopefully by now we've resolved all of our various issues...
	if (neededConstantFlgs) {
		// Aaaaand we haven't. Fail gracefully.
		if (neededConstantFlgs & CONST_QUERY_MASK) error("The query to run was never defined. Exiting.", true, 0);
		if (neededConstantFlgs & CONST_MAXSTEP_MASK) error("The maximum step was never defined and is required for static mode. Exiting.", true, 0);
		if (neededConstantFlgs & CONST_MAXADDITIVE_MASK) error("The maxAdditive constant was never defined and is required for program's containing additive constants. Exiting.", true, 0);
		if (neededConstantFlgs & CONST_MINSTEP_MASK) error("The minimum step was never specified and is required for the given running mode. Exiting.", true, 0);
		if (neededConstantFlgs & CONST_EXT_PORT_MASK) error("The port to listen on for client connections is undefined and is required for the given running mode. Exiting.", true, 0);
		cleanup(config, ran);
		nice_exit(EXT_CODE_UNDEFINED_CONSTANTS, NULL);
	}
	
	// After this point we know for a fact that the active query is non-null.
	// This is because we've guaranteed that the query was previously initialized to some value,
	// otherwise it would have been marked as deficient and we would have exited by now.

	/**********************************************************************************************************************/
	/* Pre-processor */
	/**********************************************************************************************************************/
	debug("Entering pre-processor subroutine.", true);
	if ((intSystemResult = runTool(config, Config::TC_PREPROC, config.intConfigOpt(Config::OPT_MAXSTEP), "pre-processor")) != TC_STAT_TOOLSKIPPED)  {
		// It Ran!
		ran[Config::TC_PREPROC] = true;

		// check the status and make sure all is well...
		if(intSystemResult != TC_STAT_OK)
		{
			cleanup(config, ran);
			error("An error occurred while executing the pre-processor.",true, EXT_CODE_TOOLCHAIN_PREPROC_ERR);
		}

	}
	
	/**********************************************************************************************************************/
	/* Interactive Loop */
	/**********************************************************************************************************************/

	/*********************************************************************************************/
	/* Initial Maxstep */
	/*********************************************************************************************/

	// Note: current maxstep is ONLY applicable for the static modes.
	if (config.mode() == Config::MODE_STATIC_MANUAL) {
		// Running in manual mode, ask the user what to do.
		if ((intCurMaxstep = queryUserForConstant(config, "maximum step", config.intConfigOpt(Config::OPT_MINSTEP))) != Config::UNDEFINED) {
			debug("Got new maximum step value '%d' from user.", true, intCurMaxstep);
		} else {
			// The user wants to exit.
			cleanup(config, ran);
			nice_exit(0, "Exiting.");
		}

	} else if (config.mode() == Config::MODE_STATIC_AUTO) {
		// Automatic mode, go with the current minstep value
		// or default to 0 if it's not included.
		intCurMaxstep = config.intConfigOpt(Config::OPT_MINSTEP);
		if (intCurMaxstep == Config::UNDEFINED) intCurMaxstep = 0;
	} else {
		// Incremental or reactive, go with the REAL maxstep.
		intCurMaxstep = config.intConfigOpt(Config::OPT_MAXSTEP);
	}

	// run the rest of the tool chain at least once, but we may have to run it multiple times in one of the STATIC modes...
	debug("Entering interactive loop.", true);
	do
	{

		/*********************************************************************************************/
		/* Header Logic */
		/*********************************************************************************************/

		// Print the solution header!
		if (config.run(Config::TC_SOLVER))
		{
			pragma("Running Query '%s'", true, activeQuery->name.c_str());
			switch (config.mode()) {
			case Config::MODE_STATIC_AUTO:
			case Config::MODE_STATIC_MANUAL:
				pragma("Current maxstep value is '%d'", true, intCurMaxstep);
				break;

			case Config::MODE_INCREMENTAL:
			case Config::MODE_REACTIVE:
				// We can guarantee that at this point the minimum step is defined.
				if (config.intConfigOpt(Config::OPT_MAXSTEP) != Config::UNDEFINED)
					pragma("Minimum Step = '%d', Maximum Step = '%d'.", true, config.intConfigOpt(Config::OPT_MINSTEP), config.intConfigOpt(Config::OPT_MAXSTEP));
				else
					pragma("Minimum Step = '%d', No Maximum Step.", true, config.intConfigOpt(Config::OPT_MINSTEP));
				break;

			default:
				break;
			}

			if (config.intConfigOpt(Config::OPT_NUM_SOLN) == 0)
				pragma("Searching for all solutions.", true);
			else
				pragma("Searching for %d solutions.", true, config.intConfigOpt(Config::OPT_NUM_SOLN));
		}

		/*********************************************************************************************/
		/* Grounder */
		/*********************************************************************************************/
		debug("Entering grounder subroutine.", true);
		if ((intSystemResult = runTool(config, Config::TC_GROUNDER, intCurMaxstep, "grounder")) != TC_STAT_TOOLSKIPPED)  {
			// It Ran!
			ran[Config::TC_GROUNDER] = true;

			// check the status and make sure all is well...
			if(intSystemResult != TC_STAT_OK)
			{
				cleanup(config, ran);
				error("An error occurred while executing the grounder.",true, EXT_CODE_TOOLCHAIN_GROUNDER_ERR);
			}

		}

		/*********************************************************************************************/
		/* Solver */
		/*********************************************************************************************/
		debug("Entering solver subroutine.", true);
		if ((intSystemResult = runTool(config, Config::TC_SOLVER, intCurMaxstep, "solver")) != TC_STAT_TOOLSKIPPED)  {
			// It Ran!
			ran[Config::TC_SOLVER] = true;

			// check the status and make sure all is well...
			if (intSystemResult == TC_STAT_SO_CLINGO_FOUND_SOLUTIONS) {
				// Looks like we have solutions... YAY!
				blnFoundSolutions = true;
			} else if (intSystemResult == TC_STAT_BG) {
				// The solver was launched in the background.
			} else if(intSystemResult != TC_STAT_OK) {
				cleanup(config, ran);
				error("An error occurred while executing the solver.",true, EXT_CODE_TOOLCHAIN_SOLVER_ERR);
			}

		}

		/*********************************************************************************************/
		/* Post-processor */
		/*********************************************************************************************/
		// The post-processor is only run outside of reactive mode
		debug("Entering post-processor subroutine.", true);
		if (config.mode() != Config::MODE_REACTIVE) {
			if ((intSystemResult = runTool(config, Config::TC_POSTPROC, intCurMaxstep, "post-processor")) != TC_STAT_TOOLSKIPPED)  {
				// It Ran!
				ran[Config::TC_POSTPROC] = true;

				// check the status and make sure all is well...
				if (intSystemResult == TC_STAT_POSTPROC_AS2TRANSITION_FOUND_SOLUTIONS) {
					// Looks like we have solutions... YAY!
					blnFoundSolutions = true;
				} else if(intSystemResult != TC_STAT_OK) {
					cleanup(config, ran);
					error("An error occurred while executing the post-processor.",true, EXT_CODE_TOOLCHAIN_POSTPROC_ERR);
				}
			}
		}

		/*********************************************************************************************/
		/* Reactive Bridge */
		/*********************************************************************************************/

		// The reactive bridge is run inside of reactive mode.
		// NOTE: If we really are in reactive mode then they solver is still running the background!
		debug("Entering reactive bridge subroutine.", true);
		if (config.mode() == Config::MODE_REACTIVE) {
			if ((intSystemResult = runTool(config, Config::TC_REACTIVE_BRIDGE, intCurMaxstep, "reactive bridge")) != TC_STAT_TOOLSKIPPED)  {
				// It Ran!
				ran[Config::TC_REACTIVE_BRIDGE] = true;

				// check the status and make sure all is well...
				if (intSystemResult == TC_STAT_BG) {
					// The reactive bridge was launched in the background.
				} else if(intSystemResult != TC_STAT_OK) {
					cleanup(config, ran);
					error("An error occurred while executing the reactive bridge.",true, EXT_CODE_TOOLCHAIN_REACTIVE_BRIDGE_ERR);
				}
			}
		}

		/*********************************************************************************************/
		/* Maxstep Increment */
		/*********************************************************************************************/

		if (config.mode() == Config::MODE_STATIC_MANUAL) {
			intCurMaxstep = queryUserForConstant(config, "maximum step", intCurMaxstep);
		} else {
			intCurMaxstep++;
		}

	} while(
			// The loop should continue as long as we are:
			// * Running in static-manual mode and the user hasn't told us to stop, or
			// * Running in static-auto mode, we haven't reached the maximum step , and we haven't found solutions.
			(config.mode() == Config::MODE_STATIC_MANUAL && intCurMaxstep != Config::UNDEFINED)
			|| (config.mode() == Config::MODE_STATIC_AUTO && intCurMaxstep <= config.intConfigOpt(Config::OPT_MAXSTEP) && !blnFoundSolutions)
			);

	debug("Exiting interactive loop.", true);
	/**********************************************************************************************************************/
	/* Final Cleanup */
	/**********************************************************************************************************************/

	cleanup(config, ran);

	return 0;
}

OptionStatus parseCommandOptions(int argc, char const* const* argv, Config& outConf) {
	// Process command-line arguments.

	char const* tmpptr;
	size_t tmpoffset;
	char tmpPath[PATH_MAX];
	std::list<char const*> rawInputList;

	for(int i = 1; i < argc; i++)
	{
		debug("Parsing option '%s'.", true, argv[i]);
		switch (parseOption(argv[i])) {

		case OPT_AUTO:
			// This is supposed to be an automated run, don't ask the user for anything.
			if (outConf.boolConfigOpt(Config::OPT_SUPPRESS_INTERACTION, true)) {
				warning("Detected redefinition of option '%s'. Continuing with value '%s'",true,argv[i],"true");
			}
			break;

		case OPT_BRIDGE:
			// They are specifying a specific command for the bridge.

			if (++i < argc) {
				if (outConf.command(Config::TC_REACTIVE_BRIDGE, argv[i])) {
					warning("Detected redefinition of bridge command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_BRIDGE_OPTS:

			if (++i < argc) {
				if (outConf.opts(Config::TC_REACTIVE_BRIDGE, argv[i])) {
					warning("Detected redefinition of bridge command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;
		case OPT_CONST:
			// Constant Declaration...
			if(++i < argc && (tmpptr = strchr(argv[i],'=')) != NULL)
			{
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}

			} else {   // Set up for a constant without actually giving one, bad command line.
				error("Expected a constant definition of the form 'constant=value' after option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_FRM_BRIDGE:
			pragma("Running the toolchain from the reactive bridge is discouraged.",true);
			if (outConf.setRunFrom(Config::TC_REACTIVE_BRIDGE)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_GRD:
			// Don't run anything before the grounder.
			if (outConf.setRunFrom(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_PRE:
			// Don't run anything before the pre-processor.
			if (outConf.setRunFrom(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FRM_POST:
			// Don't call anything before the post-processor (equivalent to "-justpost")
			if (outConf.setRunFrom(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_SO:
			// Don't run anything before the solver.
			if (outConf.setRunFrom(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_FROM_TRAN:
			// Don't call anything before the translator (basically a no-op option).
			if (outConf.setRunFrom(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_GRD:
			// They're giving us a specific executable to use as the grounder instead of the default.
			// Make sure a second argument follows, and save the new grounder.
			if (++i < argc) {
				if (outConf.command(Config::TC_GROUNDER, argv[i])) {
					warning("Detected redefinition of grounder command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_GRD_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_GROUNDER, argv[i])) {
					warning("Detected redefinition of grounder command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_JUST_GRD:
			// Just call the grounder program, no others.
			if (outConf.setOnlyRun(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_PRE:
			// Just call the preprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_POST:
			// Just call the postprocessor program, no others.
			if (outConf.setOnlyRun(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_SO:
			// Just call the solver program, no others.
			if (outConf.setOnlyRun(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_JUST_TRANS:
			// Just call the translator program, no others.
			if (outConf.setOnlyRun(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_MODE_SELECT:
			Config::Mode mode;

			if (++i < argc) {

				if (!strcmp(argv[i],ARG_MODE_STATIC_MANUAL)) {
					mode = Config::MODE_STATIC_MANUAL;
				} else if (!strcmp(argv[i],ARG_MODE_STATIC_AUTO)) {
					mode = Config::MODE_STATIC_AUTO;
				} else if (!strcmp(argv[i],ARG_MODE_INCREMENTAL)) {
					mode = Config::MODE_INCREMENTAL;
				} else if (!strcmp(argv[i],ARG_MODE_REACTIVE)) {
					mode = Config::MODE_INCREMENTAL;
				} else {
					error("Expected a mode option (one of '%s', '%s', '%s', or '%s') following option '%s'. Exiting.",true,0,
							ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, OPT_MODE_REACTIVE, argv[i-1]);
					return OPT_STAT_BAD_ARG;
				}

				if (outConf.mode(mode)) {
					warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, argv[i]);
				}

			} else {
				error("Expected a mode option (one of '%s', '%s', '%s', or '%s') following option '%s'. Exiting.",true,0,
						ARG_MODE_STATIC_AUTO, ARG_MODE_STATIC_MANUAL, ARG_MODE_INCREMENTAL, ARG_MODE_REACTIVE, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}

			break;

		case OPT_MODE_STATIC_AUTO:
			if (outConf.mode(Config::MODE_STATIC_AUTO)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_STATIC_AUTO);
			}
			break;

		case OPT_MODE_STATIC_MANUAL:
			if (outConf.mode(Config::MODE_STATIC_MANUAL)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_STATIC_MANUAL);
			}
			break;
		case OPT_MODE_INCREMENTAL:
			if (outConf.mode(Config::MODE_INCREMENTAL)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_INCREMENTAL);
			}
			break;

		case OPT_MODE_REACTIVE:
			if (outConf.mode(Config::MODE_REACTIVE)) {
				warning("Detected a redefinition of the program's running mode. Continuing with value '%s.", true, ARG_MODE_REACTIVE);
			}
			break;

		case OPT_NO_DEL:
			// Shut off deleting intermediate files.
			if (outConf.boolConfigOpt(Config::OPT_DISCARD_INTERMEDIATE, false)
					|/*non-short-circuiting*/ outConf.boolConfigOpt(Config::OPT_DISCARD_F2LP, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;


		case OPT_NO_STD:
			// Don't include standard files in the final product.
			if (outConf.boolConfigOpt(Config::OPT_INCL_STD, false)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_POSTPROC:
			// They're giving us a specific executable to use as the post-processor instead of the default.
			// Make sure a second argument follows, and save the new post-processor.
			if (++i < argc) {
				if (outConf.command(Config::TC_POSTPROC, argv[i])) {
					warning("Detected redefinition of post-processor command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_POSTPROC_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_POSTPROC, argv[i])) {
					warning("Detected redefinition of post-processor command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_PREPROC:
			// They're giving us a specific executable to use as the pre-processor instead of the default.
			// Make sure a second argument follows, and save the new pre-processor.
			if (++i < argc) {
				if (outConf.command(Config::TC_PREPROC, argv[i])) {
					warning("Detected redefinition of pre-processor command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_PREPROC_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_PREPROC, argv[i])) {
					warning("Detected redefinition of pre-processor command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;


		case OPT_SO:
			// They're giving us a specific executable to use as the solver instead of the default.
			// Make sure a second argument follows, and save the new solver.
			if (++i < argc) {
				if (outConf.command(Config::TC_SOLVER, argv[i])) {
					warning("Detected redefinition of solver command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_SO_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_SOLVER, argv[i])) {
					warning("Detected redefinition of solver command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_TO_BRIDGE:
			if (outConf.setRunTo(Config::TC_REACTIVE_BRIDGE)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_GRD:
			// Shut off deleting intermediate files.
			if (outConf.setRunTo(Config::TC_GROUNDER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_PRE:
			// Run everything up to the pre-processor.
			if (outConf.setRunTo(Config::TC_PREPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_POST:
			// Run everything up to the post-processor...
			if (outConf.setRunTo(Config::TC_POSTPROC)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_SO:
			// Run everything up to the solver...
			if (outConf.setRunTo(Config::TC_SOLVER)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TO_TRANS:
			// Run everything up to the translator...
			if (outConf.setRunTo(Config::TC_TRANSLATOR)) {
				warning("The option '%s' has overridden one or more previous choices.",true,argv[i]);
			}
			break;

		case OPT_TRANS:
			// They're giving us a specific executable to use as the translator instead of the default.
			// Make sure a second argument follows, and save the new grounder.
			if (++i < argc) {
				if (outConf.command(Config::TC_TRANSLATOR, argv[i])) {
					warning("Detected redefinition of translator command. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for a command but they didn't deliver.
				error("Expected a command following option '%s'. Exiting.",true,0,argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_TRANS_OPTS:
			if (++i < argc) {
				if (outConf.opts(Config::TC_TRANSLATOR, argv[i])) {
					warning("Detected redefinition of translator command options. Continuing with value '%s'",true,argv[i]);
				}
			} else {
				// setup for options but they didn't deliver
				error("Expected pass-through options following the option '%s'. Exiting.", true, 0, argv[i-1]);
				return OPT_STAT_BAD_ARG;
			}
			break;

		case OPT_VERSION:
			return OPT_STAT_VERSION;

		case OPT_HELP:
			return OPT_STAT_HELP;

		case OPT_UNSUPPORTED:
			// Whatever this is, it's unsupported.
			warning("The '%s' option is no longer supported. It will be ignored.",true);
			break;

		case OPT_UNSUPPORTED_ADDITIVE:
			// They want us to include the additive standard file...
			// This option is deprecated and shouldn't be used.
			warning("The '%s' option is no longer supported. The additive file will be included automatically if additive constants are detected.",true,argv[i]);
			break;

		case OPT_UNSUPPORTED_GRSO:
			// They did something involving the explicit grounder/solver
			// We no longer support the explicit grounder/solver calls
			error("The '%s' option is no longer supported. We no longer use a dedicated grounder/solver in the toolchain. Please make use of the solver component instead.",true,0,argv[i]);

			// We probably aren't going to do what they want, go ahead and signal that something went wrong
			return OPT_STAT_BAD_ARG;

		case OPT_UNSUPPORTED_MANUAL_MAXSTEP:
			// Manually advance the maximum step of the program query
			error("The '%s' option is no longer supported. Please use that '--mode=static-manual' option instead.",true,0,argv[i]);
			break;

		case OPT_UNKNOWN:
			debug("The option isn't a recognized flag. Checking other possibilities.", true);
			if (argv[i][0] == '-')
			{
				// It appears to be a bad argument...
				error("Found an unrecognized argument '%s'. Exiting.",true,0,argv[i]);
				return OPT_STAT_BAD_ARG;
			}

			// If there's no "header" on the argument, it's either a constant declaration, an input file, or the number of solutions.
			else if(isInteger(argv[i]))
			{	// It looks like a number, atoi it and save that as the desired number of solutions.
				int numSolutions = atoi(argv[i]);
				if(numSolutions < 0) {
					warning("The number of solutions cannot be negative. Ignoring the argument.",true);
				} else {
					if (outConf.intConfigOpt(Config::OPT_NUM_SOLN, (unsigned int)numSolutions)) {
						warning("Detected the redefinition of the number of solutions. Continuing with '%s'.",true,argv[i]);
					}
				}
			}
			else if((tmpptr = strchr(argv[i],'=')) != NULL)
			{   // Found an equals sign in the argument, it's probably a "const=value" declaration.
				tmpoffset = (size_t)(tmpptr - argv[i]);

				// Get the constant name/value
				std::string name = std::string(argv[i], tmpoffset);
				std::string value = std::string(&(argv[i][tmpoffset+1]));

				debug("Parsed constant declaration name='%s', value='%s'",true, name.c_str(), value.c_str());

				if (outConf.def(name,value)) {
					warning("Detected redefinition of constant '%s'. Continuing with value '%s'",true,name.c_str(),value.c_str());
				}
			}

			{	// If it's not a number, it's probably an input file. Make sure it exists, and then save it to the list.

				if(realpath(argv[i], tmpPath) == NULL)
				{
					// Couldn't find the input file...
					error("Unable to locate input file '%s'. Exiting.",true,0,argv[i]);
					return OPT_STAT_BAD_ARG;
				}
				else
				{
					// Save all of the input files until we are done and can handle them...
					rawInputList.push_back(argv[i]);
				}
			}
			break;
		}
	}

	// We've finished parsing all of the arguments... Let's handle those pesky input files.
	debug("Handling input files...", true);
	if (!rawInputList.size()) {
		//uh-oh. They didn't specify any input files. This simply won't do.
		error("One or more input files must be specified.",true,0);
		return OPT_STAT_BAD_ARG;
	}

	// They've insisted on sticking with a given mode. Make sure they're aware if they're using an incompatible
	for (std::list<char const*>::iterator it = rawInputList.begin(); it != rawInputList.end(); it++) {
		Config::FileType type = outConf.addInput(*it);
		if (outConf.customMode() && type.known && !(type.runningMode & outConf.mode())) {
			warning("The file '%s' doesn't appear to be compatible with the current running mode.",true,*it);
		}
	}

	return OPT_STAT_OK;
}

/**
 * Parses a string and determines what (if any) command line option it contains.
 * @param opt - The string to parse.
 * @return The command line option contained within the string (or OPT_UNKNOWN).
 */
Option parseOption(char const* opt) {
	char const* marker;

	
#line 1225 "<stdout>"
	{
		char yych;
		unsigned int yyaccept = 0;

		yych = *opt;
		switch (yych) {
		case '\n':	goto yy2;
		case '-':	goto yy3;
		default:	goto yy5;
		}
yy2:
		opt = marker;
		switch (yyaccept) {
		case 0: 	goto yy4;
		case 1: 	goto yy25;
		case 2: 	goto yy31;
		case 3: 	goto yy68;
		case 4: 	goto yy73;
		case 5: 	goto yy80;
		case 6: 	goto yy107;
		case 7: 	goto yy123;
		case 8: 	goto yy151;
		case 9: 	goto yy158;
		case 10: 	goto yy168;
		case 11: 	goto yy195;
		}
yy3:
		yyaccept = 0;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy6;
		case '?':	goto yy16;
		case 'a':	goto yy15;
		case 'b':	goto yy21;
		case 'c':	goto yy22;
		case 'f':	goto yy14;
		case 'g':	goto yy13;
		case 'j':	goto yy12;
		case 'm':	goto yy10;
		case 'n':	goto yy9;
		case 'p':	goto yy8;
		case 's':	goto yy20;
		case 't':	goto yy7;
		case 'v':	goto yy18;
		default:	goto yy4;
		}
yy4:
#line 1284 "cplus2asp.re2c"
		{ return OPT_UNKNOWN; }
#line 1275 "<stdout>"
yy5:
		yych = *++opt;
		goto yy4;
yy6:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy199;
		case 'b':	goto yy201;
		case 'c':	goto yy200;
		case 'f':	goto yy202;
		case 'g':	goto yy203;
		case 'h':	goto yy211;
		case 'j':	goto yy204;
		case 'm':	goto yy205;
		case 'n':	goto yy206;
		case 'p':	goto yy207;
		case 's':	goto yy208;
		case 't':	goto yy209;
		case 'u':	goto yy212;
		case 'v':	goto yy210;
		default:	goto yy2;
		}
yy7:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy163;
		case 'r':	goto yy164;
		default:	goto yy2;
		}
yy8:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy146;
		case 'o':	goto yy144;
		case 'r':	goto yy145;
		default:	goto yy2;
		}
yy9:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy113;
		default:	goto yy2;
		}
yy10:
		++opt;
		switch ((yych = *opt)) {
		case 'm':	goto yy111;
		default:	goto yy11;
		}
yy11:
#line 1245 "cplus2asp.re2c"
		{ return OPT_MODE_SELECT; }
#line 1328 "<stdout>"
yy12:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy85;
		default:	goto yy2;
		}
yy13:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy72;
		default:	goto yy2;
		}
yy14:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy43;
		default:	goto yy2;
		}
yy15:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy37;
		case 'u':	goto yy36;
		default:	goto yy2;
		}
yy16:
		++opt;
#line 1267 "cplus2asp.re2c"
		{ return OPT_HELP; }
#line 1358 "<stdout>"
yy18:
		++opt;
#line 1266 "cplus2asp.re2c"
		{ return OPT_VERSION; }
#line 1363 "<stdout>"
yy20:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy30;
		default:	goto yy2;
		}
yy21:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy24;
		default:	goto yy2;
		}
yy22:
		++opt;
#line 1229 "cplus2asp.re2c"
		{ return OPT_CONST; }
#line 1380 "<stdout>"
yy24:
		yyaccept = 1;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy26;
		default:	goto yy25;
		}
yy25:
#line 1230 "cplus2asp.re2c"
		{ return OPT_BRIDGE; }
#line 1391 "<stdout>"
yy26:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy27;
		default:	goto yy2;
		}
yy27:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy28;
		default:	goto yy2;
		}
yy28:
		++opt;
#line 1231 "cplus2asp.re2c"
		{ return OPT_BRIDGE_OPTS; }
#line 1408 "<stdout>"
yy30:
		yyaccept = 2;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy32;
		default:	goto yy31;
		}
yy31:
#line 1256 "cplus2asp.re2c"
		{ return OPT_SO; }
#line 1419 "<stdout>"
yy32:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy33;
		default:	goto yy2;
		}
yy33:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy34;
		default:	goto yy2;
		}
yy34:
		++opt;
#line 1257 "cplus2asp.re2c"
		{ return OPT_SO_OPTS; }
#line 1436 "<stdout>"
yy36:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy40;
		default:	goto yy2;
		}
yy37:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy38;
		default:	goto yy2;
		}
yy38:
		++opt;
#line 1270 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_ADDITIVE; }
#line 1453 "<stdout>"
yy40:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy41;
		default:	goto yy2;
		}
yy41:
		++opt;
#line 1228 "cplus2asp.re2c"
		{ return OPT_AUTO; }
#line 1464 "<stdout>"
yy43:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy44;
		default:	goto yy2;
		}
yy44:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy45;
		default:	goto yy2;
		}
yy45:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy50;
		case 'g':	goto yy46;
		case 'p':	goto yy49;
		case 's':	goto yy48;
		case 't':	goto yy47;
		default:	goto yy2;
		}
yy46:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy67;
		default:	goto yy2;
		}
yy47:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy62;
		default:	goto yy2;
		}
yy48:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy60;
		default:	goto yy2;
		}
yy49:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy54;
		case 'r':	goto yy53;
		default:	goto yy2;
		}
yy50:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy51;
		default:	goto yy2;
		}
yy51:
		++opt;
#line 1232 "cplus2asp.re2c"
		{ return OPT_FRM_BRIDGE; }
#line 1522 "<stdout>"
yy53:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy58;
		default:	goto yy2;
		}
yy54:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy55;
		default:	goto yy2;
		}
yy55:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy56;
		default:	goto yy2;
		}
yy56:
		++opt;
#line 1235 "cplus2asp.re2c"
		{ return OPT_FRM_POST; }
#line 1545 "<stdout>"
yy58:
		++opt;
#line 1234 "cplus2asp.re2c"
		{ return OPT_FRM_PRE; }
#line 1550 "<stdout>"
yy60:
		++opt;
#line 1236 "cplus2asp.re2c"
		{ return OPT_FROM_SO; }
#line 1555 "<stdout>"
yy62:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy63;
		default:	goto yy2;
		}
yy63:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy64;
		default:	goto yy2;
		}
yy64:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy65;
		default:	goto yy2;
		}
yy65:
		++opt;
#line 1237 "cplus2asp.re2c"
		{ return OPT_FROM_TRAN; }
#line 1578 "<stdout>"
yy67:
		yyaccept = 3;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy69;
		default:	goto yy68;
		}
yy68:
#line 1233 "cplus2asp.re2c"
		{ return OPT_FRM_GRD; }
#line 1589 "<stdout>"
yy69:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy70;
		default:	goto yy2;
		}
yy70:
		++opt;
#line 1271 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 1600 "<stdout>"
yy72:
		yyaccept = 4;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy75;
		case 's':	goto yy74;
		default:	goto yy73;
		}
yy73:
#line 1238 "cplus2asp.re2c"
		{ return OPT_GRD; }
#line 1612 "<stdout>"
yy74:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy79;
		default:	goto yy2;
		}
yy75:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy76;
		default:	goto yy2;
		}
yy76:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy77;
		default:	goto yy2;
		}
yy77:
		++opt;
#line 1239 "cplus2asp.re2c"
		{ return OPT_GRD_OPTS; }
#line 1635 "<stdout>"
yy79:
		yyaccept = 5;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy81;
		default:	goto yy80;
		}
yy80:
#line 1272 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 1646 "<stdout>"
yy81:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy82;
		default:	goto yy2;
		}
yy82:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy83;
		default:	goto yy2;
		}
yy83:
		++opt;
#line 1273 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 1663 "<stdout>"
yy85:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy86;
		default:	goto yy2;
		}
yy86:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy87;
		default:	goto yy2;
		}
yy87:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy88;
		case 'p':	goto yy91;
		case 's':	goto yy90;
		case 't':	goto yy89;
		default:	goto yy2;
		}
yy88:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy106;
		default:	goto yy2;
		}
yy89:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy101;
		default:	goto yy2;
		}
yy90:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy99;
		default:	goto yy2;
		}
yy91:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy93;
		case 'r':	goto yy92;
		default:	goto yy2;
		}
yy92:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy97;
		default:	goto yy2;
		}
yy93:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy94;
		default:	goto yy2;
		}
yy94:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy95;
		default:	goto yy2;
		}
yy95:
		++opt;
#line 1242 "cplus2asp.re2c"
		{ return OPT_JUST_POST; }
#line 1732 "<stdout>"
yy97:
		++opt;
#line 1241 "cplus2asp.re2c"
		{ return OPT_JUST_PRE; }
#line 1737 "<stdout>"
yy99:
		++opt;
#line 1243 "cplus2asp.re2c"
		{ return OPT_JUST_SO; }
#line 1742 "<stdout>"
yy101:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy102;
		default:	goto yy2;
		}
yy102:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy103;
		default:	goto yy2;
		}
yy103:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy104;
		default:	goto yy2;
		}
yy104:
		++opt;
#line 1244 "cplus2asp.re2c"
		{ return OPT_JUST_TRANS; }
#line 1765 "<stdout>"
yy106:
		yyaccept = 6;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy108;
		default:	goto yy107;
		}
yy107:
#line 1240 "cplus2asp.re2c"
		{ return OPT_JUST_GRD; }
#line 1776 "<stdout>"
yy108:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy109;
		default:	goto yy2;
		}
yy109:
		++opt;
#line 1274 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_GRSO; }
#line 1787 "<stdout>"
yy111:
		++opt;
#line 1275 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED_MANUAL_MAXSTEP; }
#line 1792 "<stdout>"
yy113:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy118;
		case 'g':	goto yy117;
		case 'p':	goto yy116;
		case 's':	goto yy115;
		case 't':	goto yy114;
		default:	goto yy2;
		}
yy114:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy139;
		default:	goto yy2;
		}
yy115:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy135;
		case 't':	goto yy134;
		default:	goto yy2;
		}
yy116:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy128;
		case 'r':	goto yy127;
		default:	goto yy2;
		}
yy117:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy122;
		default:	goto yy2;
		}
yy118:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy119;
		default:	goto yy2;
		}
yy119:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy120;
		default:	goto yy2;
		}
yy120:
		++opt;
#line 1250 "cplus2asp.re2c"
		{ return OPT_NO_DEL; }
#line 1845 "<stdout>"
yy122:
		yyaccept = 7;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy124;
		default:	goto yy123;
		}
yy123:
#line 1276 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1856 "<stdout>"
yy124:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy125;
		default:	goto yy2;
		}
yy125:
		++opt;
#line 1277 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1867 "<stdout>"
yy127:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy132;
		default:	goto yy2;
		}
yy128:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy129;
		default:	goto yy2;
		}
yy129:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy130;
		default:	goto yy2;
		}
yy130:
		++opt;
#line 1279 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1890 "<stdout>"
yy132:
		++opt;
#line 1278 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1895 "<stdout>"
yy134:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy137;
		default:	goto yy2;
		}
yy135:
		++opt;
#line 1280 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1906 "<stdout>"
yy137:
		++opt;
#line 1251 "cplus2asp.re2c"
		{ return OPT_NO_STD; }
#line 1911 "<stdout>"
yy139:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy140;
		default:	goto yy2;
		}
yy140:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy141;
		default:	goto yy2;
		}
yy141:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy142;
		default:	goto yy2;
		}
yy142:
		++opt;
#line 1281 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1934 "<stdout>"
yy144:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy156;
		default:	goto yy2;
		}
yy145:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy150;
		default:	goto yy2;
		}
yy146:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy147;
		default:	goto yy2;
		}
yy147:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy148;
		default:	goto yy2;
		}
yy148:
		++opt;
#line 1282 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 1963 "<stdout>"
yy150:
		yyaccept = 8;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy152;
		default:	goto yy151;
		}
yy151:
#line 1254 "cplus2asp.re2c"
		{ return OPT_PREPROC; }
#line 1974 "<stdout>"
yy152:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy153;
		default:	goto yy2;
		}
yy153:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy154;
		default:	goto yy2;
		}
yy154:
		++opt;
#line 1255 "cplus2asp.re2c"
		{ return OPT_PREPROC_OPTS; }
#line 1991 "<stdout>"
yy156:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy157;
		default:	goto yy2;
		}
yy157:
		yyaccept = 9;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy159;
		default:	goto yy158;
		}
yy158:
#line 1252 "cplus2asp.re2c"
		{ return OPT_POSTPROC; }
#line 2008 "<stdout>"
yy159:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy160;
		default:	goto yy2;
		}
yy160:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy161;
		default:	goto yy2;
		}
yy161:
		++opt;
#line 1253 "cplus2asp.re2c"
		{ return OPT_POSTPROC_OPTS; }
#line 2025 "<stdout>"
yy163:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy174;
		case 'g':	goto yy173;
		case 'p':	goto yy177;
		case 's':	goto yy176;
		case 't':	goto yy175;
		default:	goto yy2;
		}
yy164:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy165;
		default:	goto yy2;
		}
yy165:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy166;
		default:	goto yy2;
		}
yy166:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy167;
		default:	goto yy2;
		}
yy167:
		yyaccept = 10;
		yych = *(marker = ++opt);
		switch (yych) {
		case 'o':	goto yy169;
		default:	goto yy168;
		}
yy168:
#line 1264 "cplus2asp.re2c"
		{ return OPT_TRANS; }
#line 2064 "<stdout>"
yy169:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy170;
		default:	goto yy2;
		}
yy170:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy171;
		default:	goto yy2;
		}
yy171:
		++opt;
#line 1265 "cplus2asp.re2c"
		{ return OPT_TRANS_OPTS; }
#line 2081 "<stdout>"
yy173:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy194;
		default:	goto yy2;
		}
yy174:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy192;
		default:	goto yy2;
		}
yy175:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy187;
		default:	goto yy2;
		}
yy176:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy185;
		default:	goto yy2;
		}
yy177:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy179;
		case 'r':	goto yy178;
		default:	goto yy2;
		}
yy178:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy183;
		default:	goto yy2;
		}
yy179:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy180;
		default:	goto yy2;
		}
yy180:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy181;
		default:	goto yy2;
		}
yy181:
		++opt;
#line 1260 "cplus2asp.re2c"
		{ return OPT_TO_POST; }
#line 2135 "<stdout>"
yy183:
		++opt;
#line 1259 "cplus2asp.re2c"
		{ return OPT_TO_PRE; }
#line 2140 "<stdout>"
yy185:
		++opt;
#line 1261 "cplus2asp.re2c"
		{ return OPT_TO_SO; }
#line 2145 "<stdout>"
yy187:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy188;
		default:	goto yy2;
		}
yy188:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy189;
		default:	goto yy2;
		}
yy189:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy190;
		default:	goto yy2;
		}
yy190:
		++opt;
#line 1262 "cplus2asp.re2c"
		{ return OPT_TO_TRANS; }
#line 2168 "<stdout>"
yy192:
		++opt;
#line 1263 "cplus2asp.re2c"
		{ return OPT_TO_BRIDGE;	}
#line 2173 "<stdout>"
yy194:
		yyaccept = 11;
		yych = *(marker = ++opt);
		switch (yych) {
		case 's':	goto yy196;
		default:	goto yy195;
		}
yy195:
#line 1258 "cplus2asp.re2c"
		{ return OPT_TO_GRD; }
#line 2184 "<stdout>"
yy196:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy197;
		default:	goto yy2;
		}
yy197:
		++opt;
#line 1283 "cplus2asp.re2c"
		{ return OPT_UNSUPPORTED; }
#line 2195 "<stdout>"
yy199:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy613;
		case 'u':	goto yy614;
		default:	goto yy2;
		}
yy200:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy610;
		default:	goto yy2;
		}
yy201:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy600;
		default:	goto yy2;
		}
yy202:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy539;
		default:	goto yy2;
		}
yy203:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy518;
		default:	goto yy2;
		}
yy204:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy462;
		default:	goto yy2;
		}
yy205:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy406;
		case 'o':	goto yy407;
		default:	goto yy2;
		}
yy206:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy341;
		default:	goto yy2;
		}
yy207:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy309;
		case 'r':	goto yy308;
		default:	goto yy2;
		}
yy208:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy299;
		default:	goto yy2;
		}
yy209:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy227;
		case 'r':	goto yy228;
		default:	goto yy2;
		}
yy210:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy222;
		default:	goto yy2;
		}
yy211:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy220;
		default:	goto yy2;
		}
yy212:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy213;
		default:	goto yy2;
		}
yy213:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy214;
		default:	goto yy2;
		}
yy214:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy215;
		default:	goto yy2;
		}
yy215:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy216;
		default:	goto yy2;
		}
yy216:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy217;
		default:	goto yy2;
		}
yy217:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy218;
		default:	goto yy2;
		}
yy218:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy219;
		default:	goto yy2;
		}
yy219:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy148;
		default:	goto yy2;
		}
yy220:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy221;
		default:	goto yy2;
		}
yy221:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy16;
		default:	goto yy2;
		}
yy222:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy223;
		default:	goto yy2;
		}
yy223:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy224;
		default:	goto yy2;
		}
yy224:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy225;
		default:	goto yy2;
		}
yy225:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy226;
		default:	goto yy2;
		}
yy226:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy18;
		default:	goto yy2;
		}
yy227:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy241;
		default:	goto yy2;
		}
yy228:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy229;
		default:	goto yy2;
		}
yy229:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy230;
		default:	goto yy2;
		}
yy230:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy231;
		default:	goto yy2;
		}
yy231:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy232;
		default:	goto yy2;
		}
yy232:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy233;
		default:	goto yy2;
		}
yy233:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy234;
		default:	goto yy2;
		}
yy234:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy235;
		default:	goto yy2;
		}
yy235:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy236;
		default:	goto yy2;
		}
yy236:
		yyaccept = 10;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy237;
		default:	goto yy168;
		}
yy237:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy238;
		default:	goto yy2;
		}
yy238:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy239;
		default:	goto yy2;
		}
yy239:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy240;
		default:	goto yy2;
		}
yy240:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy171;
		default:	goto yy2;
		}
yy241:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy243;
		case 'g':	goto yy242;
		case 'p':	goto yy246;
		case 's':	goto yy245;
		case 't':	goto yy244;
		default:	goto yy2;
		}
yy242:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy286;
		default:	goto yy2;
		}
yy243:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy282;
		default:	goto yy2;
		}
yy244:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy274;
		default:	goto yy2;
		}
yy245:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy270;
		default:	goto yy2;
		}
yy246:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy248;
		case 'r':	goto yy247;
		default:	goto yy2;
		}
yy247:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy260;
		default:	goto yy2;
		}
yy248:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy249;
		default:	goto yy2;
		}
yy249:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy250;
		default:	goto yy2;
		}
yy250:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy251;
		default:	goto yy2;
		}
yy251:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy252;
		default:	goto yy2;
		}
yy252:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy253;
		default:	goto yy2;
		}
yy253:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy254;
		default:	goto yy2;
		}
yy254:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy255;
		default:	goto yy2;
		}
yy255:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy256;
		default:	goto yy2;
		}
yy256:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy257;
		default:	goto yy2;
		}
yy257:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy258;
		default:	goto yy2;
		}
yy258:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy259;
		default:	goto yy2;
		}
yy259:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy181;
		default:	goto yy2;
		}
yy260:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy261;
		default:	goto yy2;
		}
yy261:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy262;
		default:	goto yy2;
		}
yy262:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy263;
		default:	goto yy2;
		}
yy263:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy264;
		default:	goto yy2;
		}
yy264:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy265;
		default:	goto yy2;
		}
yy265:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy266;
		default:	goto yy2;
		}
yy266:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy267;
		default:	goto yy2;
		}
yy267:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy268;
		default:	goto yy2;
		}
yy268:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy269;
		default:	goto yy2;
		}
yy269:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy183;
		default:	goto yy2;
		}
yy270:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy271;
		default:	goto yy2;
		}
yy271:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy272;
		default:	goto yy2;
		}
yy272:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy273;
		default:	goto yy2;
		}
yy273:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy185;
		default:	goto yy2;
		}
yy274:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy275;
		default:	goto yy2;
		}
yy275:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy276;
		default:	goto yy2;
		}
yy276:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy277;
		default:	goto yy2;
		}
yy277:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy278;
		default:	goto yy2;
		}
yy278:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy279;
		default:	goto yy2;
		}
yy279:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy280;
		default:	goto yy2;
		}
yy280:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy281;
		default:	goto yy2;
		}
yy281:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy190;
		default:	goto yy2;
		}
yy282:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy283;
		default:	goto yy2;
		}
yy283:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy284;
		default:	goto yy2;
		}
yy284:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy285;
		default:	goto yy2;
		}
yy285:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy192;
		default:	goto yy2;
		}
yy286:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy287;
		default:	goto yy2;
		}
yy287:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy288;
		default:	goto yy2;
		}
yy288:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy289;
		default:	goto yy2;
		}
yy289:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy290;
		default:	goto yy2;
		}
yy290:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy291;
		default:	goto yy2;
		}
yy291:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy292;
		default:	goto yy2;
		}
yy292:
		yyaccept = 11;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy293;
		default:	goto yy195;
		}
yy293:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy294;
		default:	goto yy2;
		}
yy294:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy295;
		default:	goto yy2;
		}
yy295:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy296;
		default:	goto yy2;
		}
yy296:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy297;
		default:	goto yy2;
		}
yy297:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy298;
		default:	goto yy2;
		}
yy298:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy197;
		default:	goto yy2;
		}
yy299:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy300;
		default:	goto yy2;
		}
yy300:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy301;
		default:	goto yy2;
		}
yy301:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy302;
		default:	goto yy2;
		}
yy302:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy303;
		default:	goto yy2;
		}
yy303:
		yyaccept = 2;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy304;
		default:	goto yy31;
		}
yy304:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy305;
		default:	goto yy2;
		}
yy305:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy306;
		default:	goto yy2;
		}
yy306:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy307;
		default:	goto yy2;
		}
yy307:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy34;
		default:	goto yy2;
		}
yy308:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy326;
		default:	goto yy2;
		}
yy309:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy310;
		default:	goto yy2;
		}
yy310:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy311;
		default:	goto yy2;
		}
yy311:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy312;
		default:	goto yy2;
		}
yy312:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy313;
		default:	goto yy2;
		}
yy313:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy314;
		default:	goto yy2;
		}
yy314:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy315;
		default:	goto yy2;
		}
yy315:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy316;
		default:	goto yy2;
		}
yy316:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy317;
		default:	goto yy2;
		}
yy317:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy318;
		default:	goto yy2;
		}
yy318:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy319;
		default:	goto yy2;
		}
yy319:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy320;
		default:	goto yy2;
		}
yy320:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy321;
		default:	goto yy2;
		}
yy321:
		yyaccept = 9;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy322;
		default:	goto yy158;
		}
yy322:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy323;
		default:	goto yy2;
		}
yy323:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy324;
		default:	goto yy2;
		}
yy324:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy325;
		default:	goto yy2;
		}
yy325:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy161;
		default:	goto yy2;
		}
yy326:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy327;
		default:	goto yy2;
		}
yy327:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy328;
		default:	goto yy2;
		}
yy328:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy329;
		default:	goto yy2;
		}
yy329:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy330;
		default:	goto yy2;
		}
yy330:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy331;
		default:	goto yy2;
		}
yy331:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy332;
		default:	goto yy2;
		}
yy332:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy333;
		default:	goto yy2;
		}
yy333:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy334;
		default:	goto yy2;
		}
yy334:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy335;
		default:	goto yy2;
		}
yy335:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy336;
		default:	goto yy2;
		}
yy336:
		yyaccept = 8;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy337;
		default:	goto yy151;
		}
yy337:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy338;
		default:	goto yy2;
		}
yy338:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy339;
		default:	goto yy2;
		}
yy339:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy340;
		default:	goto yy2;
		}
yy340:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy154;
		default:	goto yy2;
		}
yy341:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy342;
		default:	goto yy2;
		}
yy342:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy347;
		case 'g':	goto yy346;
		case 'p':	goto yy345;
		case 's':	goto yy344;
		case 't':	goto yy343;
		default:	goto yy2;
		}
yy343:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy398;
		default:	goto yy2;
		}
yy344:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy389;
		case 't':	goto yy388;
		default:	goto yy2;
		}
yy345:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy366;
		case 'r':	goto yy365;
		default:	goto yy2;
		}
yy346:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy352;
		default:	goto yy2;
		}
yy347:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy348;
		default:	goto yy2;
		}
yy348:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy349;
		default:	goto yy2;
		}
yy349:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy350;
		default:	goto yy2;
		}
yy350:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy351;
		default:	goto yy2;
		}
yy351:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy120;
		default:	goto yy2;
		}
yy352:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy353;
		default:	goto yy2;
		}
yy353:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy354;
		default:	goto yy2;
		}
yy354:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy355;
		default:	goto yy2;
		}
yy355:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy356;
		default:	goto yy2;
		}
yy356:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy357;
		default:	goto yy2;
		}
yy357:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy358;
		default:	goto yy2;
		}
yy358:
		yyaccept = 7;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy359;
		default:	goto yy123;
		}
yy359:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy360;
		default:	goto yy2;
		}
yy360:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy361;
		default:	goto yy2;
		}
yy361:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy362;
		default:	goto yy2;
		}
yy362:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy363;
		default:	goto yy2;
		}
yy363:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy364;
		default:	goto yy2;
		}
yy364:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy125;
		default:	goto yy2;
		}
yy365:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy378;
		default:	goto yy2;
		}
yy366:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy367;
		default:	goto yy2;
		}
yy367:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy368;
		default:	goto yy2;
		}
yy368:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy369;
		default:	goto yy2;
		}
yy369:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy370;
		default:	goto yy2;
		}
yy370:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy371;
		default:	goto yy2;
		}
yy371:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy372;
		default:	goto yy2;
		}
yy372:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy373;
		default:	goto yy2;
		}
yy373:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy374;
		default:	goto yy2;
		}
yy374:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy375;
		default:	goto yy2;
		}
yy375:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy376;
		default:	goto yy2;
		}
yy376:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy377;
		default:	goto yy2;
		}
yy377:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy130;
		default:	goto yy2;
		}
yy378:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy379;
		default:	goto yy2;
		}
yy379:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy380;
		default:	goto yy2;
		}
yy380:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy381;
		default:	goto yy2;
		}
yy381:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy382;
		default:	goto yy2;
		}
yy382:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy383;
		default:	goto yy2;
		}
yy383:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy384;
		default:	goto yy2;
		}
yy384:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy385;
		default:	goto yy2;
		}
yy385:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy386;
		default:	goto yy2;
		}
yy386:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy387;
		default:	goto yy2;
		}
yy387:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy132;
		default:	goto yy2;
		}
yy388:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy393;
		default:	goto yy2;
		}
yy389:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy390;
		default:	goto yy2;
		}
yy390:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy391;
		default:	goto yy2;
		}
yy391:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy392;
		default:	goto yy2;
		}
yy392:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy135;
		default:	goto yy2;
		}
yy393:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy394;
		default:	goto yy2;
		}
yy394:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy395;
		default:	goto yy2;
		}
yy395:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy396;
		default:	goto yy2;
		}
yy396:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy397;
		default:	goto yy2;
		}
yy397:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy137;
		default:	goto yy2;
		}
yy398:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy399;
		default:	goto yy2;
		}
yy399:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy400;
		default:	goto yy2;
		}
yy400:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy401;
		default:	goto yy2;
		}
yy401:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy402;
		default:	goto yy2;
		}
yy402:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy403;
		default:	goto yy2;
		}
yy403:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy404;
		default:	goto yy2;
		}
yy404:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy405;
		default:	goto yy2;
		}
yy405:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy142;
		default:	goto yy2;
		}
yy406:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy451;
		default:	goto yy2;
		}
yy407:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy408;
		default:	goto yy2;
		}
yy408:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy409;
		default:	goto yy2;
		}
yy409:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy410;
		default:	goto yy2;
		}
yy410:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy412;
		case 'r':	goto yy411;
		case 's':	goto yy413;
		default:	goto yy2;
		}
yy411:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy443;
		default:	goto yy2;
		}
yy412:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy432;
		default:	goto yy2;
		}
yy413:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy414;
		default:	goto yy2;
		}
yy414:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy415;
		default:	goto yy2;
		}
yy415:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy416;
		default:	goto yy2;
		}
yy416:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy417;
		default:	goto yy2;
		}
yy417:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy418;
		default:	goto yy2;
		}
yy418:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy419;
		default:	goto yy2;
		}
yy419:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy420;
		case 'm':	goto yy421;
		default:	goto yy2;
		}
yy420:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy428;
		default:	goto yy2;
		}
yy421:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy422;
		default:	goto yy2;
		}
yy422:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy423;
		default:	goto yy2;
		}
yy423:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy424;
		default:	goto yy2;
		}
yy424:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy425;
		default:	goto yy2;
		}
yy425:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy426;
		default:	goto yy2;
		}
yy426:
		++opt;
#line 1247 "cplus2asp.re2c"
		{ return OPT_MODE_STATIC_MANUAL; }
#line 3586 "<stdout>"
yy428:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy429;
		default:	goto yy2;
		}
yy429:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy430;
		default:	goto yy2;
		}
yy430:
		++opt;
#line 1246 "cplus2asp.re2c"
		{ return OPT_MODE_STATIC_AUTO; }
#line 3603 "<stdout>"
yy432:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy433;
		default:	goto yy2;
		}
yy433:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy434;
		default:	goto yy2;
		}
yy434:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy435;
		default:	goto yy2;
		}
yy435:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy436;
		default:	goto yy2;
		}
yy436:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy437;
		default:	goto yy2;
		}
yy437:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy438;
		default:	goto yy2;
		}
yy438:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy439;
		default:	goto yy2;
		}
yy439:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy440;
		default:	goto yy2;
		}
yy440:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy441;
		default:	goto yy2;
		}
yy441:
		++opt;
#line 1248 "cplus2asp.re2c"
		{ return OPT_MODE_INCREMENTAL; }
#line 3662 "<stdout>"
yy443:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy444;
		default:	goto yy2;
		}
yy444:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy445;
		default:	goto yy2;
		}
yy445:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy446;
		default:	goto yy2;
		}
yy446:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy447;
		default:	goto yy2;
		}
yy447:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy448;
		default:	goto yy2;
		}
yy448:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy449;
		default:	goto yy2;
		}
yy449:
		++opt;
#line 1249 "cplus2asp.re2c"
		{ return OPT_MODE_REACTIVE; }
#line 3703 "<stdout>"
yy451:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy452;
		default:	goto yy2;
		}
yy452:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy453;
		default:	goto yy2;
		}
yy453:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy454;
		default:	goto yy2;
		}
yy454:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy455;
		default:	goto yy2;
		}
yy455:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy456;
		default:	goto yy2;
		}
yy456:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy457;
		default:	goto yy2;
		}
yy457:
		yych = *++opt;
		switch (yych) {
		case 'x':	goto yy458;
		default:	goto yy2;
		}
yy458:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy459;
		default:	goto yy2;
		}
yy459:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy460;
		default:	goto yy2;
		}
yy460:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy461;
		default:	goto yy2;
		}
yy461:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy111;
		default:	goto yy2;
		}
yy462:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy463;
		default:	goto yy2;
		}
yy463:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy464;
		default:	goto yy2;
		}
yy464:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy465;
		default:	goto yy2;
		}
yy465:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy466;
		case 'p':	goto yy469;
		case 's':	goto yy468;
		case 't':	goto yy467;
		default:	goto yy2;
		}
yy466:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy505;
		default:	goto yy2;
		}
yy467:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy497;
		default:	goto yy2;
		}
yy468:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy493;
		default:	goto yy2;
		}
yy469:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy471;
		case 'r':	goto yy470;
		default:	goto yy2;
		}
yy470:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy483;
		default:	goto yy2;
		}
yy471:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy472;
		default:	goto yy2;
		}
yy472:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy473;
		default:	goto yy2;
		}
yy473:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy474;
		default:	goto yy2;
		}
yy474:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy475;
		default:	goto yy2;
		}
yy475:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy476;
		default:	goto yy2;
		}
yy476:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy477;
		default:	goto yy2;
		}
yy477:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy478;
		default:	goto yy2;
		}
yy478:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy479;
		default:	goto yy2;
		}
yy479:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy480;
		default:	goto yy2;
		}
yy480:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy481;
		default:	goto yy2;
		}
yy481:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy482;
		default:	goto yy2;
		}
yy482:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy95;
		default:	goto yy2;
		}
yy483:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy484;
		default:	goto yy2;
		}
yy484:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy485;
		default:	goto yy2;
		}
yy485:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy486;
		default:	goto yy2;
		}
yy486:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy487;
		default:	goto yy2;
		}
yy487:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy488;
		default:	goto yy2;
		}
yy488:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy489;
		default:	goto yy2;
		}
yy489:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy490;
		default:	goto yy2;
		}
yy490:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy491;
		default:	goto yy2;
		}
yy491:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy492;
		default:	goto yy2;
		}
yy492:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy97;
		default:	goto yy2;
		}
yy493:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy494;
		default:	goto yy2;
		}
yy494:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy495;
		default:	goto yy2;
		}
yy495:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy496;
		default:	goto yy2;
		}
yy496:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy99;
		default:	goto yy2;
		}
yy497:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy498;
		default:	goto yy2;
		}
yy498:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy499;
		default:	goto yy2;
		}
yy499:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy500;
		default:	goto yy2;
		}
yy500:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy501;
		default:	goto yy2;
		}
yy501:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy502;
		default:	goto yy2;
		}
yy502:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy503;
		default:	goto yy2;
		}
yy503:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy504;
		default:	goto yy2;
		}
yy504:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy104;
		default:	goto yy2;
		}
yy505:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy506;
		default:	goto yy2;
		}
yy506:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy507;
		default:	goto yy2;
		}
yy507:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy508;
		default:	goto yy2;
		}
yy508:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy509;
		default:	goto yy2;
		}
yy509:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy510;
		default:	goto yy2;
		}
yy510:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy511;
		default:	goto yy2;
		}
yy511:
		yyaccept = 6;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy512;
		default:	goto yy107;
		}
yy512:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy513;
		default:	goto yy2;
		}
yy513:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy514;
		default:	goto yy2;
		}
yy514:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy515;
		default:	goto yy2;
		}
yy515:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy516;
		default:	goto yy2;
		}
yy516:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy517;
		default:	goto yy2;
		}
yy517:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy109;
		default:	goto yy2;
		}
yy518:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy519;
		default:	goto yy2;
		}
yy519:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy520;
		default:	goto yy2;
		}
yy520:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy521;
		default:	goto yy2;
		}
yy521:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy522;
		default:	goto yy2;
		}
yy522:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy523;
		default:	goto yy2;
		}
yy523:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy524;
		default:	goto yy2;
		}
yy524:
		yyaccept = 4;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy525;
		default:	goto yy73;
		}
yy525:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy527;
		case 's':	goto yy526;
		default:	goto yy2;
		}
yy526:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy530;
		default:	goto yy2;
		}
yy527:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy528;
		default:	goto yy2;
		}
yy528:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy529;
		default:	goto yy2;
		}
yy529:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy77;
		default:	goto yy2;
		}
yy530:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy531;
		default:	goto yy2;
		}
yy531:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy532;
		default:	goto yy2;
		}
yy532:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy533;
		default:	goto yy2;
		}
yy533:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy534;
		default:	goto yy2;
		}
yy534:
		yyaccept = 5;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy535;
		default:	goto yy80;
		}
yy535:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy536;
		default:	goto yy2;
		}
yy536:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy537;
		default:	goto yy2;
		}
yy537:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy538;
		default:	goto yy2;
		}
yy538:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy83;
		default:	goto yy2;
		}
yy539:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy540;
		default:	goto yy2;
		}
yy540:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy541;
		default:	goto yy2;
		}
yy541:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy542;
		default:	goto yy2;
		}
yy542:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy547;
		case 'g':	goto yy543;
		case 'p':	goto yy546;
		case 's':	goto yy545;
		case 't':	goto yy544;
		default:	goto yy2;
		}
yy543:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy587;
		default:	goto yy2;
		}
yy544:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy579;
		default:	goto yy2;
		}
yy545:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy575;
		default:	goto yy2;
		}
yy546:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy553;
		case 'r':	goto yy552;
		default:	goto yy2;
		}
yy547:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy548;
		default:	goto yy2;
		}
yy548:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy549;
		default:	goto yy2;
		}
yy549:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy550;
		default:	goto yy2;
		}
yy550:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy551;
		default:	goto yy2;
		}
yy551:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy51;
		default:	goto yy2;
		}
yy552:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy565;
		default:	goto yy2;
		}
yy553:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy554;
		default:	goto yy2;
		}
yy554:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy555;
		default:	goto yy2;
		}
yy555:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy556;
		default:	goto yy2;
		}
yy556:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy557;
		default:	goto yy2;
		}
yy557:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy558;
		default:	goto yy2;
		}
yy558:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy559;
		default:	goto yy2;
		}
yy559:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy560;
		default:	goto yy2;
		}
yy560:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy561;
		default:	goto yy2;
		}
yy561:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy562;
		default:	goto yy2;
		}
yy562:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy563;
		default:	goto yy2;
		}
yy563:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy564;
		default:	goto yy2;
		}
yy564:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy56;
		default:	goto yy2;
		}
yy565:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy566;
		default:	goto yy2;
		}
yy566:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy567;
		default:	goto yy2;
		}
yy567:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy568;
		default:	goto yy2;
		}
yy568:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy569;
		default:	goto yy2;
		}
yy569:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy570;
		default:	goto yy2;
		}
yy570:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy571;
		default:	goto yy2;
		}
yy571:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy572;
		default:	goto yy2;
		}
yy572:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy573;
		default:	goto yy2;
		}
yy573:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy574;
		default:	goto yy2;
		}
yy574:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy58;
		default:	goto yy2;
		}
yy575:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy576;
		default:	goto yy2;
		}
yy576:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy577;
		default:	goto yy2;
		}
yy577:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy578;
		default:	goto yy2;
		}
yy578:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy60;
		default:	goto yy2;
		}
yy579:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy580;
		default:	goto yy2;
		}
yy580:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy581;
		default:	goto yy2;
		}
yy581:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy582;
		default:	goto yy2;
		}
yy582:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy583;
		default:	goto yy2;
		}
yy583:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy584;
		default:	goto yy2;
		}
yy584:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy585;
		default:	goto yy2;
		}
yy585:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy586;
		default:	goto yy2;
		}
yy586:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy65;
		default:	goto yy2;
		}
yy587:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy588;
		default:	goto yy2;
		}
yy588:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy589;
		default:	goto yy2;
		}
yy589:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy590;
		default:	goto yy2;
		}
yy590:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy591;
		default:	goto yy2;
		}
yy591:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy592;
		default:	goto yy2;
		}
yy592:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy593;
		default:	goto yy2;
		}
yy593:
		yyaccept = 3;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy594;
		default:	goto yy68;
		}
yy594:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy595;
		default:	goto yy2;
		}
yy595:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy596;
		default:	goto yy2;
		}
yy596:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy597;
		default:	goto yy2;
		}
yy597:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy598;
		default:	goto yy2;
		}
yy598:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy599;
		default:	goto yy2;
		}
yy599:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy70;
		default:	goto yy2;
		}
yy600:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy601;
		default:	goto yy2;
		}
yy601:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy602;
		default:	goto yy2;
		}
yy602:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy603;
		default:	goto yy2;
		}
yy603:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy604;
		default:	goto yy2;
		}
yy604:
		yyaccept = 1;
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy605;
		default:	goto yy25;
		}
yy605:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy606;
		default:	goto yy2;
		}
yy606:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy607;
		default:	goto yy2;
		}
yy607:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy608;
		default:	goto yy2;
		}
yy608:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy609;
		default:	goto yy2;
		}
yy609:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy28;
		default:	goto yy2;
		}
yy610:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy611;
		default:	goto yy2;
		}
yy611:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy612;
		default:	goto yy2;
		}
yy612:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy22;
		default:	goto yy2;
		}
yy613:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy621;
		default:	goto yy2;
		}
yy614:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy615;
		default:	goto yy2;
		}
yy615:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy616;
		default:	goto yy2;
		}
yy616:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy617;
		default:	goto yy2;
		}
yy617:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy618;
		default:	goto yy2;
		}
yy618:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy619;
		default:	goto yy2;
		}
yy619:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy620;
		default:	goto yy2;
		}
yy620:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy41;
		default:	goto yy2;
		}
yy621:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy622;
		default:	goto yy2;
		}
yy622:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy623;
		default:	goto yy2;
		}
yy623:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy624;
		default:	goto yy2;
		}
yy624:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy625;
		default:	goto yy2;
		}
yy625:
		++opt;
		switch ((yych = *opt)) {
		case 'e':	goto yy38;
		default:	goto yy2;
		}
	}
#line 1285 "cplus2asp.re2c"

}

/**
 * Shows the help dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showHelp(std::string const& execName, std::ostream& out) {
	out << "Usage: " << execName << " INPUT_FILES [OPTIONS] [CONSTANTS] [NUM_SOLUTIONS]" << endl
		  << "Calls cplus2asp.bin (translator), f2lp (pre-processor), gringo (grounder)," << endl
		  << "clasp (solver), and as2transition (post-processor) on the input files" << endl
		  << "(CCalc-style files that have been translated to ASP/f2lp syntax)," << endl
		  << "adding \"standard\" CCalc to ASP translation support files and" << endl
		  << "outputting the results from as2transition." << endl
		  << "  INPUT_FILES is a series of files in CCalc, ASP, or f2lp syntax." << endl
		  << "              At least one input file is required." << endl
		  << "              Any input files that have extensions \".f2lp\" or \".lp\"" << endl
		  << "              will automatically not be passed to the translator." << endl
		  << "  OPTIONS are optional arguments that change the program's behavior." << endl
		  << "  CONSTANTS are constant definitions that are passed to the grounder." << endl
		  << "            There are three special constants that are often seen in" << endl
		  << "            CCalc programs, and so can be useful to manually set." << endl
		  << "            These are not required to be defined if special \"hint\"" << endl
		  << "            comments are placed in the output from the translator." << endl
		  << "            maxAdditive - The maximum additive integer (only needed if" << endl
		  << "                          using additive fluents/actions)." << endl
		  << "            maxstep - The maximum time step to consider." << endl
		  << "            query - The query number (i.e., label) to select." << endl
		  << "  NUM_SOLUTIONS is the desired number of solutions for the solver to find." << endl
		  << "                This should be a non-negative integer (0 or greater)." << endl
		  << "                If not specified, defaults to 1." << endl
		  << endl
		  << "Normal Program Options:" << endl
		  << "  -auto" << endl
		  << "  --automated makes the program run in automated mode, so it won't prompt" << endl
		  << "              or ask for any information from the user." << endl
		  << "  CONST=VALUE" << endl
		  << "  -c CONST=VALUE" << endl
		  << "  --const CONST=VALUE declares a constant & value pair to pass to gringo." << endl
		  << "                      You will probably need to at least declare values for" << endl
		  << "                      the constants maxstep, query, and possibly maxAdditive." << endl
		  << "  --help shows this usage message." << endl
		  << "  -v" << endl
		  << "  --version outputs version information." << endl
		  << "  -m [MODE]" << endl
		  << "  --mode=[MODE] sets the program to run in the specified running mode." << endl
		  << "                [MODE] can be one of the following: " << endl
		  << "                 * static-auto - uses a static translation and automatically " << endl
		  << "                                 advances the queries maximum time step." << endl
		  << "                 * static-manual - uses a static translation and queries the user " << endl
		  << "                                   each time a solution isn't found for a new time step." << endl
		  << "                 * incremental - [default] uses an incremental translation and solver for " << endl
		  << "                                 better efficiency while ranging over maxsteps in a query." << endl
		  << "                 * reactive - uses a incremental translation and reactive solver in order " << endl
		  << "                              to dynamically adding abnormality constants during execution."  << endl
		  << endl
		  << "Extra Program Options:" << endl
		  << "  Options with [PROG] or [PROGRAM] in their name affect individual" << endl
		  << "  programs in the tool chain, depending on [PROG] or [PROGRAM]'s value." << endl
		  << "  Any option with [PROG] in its name should have [PROG] replaced with one of:" << endl
		  << "    gr (grounder), pre (pre-processor), post (post-processor), so (solver)," << endl
		  << "    trans (translator), or br (reactive bridge)." << endl
		  << "  Replace [PROGRAM] in the applicable options with one of the following:" << endl
		  << "    grounder, pre-processor, post-processor, solver, translator, or bridge." << endl
		  << endl
		  << "  -[PROG] PATH" << endl
		  << "  --[PROGRAM] PATH gives a new path to the desired tool chain program." << endl
		  << "  -[PROG]opt \"OPTIONS\"" << endl
		  << "  --[PROGRAM]-opts \"OPTIONS\" passes OPTIONS to the given tool chain program." << endl
		  << "  -from[PROG]" << endl
		  << "  --from-[PROGRAM] starts running the tool chain from the given program." << endl
		  << "  -just[PROG]" << endl
		  << "  --just-[PROGRAM] removes all but the given program from the tool chain." << endl
		  << "  -nodel" << endl
		  << "  --no-delete stops the program from deleting intermediate files created" << endl
		  << "              during processing, grounding, and solving." << endl
		  << "  -nostd" << endl
		  << "  --no-standard removes the standard translation files from the call to the" << endl
		  << "                pre-processor. Useful if supplying different \"standard\"" << endl
		  << "                files, or for debugging of input file errors." << endl
		  << "  -to[PROG]" << endl
		  << "  --to-[PROGRAM] stops running the tool chain after the given program." << endl
		  << endl
		  << "  Example: " << execName << " myProgram.cp" << endl
		  << "           would translate and process the file \"myProgram.cp\"," << endl
		  << "           interactively asking which query from the file to run, returning" << endl
		  << "           the first solution found (if any)." << endl
		  << "  Example: " << execName << " myProgram.cp query=1 2" << endl
		  << "           does the same as above, except it automatically runs Query 1" << endl
		  << "           (assuming it can find or derive maxstep), and tries to find two" << endl
		  << "           solutions to the query." << endl
		  << "  Example: " << execName << " myProgram.cp query=1 maxstep=3 -so cmodels 2" << endl
		  << "           would do the same as above, but it changes the solver to cmodels" << endl
		  << "           and forces maxstep to be 3." << endl
		  << "  Example: " << execName << " myProgram.f2lp --just-pre-processor" << endl
		  << "           skips running the translator because the input file has" << endl
		  << "           the .f2lp extension, just running f2lp (the pre-processor)" << endl
		  << "           on the contents of \"myProgram.f2lp\", outputting the results." << endl;
	return out;
}

/**
 * Shows the version dialog.
 * @param execName - The name of the executable we are running.
 * @param out - The output stream to send the help message to.
 * @return out.
 */
std::ostream& showVersion(std::string const& execName, std::ostream& out) {
	// Show version information and quit.
	out << execName << " version " << VERSION_MAJOR;
	out << "." << VERSION_MINOR;
	if(VERSION_REV > 0) { cout << "." << VERSION_REV; }
	return out;
}


unsigned char scanFilesForConstants(Config& config, bool ranTranslator, unsigned char neededConstants) {


	// Go through the input file(s) looking for special "hint" comments
	// that tell us the value of maxAdditive, maxstep, and/or query.
	// Loop through the file(s) looking for hints for any undefined constants.

	// Start with the output of the translator
	if(config.run(Config::TC_TRANSLATOR))
	{	// Start with the output from the translator.
		debug("Starting with the translator output file...",true);
		neededConstants = scanForConstants(config, config.intTransFile(), neededConstants);
	}


	// Scan all other input files
	for (Config::Toolchain tool = Config::TC_BEGIN; tool < Config::TC_END; tool = (Config::Toolchain)(((int) tool) + 1)) {
		for (Config::InputList::const_iterator it = config.beginInput(tool); it != config.endInput(tool); it++) {
			neededConstants = scanForConstants(config, *it, neededConstants);
		}

	}

	return neededConstants;
}





unsigned char scanForConstants(Config& config, std::string const& file, unsigned char neededConstants) {
	std::string tempLine = "";
	std::string tempString;
	std::ifstream fin;

	std::string findText = "";
	size_t tempPos, tempPos2;
	size_t currentLine = 0;

	bool foundQuery = false;
	unsigned int tempInt;
	Config::Query tempQuery;					// Temporary place to store query information.
	std::stringstream nameBuilder;


	// Open the file
	fin.open(file.c_str());

	// If at any point we fail to open an input file, just skip over it...
	if(fin.fail()) {
		// Throw a warning!
		warning("Unable to open file '%s' for scanning. Skipping it.", true, file.c_str());
		return neededConstants;
	}


	while(!fin.eof()) {
		// Go line by line looking for specially-formatted comments.
		getline(fin, tempLine);
		currentLine++;
		if (tempLine.empty()) continue;

		// Look for a maxadditive definition
		if (neededConstants & CONST_MAXADDITIVE_MASK) {
			// Look for a maxAdditive hint comment.
			// If one is found, set maxAdditive

			findText = "% [MaxAdditive:";
			tempPos = tempLine.find(findText);

			if(tempPos != string::npos)
			{
				debug("Found what appears to be a maxAdditive definition: '%s'", true, tempLine.c_str());
				tempPos += findText.length();
				tempPos2 = tempLine.find("]", tempPos);
				if(tempPos2 != string::npos && tempPos2 > tempPos)
				{
					tempString = tempLine.substr(tempPos, tempPos2 - tempPos);
					if(from_string(tempInt, tempString))
					{
						// Found maxAdditive, set it and flag that we need the additive standard file.
						pragma("Found a maxAdditive hint. Setting maxAdditive to '%d'.", true, tempInt);
						config.intConfigOpt(Config::OPT_MAXADDITIVE, tempInt);
						neededConstants &= ~CONST_MAXADDITIVE_MASK;
					} else {
						// It looks like this hint is malformed. Be sure to warn them!
						warning("The maxAdditive hint '%s' is malformed. Ignoring it.", true, tempLine.c_str());
					}
				}
			}
		}

		// Look for query definitions

		if ((neededConstants & CONST_MAXSTEP_MASK)
				|| (neededConstants & CONST_QUERY_MASK)) {

			// Look for a query hint comment.
			// Collect any that are found.
			findText = "% [Query: Label:";

			if((tempPos = tempLine.find(findText)) != std::string::npos
					&& (tempPos += findText.length())
					&& (tempPos2 = tempLine.find_first_of(",]", tempPos)) != std::string::npos
					&& tempPos2 > tempPos)
			{
				foundQuery = false;
				debug("Found what appears to be a query definition: '%s'", true, tempLine.c_str());
				tempString = tempLine.substr(tempPos, tempPos2 - tempPos);

				if(from_string(tempInt, tempString)) {
					// Found a query's label, keep it and look for the maxstep...
					tempQuery.id = tempInt;

					findText = "Maxstep:";
					if (tempLine.at(tempPos2) != ']' // Don't bother if we're at the end of the hint...
							&& (tempPos = tempLine.find(findText, tempPos2)) != std::string::npos
							&& (tempPos += findText.length())
							&& (tempPos2 = tempLine.find("]", tempPos)) != std::string::npos
							&& tempPos2 > tempPos) {

						// This would be a maximum step definition
						// This could be an integer M
						// Or this could be a range M::N or M..N
						tempString = tempLine.substr(tempPos, tempPos2 - tempPos);

						size_t sepBegin, sepEnd;

						if (((sepBegin = tempString.find("::")) != std::string::npos
								|| (sepBegin = tempString.find("..")) != std::string::npos)
							&& (sepEnd = sepBegin + 2)
							&& from_string(tempQuery.minstep, tempString.substr(0, sepBegin))
							&& from_string(tempQuery.maxstep, tempString.substr(sepEnd, std::string::npos))){
							// The query is good and contains a minstep and maxstep.
							foundQuery = true;
						} else if (from_string(tempQuery.maxstep, tempString)) {
							// The query is good and contains only a maxstep.
							// The minstep is undefined.
							tempQuery.minstep = Config::UNDEFINED;
							foundQuery = true;
						} else {
							// The step information is malformed.
							// Warn them...
							warning("[%s:%d]: The query hint '%s' has a malformed step maxstep parameter. Ignoring the maximum step information...", true, file.c_str(), currentLine, tempLine.c_str());
							tempQuery.minstep = Config::UNDEFINED;
							tempQuery.maxstep = Config::UNDEFINED;
							foundQuery = true;
						}
					} else {
						// No maxstep information to be found. This is ok.
						tempQuery.maxstep = Config::UNDEFINED;
						tempQuery.maxstep = Config::UNDEFINED;
						foundQuery = true;
					}
				} else {
					// The query ID is malformed... Warn them and move on.
					warning("[%s:%d]: The query hint '%s' has a malformed query ID. Ignoring it.", true, file.c_str(), currentLine, tempLine.c_str());
				}

				if (foundQuery) {
					// The query was good. We can go ahead and register it.
					// Generate a name...
					nameBuilder.str("");
					nameBuilder << "Query " << tempQuery.id;

					//if (tempQuery.minstep != Config::UNDEFINED && tempQuery.maxstep != Config::UNDEFINED)
					//	nameBuilder << " (" << tempQuery.minstep << ".." << tempQuery.maxstep <<")";
					//else if (tempQuery.maxstep != Config::UNDEFINED)
					//	nameBuilder << " (" << tempQuery.maxstep <<")";

					tempQuery.name = nameBuilder.str();

					// Build the command
					nameBuilder.str("");
					nameBuilder << tempQuery.id;
					tempQuery.cmd = nameBuilder.str();

					// Attempt to register it.
					debug("Registering query '%s'...", true, tempQuery.name.c_str());
					if (!config.addQuery(tempQuery)) {
						warning("[%s:%d]: Detected duplicate queries with ID '%d'. Ignoring the most recent one found.", file.c_str(), currentLine, tempQuery.id);
					}
				}
			}
		}
	}

	// Clean up and move on...
	fin.close();
	return neededConstants;
}

// Asks the user to select a query.
unsigned int queryUserForQuery(Config const& config)
{
	unsigned int ret = Config::UNDEFINED;
	std::string line;

	bool goodInput = false;
	std::cout << "The following queries are available to run:" << endl;

	for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries(); it++) {
		std::cout << it->second.cmd << ": " << it->second.name;

		if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED)
				|| (!config.customConfigOpt(Config::OPT_MAXSTEP) && it->second.maxstep != Config::UNDEFINED) )
			std::cout << " -";

		if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.minstep != Config::UNDEFINED))
			std::cout << " minstep=" << it->second.minstep;

		if ((!config.customConfigOpt(Config::OPT_MINSTEP) && it->second.maxstep != Config::UNDEFINED))
			std::cout << " maxstep=" << it->second.maxstep;

		std::cout << std::endl;
	}

	// provide an exit
	std::cout << EXIT_CMD << ": Exit the program." << std::endl;


	while (!goodInput) {

		// Get user input
		std::cout << "Please select a query to run: ";
		std::cin >> line;
		line = trimWhitespace(line);

		// Make sure they don't want to exit.
		if (line == EXIT_CMD) {
			// crap, they do. returning UNDEFINED will indicate this.
			goodInput = true;
			ret = Config::UNDEFINED;
		} else {

			// Scan through the queries and try to find the one they (hopefully) selected.
			for (Config::QueryMap::const_iterator it = config.beginQueries(); it != config.endQueries() && !goodInput; it++) {
				if (it->second.cmd == line) {
					// We have a match!
					goodInput = true;
					ret = it->second.id;
				}
			}

		}

		if (!goodInput) {
			std::cout << "Error: Invalid choice." << std::endl;
		}

	}

	return ret;
}

// Asks the user to select a max step.
unsigned int queryUserForConstant(Config const& config, std::string const& constant, unsigned int defVal) {
	unsigned int ret = Config::UNDEFINED;
	std::string line;
	bool goodInput = false;

	while (!goodInput) {

		// Prompt user input
		std::cout << "Please select a (non-negative) value for the " << constant << ". You may input 'exit' to exit the program." << std::endl;
		std::cout << "Selected value";
		if (defVal != Config::UNDEFINED) std::cout << " [" << defVal << "]";
		std::cout << ": ";


		// Get user input
		std::cin >> line;
		line = trimWhitespace(line);

		// Make sure they don't want to exit.
		if (line == EXIT_CMD) {
			// crap, they do. returning UNDEFINED will indicate this.
			goodInput = true;
			ret = Config::UNDEFINED;
		}
		// Check if they want to go for a default value
		else if (defVal != Config::UNDEFINED && line == "") {
			ret = defVal;
			goodInput = true;
		}
		// Check if they have provided any other valid input...
		else if (from_string(ret, line)) {
			goodInput = true;
		}

		if (!goodInput) {
			std::cout << "Error: Invalid selection." << std::endl;
		}

	}

	return ret;
}

int runTool(Config const& config, Config::Toolchain tool, unsigned int maxstep, std::string const& name) {
	std::string tmpCmd;
	int ret = TC_STAT_TOOLSKIPPED;

	if (!config.run(tool)) {
		debug("Skipping %s execution.", true, name.c_str());
	} else if (!config.cumulativeInputCount(tool)) {
		pragma("No input files for the %s have been specified. Skipping it.", true, name.c_str());
	} else {
		// Run the translator...
		tmpCmd = config.compileCommandLine(tool, maxstep);
		debug("Running the %s with command: %s",true,name.c_str(), tmpCmd.c_str());
		int stat = system(tmpCmd.c_str());
		ret = WEXITSTATUS(stat);
	}

	return ret;
}

void cleanup(Config const& config, bool const* ran) {
	std::ostringstream builder;
	std::string tmpCmd;
	bool filesToDelete = false;

	builder << "rm";

	if (config.boolConfigOpt(Config::OPT_DISCARD_F2LP)) {
		// Discard F2LP intermediates...
		if (ran[Config::TC_PREPROC]) {
			builder << " " << F2LP_INPUT_FILE << " " << F2LP_OUTPUT_FILE;
			filesToDelete = true;
		}
	}

	if (config.boolConfigOpt(Config::OPT_DISCARD_INTERMEDIATE)) {
		if (ran[Config::TC_TRANSLATOR]) {
			builder << " " << config.intTransFile() << " " << config.intTransSymTabFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_PREPROC]) {
			builder << " " << config.intPreprocFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_GROUNDER]) {
			builder << " " << config.intGrdFile();
			filesToDelete = true;
		}

		if (ran[Config::TC_SOLVER]) {
			builder << " " << config.intSoFile();
			filesToDelete = true;
		}
	}

	builder << " 2> /dev/null";

	if (filesToDelete) {
		tmpCmd = builder.str();
		debug("Deleting temporary files with command '%s'.", true, tmpCmd.c_str());
		system(tmpCmd.c_str());
	} else {
		debug("There are no files to delete.", true);
	}
}

