% File: 3-towers-of-hanoi

:- macros
  N -> 3.

:- sorts
  peg;
  disk;
  integer >> posInteger.

:- objects
  1..N            :: posInteger;
  0               :: integer;
  p(posInteger)   :: peg;
  d(posInteger)   :: disk.

:- variables
  P,P1            :: posInteger;
  Pi,Pj           :: peg;
  DS,DS1          :: disk*;
  D,D1            :: disk;
  S,S1            :: 0..N.

:- constants
  top(peg)        :: inertialFluent(disk*);
  loc(disk)       :: inertialFluent(disk*);
  size(disk*)     :: inertialFluent(0..N);
  move(peg,peg)   :: exogenousAction.


constraint loc(D)=DS ->> size(D)<size(DS).

nonexecutable move(p(P),p(P1)) if top(p(P))=none.

/*
% effects

% top(Pi) := loc(top(Pi))    
move(Pi,Pj) causes top(Pi)=DS if top(Pi)=D & loc(D)=DS.

% loc(top(Pi)) := top(Pj)    
move(Pi,Pj) causes loc(D)=DS if top(Pi)=D & top(Pj)=DS.

% top(Pj) := top(Pi)         
move(Pi,Pj) causes top(Pj)=D if top(Pi)=D.

noconcurrency.

:- query
maxstep :: 7;
0: size(none)=3, size(d1)=2, size(d2)=1, size(d3)=0,
   loc(d1)=none,  loc(d2)=d1,  loc(d3)=d2,
   top(p1)=d3, top(p2)=none, top(p3)=none;
maxstep:
   loc(d1)=none, loc(d2)=d1, loc(d3)=d2, top(p3)=d3.

:- query
label :: 2;
maxstep :: 1;
0: size(none)=3, size(d1)=2, size(d2)=1, size(d3)=0,
   loc(d1)=none,  loc(d2)=d1,  loc(d3)=d2,
   top(p1)=d3, top(p2)=none, top(p3)=none;
0: move(p3,p1).

*/